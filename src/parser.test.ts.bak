import { describe, test, expect } from "bun:test"
import { Lexer } from "./lexer"
import { parseTokens } from "./parser"

function parse(source: string) {
  const lexer = new Lexer(source)
  const tokens = lexer.tokenize()
  const filteredTokens = tokens.filter((t) => t.type !== "WHITESPACE" && t.type !== "COMMENT")
  return parseTokens(filteredTokens)
}

describe("parser literals", () => {
  test("number literal", () => {
    const ast = parse("{ 42; }")
    expect(ast.type).toBe("Program")
    expect(ast.statements.length).toBe(1)
    const stmt = ast.statements[0]
    expect(stmt.type).toBe("ExpressionStatement")
    expect((stmt as any).expression.type).toBe("NumberLiteral")
    expect((stmt as any).expression.value).toBe(42)
  })

  test("string literal", () => {
    const ast = parse('{ "hello"; }')
    const stmt = ast.statements[0] as any
    expect(stmt.expression.type).toBe("StringLiteral")
    expect(stmt.expression.value).toBe("hello")
  })
})

describe("parser identifiers", () => {
  test("single identifier", () => {
    const ast = parse("{ x; }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.type).toBe("Identifier")
    expect(stmt.expression.name).toBe("x")
  })

  test("multi-character identifier", () => {
    const ast = parse("{ myVariable; }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.name).toBe("myVariable")
  })
})

describe("parser binary expressions", () => {
  test("addition", () => {
    const ast = parse("{ 1 + 2; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.type).toBe("BinaryExpression")
    expect(expr.operator).toBe("+")
    expect(expr.left.value).toBe(1)
    expect(expr.right.value).toBe(2)
  })

  test("subtraction", () => {
    const ast = parse("{ 5 - 3; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("-")
  })

  test("multiplication", () => {
    const ast = parse("{ 2 * 3; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("*")
  })

  test("division", () => {
    const ast = parse("{ 10 / 2; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("/")
  })

  test("modulo", () => {
    const ast = parse("{ 7 % 3; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("%")
  })
})

describe("parser logical expressions", () => {
  test("bitwise and", () => {
    const ast = parse("{ 1 & 2; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("&")
  })

  test("bitwise or", () => {
    const ast = parse("{ 1 | 2; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("|")
  })
})

describe("parser unary expressions", () => {
  test("negation", () => {
    const ast = parse("{ -x; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.type).toBe("UnaryExpression")
    expect(expr.operator).toBe("-")
    expect(expr.argument.type).toBe("Identifier")
    expect(expr.argument.name).toBe("x")
  })

  test("logical not", () => {
    const ast = parse("{ not 1; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.type).toBe("UnaryExpression")
    expect(expr.operator).toBe("not")
  })
})

describe("parser grouped expressions", () => {
  test("parenthesized expression", () => {
    const ast = parse("{ (1 + 2) * 3; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.type).toBe("BinaryExpression")
    expect(expr.operator).toBe("*")
    expect(expr.left.type).toBe("BinaryExpression")
    expect(expr.left.operator).toBe("+")
  })
})

describe("parser operator precedence", () => {
  test("multiplication before addition", () => {
    const ast = parse("{ 1 + 2 * 3; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("+")
    expect(expr.right.type).toBe("BinaryExpression")
    expect(expr.right.operator).toBe("*")
  })

  test("parentheses override precedence", () => {
    const ast = parse("{ (1 + 2) * 3; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("*")
    expect(expr.left.type).toBe("BinaryExpression")
    expect(expr.left.operator).toBe("+")
  })

  test("left associativity", () => {
    const ast = parse("{ 1 - 2 - 3; }")
    const expr = (ast.statements[0] as any).expression
    expect(expr.operator).toBe("-")
    expect(expr.left.type).toBe("BinaryExpression")
  })
})

describe("parser function calls", () => {
  test("call without arguments", () => {
    const ast = parse("{ foo(); }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.type).toBe("CallExpression")
    expect(stmt.expression.callee.name).toBe("foo")
    expect(stmt.expression.args.length).toBe(0)
  })

  test("call with one argument", () => {
    const ast = parse("{ foo(42); }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.args.length).toBe(1)
    expect(stmt.expression.args[0].type).toBe("NumberLiteral")
  })

  test("call with multiple arguments", () => {
    const ast = parse("{ foo(1, 2, 3); }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.args.length).toBe(3)
  })

  test("call with expression argument", () => {
    const ast = parse("{ foo(a + b); }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.args[0].type).toBe("BinaryExpression")
  })

  test("chained function call", () => {
    const ast = parse("{ foo(bar()); }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.args[0].type).toBe("CallExpression")
  })
})

describe("parser array literals", () => {
  test("empty array", () => {
    const ast = parse("{ []; }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.type).toBe("ArrayLiteral")
    expect(stmt.expression.elements.length).toBe(0)
  })

  test("array with numbers", () => {
    const ast = parse("{ [1, 2, 3]; }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.elements.length).toBe(3)
  })

  test("nested array", () => {
    const ast = parse("{ [[1, 2], [3, 4]]; }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.elements.length).toBe(2)
    expect(stmt.expression.elements[0].type).toBe("ArrayLiteral")
  })
})

describe("parser table literals", () => {
  test("empty table", () => {
    const ast = parse("{ {}; }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.type).toBe("TableLiteral")
    expect(stmt.expression.columns.length).toBe(0)
  })

  test("table with columns", () => {
    const ast = parse("{ { a: 1, b: 2 }; }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.columns.length).toBe(2)
    expect(stmt.expression.columns[0].name).toBe("a")
    expect(stmt.expression.columns[1].name).toBe("b")
  })
})

describe("parser if statements", () => {
  test("if without else", () => {
    const ast = parse("{ if (x > y) { x := x + 1; } }")
    const stmt = ast.statements[0] as any
    expect(stmt.type).toBe("Conditional")
    expect(stmt.condition.type).toBe("BinaryExpression")
    expect(stmt.falseBranch).toBeNull()
  })

  test("if with else", () => {
    const ast = parse("{ if (x > y) { x := 1; ELSE x := -1; } }")
    const stmt = ast.statements[0] as any
    expect(stmt.type).toBe("Conditional")
    expect(stmt.falseBranch).not.toBeNull()
  })
})

describe("parser while loops", () => {
  test("simple while loop", () => {
    const ast = parse("{ while (x < 10) { x := x + 1; } }")
    const stmt = ast.statements[0] as any
    expect(stmt.type).toBe("WhileLoop")
    expect(stmt.test.type).toBe("BinaryExpression")
    expect(stmt.body.type).toBe("Block")
  })
})

describe("parser blocks", () => {
  test("empty block", () => {
    const ast = parse("{ }")
    const stmt = ast.statements[0] as any
    expect(stmt.type).toBe("Block")
    expect(stmt.statements.length).toBe(0)
  })

  test("block with multiple statements", () => {
    const ast = parse("{ a: i32 = 1; a := a + 1; 42; }")
    const stmt = ast.statements[0] as any
    expect(stmt.statements.length).toBe(3)
  })
})

describe("parser complex nested structures", () => {
  test("nested blocks with conditionals", () => {
    const ast = parse("{ if (x > 0) { if (y > 0) { 1; } } }")
    const stmt = ast.statements[0] as any
    expect(stmt.type).toBe("Conditional")
    expect(stmt.trueBranch.statements[0].type).toBe("Conditional")
  })

  test("expression with nested function calls", () => {
    const ast = parse("{ foo(bar(1, 2), 3); }")
    const stmt = ast.statements[0] as any
    expect(stmt.expression.args.length).toBe(2)
    expect(stmt.expression.args[0].type).toBe("CallExpression")
  })
})
