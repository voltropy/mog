import { describe, test, expect } from "bun:test"
import { QBECodeGen, generateQBEIR, generateModuleQBEIR } from "./qbe_codegen.js"
import { IntegerType, FloatType, StringType, ArrayType, StructType, VoidType, BoolType, MapType, PointerType, TensorType } from "./types.js"
import { tokenize } from "./lexer.js"
import { parseTokens } from "./parser.js"

describe("QBE Codegen - Core Infrastructure", () => {
  test("QBECodeGen can be instantiated", () => {
    const gen = new QBECodeGen()
    expect(gen).toBeDefined()
  })

  test("toQBEType maps types correctly", () => {
    const gen = new QBECodeGen()
    expect(gen.toQBEType(new IntegerType("i64"))).toBe("l")
    expect(gen.toQBEType(new IntegerType("i32"))).toBe("l")
    expect(gen.toQBEType(new FloatType("f64"))).toBe("d")
    expect(gen.toQBEType(new FloatType("f32"))).toBe("s")
    expect(gen.toQBEType(new StringType())).toBe("l")
    expect(gen.toQBEType(new ArrayType(new IntegerType("i64"), []))).toBe("l")
    expect(gen.toQBEType(new VoidType())).toBe("void")
    expect(gen.toQBEType(new BoolType())).toBe("l")
    expect(gen.toQBEType(new MapType(new StringType(), new IntegerType("i64")))).toBe("l")
    expect(gen.toQBEType(new PointerType(null))).toBe("l")
    expect(gen.toQBEType(null)).toBe("l")
    expect(gen.toQBEType(undefined)).toBe("l")
  })

  test("generateQBEIR produces valid QBE IL header", () => {
    const ast = { type: "Program", statements: [], scopeId: "0" }
    const ir = generateQBEIR(ast)
    expect(ir).toContain("# Mog QBE IL")
    expect(ir).toContain("# Generated by Mog compiler")
  })

  test("generateQBEIR generates main entry for empty program with no main", () => {
    const ast = { type: "Program", statements: [], scopeId: "0" }
    const ir = generateQBEIR(ast)
    // No main function, no top-level statements -> no main entry
    expect(ir).not.toContain("$main")
  })

  test("string constants are deduplicated", () => {
    const gen = new QBECodeGen()
    // Access through the generate method with a simple AST containing duplicate strings
    const ast = {
      type: "Program",
      scopeId: "0",
      statements: [
        { type: "ExpressionStatement", expression: { type: "StringLiteral", value: "hello" } },
        { type: "ExpressionStatement", expression: { type: "StringLiteral", value: "hello" } },
        { type: "ExpressionStatement", expression: { type: "StringLiteral", value: "world" } },
      ]
    }
    const ir = generateQBEIR(ast)
    // Should only have one "hello" data definition
    const helloCount = (ir.match(/b "hello"/g) || []).length
    expect(helloCount).toBe(1)
    // Should have both "hello" and "world"
    expect(ir).toContain('b "hello"')
    expect(ir).toContain('b "world"')
  })

  test("string escaping handles special characters", () => {
    const gen = new QBECodeGen() as any
    const result = gen.escapeStringForQBE("hello\nworld")
    expect(result.escaped).toContain("\\n")
    expect(result.byteLength).toBe(11) // hello + \n + world

    const result2 = gen.escapeStringForQBE('say "hi"')
    expect(result2.escaped).toContain('\\"')
    expect(result2.byteLength).toBe(8)

    const result3 = gen.escapeStringForQBE("tab\there")
    expect(result3.escaped).toContain("\\t")
    expect(result3.byteLength).toBe(8)
  })

  test("string escaping handles UTF-8 multi-byte chars", () => {
    const gen = new QBECodeGen() as any
    const result = gen.escapeStringForQBE("café")
    expect(result.byteLength).toBe(5) // c-a-f-é(2 bytes)
  })

  test("float detection works", () => {
    const gen = new QBECodeGen() as any
    expect(gen.isFloatOperand({ type: "NumberLiteral", value: 3.14, kind: "f64" })).toBe(true)
    expect(gen.isFloatOperand({ type: "NumberLiteral", value: 42 })).toBe(false)
    expect(gen.isFloatOperand({ type: "NumberLiteral", value: 3.14 })).toBe(true)
    expect(gen.isFloatOperand(null)).toBe(false)
  })
})

describe("QBE Codegen - Binary Expressions", () => {
  function makeIntBinExpr(op: string) {
    return {
      type: "BinaryExpression",
      operator: op,
      left: { type: "NumberLiteral", value: 10 },
      right: { type: "NumberLiteral", value: 3 },
    }
  }

  function makeFloatBinExpr(op: string) {
    return {
      type: "BinaryExpression",
      operator: op,
      left: { type: "NumberLiteral", value: 3.14, kind: "f64" },
      right: { type: "NumberLiteral", value: 2.0, kind: "f64" },
    }
  }

  test("integer addition emits add", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const result = gen.generateExpression(ir, makeIntBinExpr("+"))
    expect(result).toMatch(/%v\.\d+/)
    expect(ir.some(line => line.includes("=l add"))).toBe(true)
  })

  test("integer subtraction emits sub", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("-"))
    expect(ir.some(line => line.includes("=l sub"))).toBe(true)
  })

  test("integer multiplication emits mul", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("*"))
    expect(ir.some(line => line.includes("=l mul"))).toBe(true)
  })

  test("integer division emits sdiv", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("/"))
    expect(ir.some(line => line.includes("=l sdiv"))).toBe(true)
  })

  test("integer modulo emits srem", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("%"))
    expect(ir.some(line => line.includes("=l srem"))).toBe(true)
  })

  test("integer equality emits ceql and extsw", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("=="))
    expect(ir.some(line => line.includes("=w ceql"))).toBe(true)
    expect(ir.some(line => line.includes("=l extsw"))).toBe(true)
  })

  test("integer not-equal emits cnel and extsw", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("!="))
    expect(ir.some(line => line.includes("=w cnel"))).toBe(true)
    expect(ir.some(line => line.includes("=l extsw"))).toBe(true)
  })

  test("integer less-than emits csltl", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("<"))
    expect(ir.some(line => line.includes("=w csltl"))).toBe(true)
  })

  test("integer greater-than emits csgtl", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr(">"))
    expect(ir.some(line => line.includes("=w csgtl"))).toBe(true)
  })

  test("integer less-or-equal emits cslel", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("<="))
    expect(ir.some(line => line.includes("=w cslel"))).toBe(true)
  })

  test("integer greater-or-equal emits csgel", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr(">="))
    expect(ir.some(line => line.includes("=w csgel"))).toBe(true)
  })

  test("float addition emits d add", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeFloatBinExpr("+"))
    expect(ir.some(line => line.includes("=d add"))).toBe(true)
  })

  test("float subtraction emits d sub", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeFloatBinExpr("-"))
    expect(ir.some(line => line.includes("=d sub"))).toBe(true)
  })

  test("float multiplication emits d mul", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeFloatBinExpr("*"))
    expect(ir.some(line => line.includes("=d mul"))).toBe(true)
  })

  test("float division emits d div", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeFloatBinExpr("/"))
    expect(ir.some(line => line.includes("=d div"))).toBe(true)
  })

  test("float comparison emits ceqd and extsw", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeFloatBinExpr("=="))
    expect(ir.some(line => line.includes("=w ceqd"))).toBe(true)
    expect(ir.some(line => line.includes("=l extsw"))).toBe(true)
  })

  test("float less-than emits cltd", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeFloatBinExpr("<"))
    expect(ir.some(line => line.includes("=w cltd"))).toBe(true)
  })

  test("float greater-than emits cgtd", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeFloatBinExpr(">"))
    expect(ir.some(line => line.includes("=w cgtd"))).toBe(true)
  })

  test("logical AND emits cnel and and", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("&&"))
    // Should convert operands to w booleans first
    const cnelLines = ir.filter(line => line.includes("cnel"))
    expect(cnelLines.length).toBe(2) // both operands
    expect(ir.some(line => line.includes("=w and"))).toBe(true)
    expect(ir.some(line => line.includes("=l extsw"))).toBe(true)
  })

  test("logical OR emits cnel and or", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("||"))
    const cnelLines = ir.filter(line => line.includes("cnel"))
    expect(cnelLines.length).toBe(2)
    expect(ir.some(line => line.includes("=w or"))).toBe(true)
    expect(ir.some(line => line.includes("=l extsw"))).toBe(true)
  })

  test("bitwise AND emits l and", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("&"))
    expect(ir.some(line => line.includes("=l and"))).toBe(true)
  })

  test("bitwise OR emits l or", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("|"))
    expect(ir.some(line => line.includes("=l or"))).toBe(true)
  })

  test("bitwise XOR emits l xor", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("^"))
    expect(ir.some(line => line.includes("=l xor"))).toBe(true)
  })

  test("left shift emits shl", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr("<<"))
    expect(ir.some(line => line.includes("=l shl"))).toBe(true)
  })

  test("right shift emits sar", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    gen.generateExpression(ir, makeIntBinExpr(">>"))
    expect(ir.some(line => line.includes("=l sar"))).toBe(true)
  })

  test("string equality uses string_eq", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "BinaryExpression",
      operator: "==",
      left: { type: "StringLiteral", value: "hello" },
      right: { type: "StringLiteral", value: "world" },
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $string_eq"))).toBe(true)
  })

  test("string inequality uses string_eq and xor", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "BinaryExpression",
      operator: "!=",
      left: { type: "StringLiteral", value: "hello" },
      right: { type: "StringLiteral", value: "world" },
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $string_eq"))).toBe(true)
    expect(ir.some(line => line.includes("xor") && line.includes("1"))).toBe(true)
  })

  test("mixed float/int binary converts int operand", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "BinaryExpression",
      operator: "+",
      left: { type: "NumberLiteral", value: 3.14, kind: "f64" },
      right: { type: "NumberLiteral", value: 5 },
    }
    gen.generateExpression(ir, expr)
    // Should convert the integer operand to double
    expect(ir.some(line => line.includes("swtof"))).toBe(true)
    expect(ir.some(line => line.includes("=d add"))).toBe(true)
  })
})

describe("QBE Codegen - Unary Expressions", () => {
  test("integer negation emits sub 0", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "UnaryExpression",
      operator: "-",
      argument: { type: "NumberLiteral", value: 42 },
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("=l sub 0,"))).toBe(true)
  })

  test("float negation emits neg", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "UnaryExpression",
      operator: "-",
      argument: { type: "NumberLiteral", value: 3.14, kind: "f64" },
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("=d neg"))).toBe(true)
  })

  test("logical not emits xor with 1", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "UnaryExpression",
      operator: "!",
      argument: { type: "BooleanLiteral", value: true },
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/%v\.\d+/)
    expect(ir.some(line => line.includes("=l xor") && line.includes(", 1"))).toBe(true)
  })

  test("bitwise not emits xor with -1", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "UnaryExpression",
      operator: "~",
      argument: { type: "NumberLiteral", value: 0xFF },
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("=l xor") && line.includes(", -1"))).toBe(true)
  })

  test("unary with operand field works too", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "UnaryExpression",
      operator: "-",
      operand: { type: "NumberLiteral", value: 7 },
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("=l sub 0,"))).toBe(true)
  })
})

// ============================================================
// Call Expression Generation Tests
// ============================================================
describe("QBE Codegen - Call Expressions", () => {
  // --- Print calls ---
  test("print with integer arg emits print_i64 call", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "print" },
      args: [{ type: "NumberLiteral", value: 42 }],
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $print_i64(l "))).toBe(true)
  })

  test("println with string arg emits println_string call", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "println" },
      args: [{ type: "StringLiteral", value: "hello" }],
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $println_string(l "))).toBe(true)
  })

  test("print_f64 emits call with d type arg", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "print_f64" },
      args: [{ type: "NumberLiteral", value: 3.14, kind: "f64" }],
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $print_f64(d "))).toBe(true)
  })

  // --- Math builtins (single-arg) ---
  test("sqrt emits d-typed call to $sqrt", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "sqrt" },
      args: [{ type: "NumberLiteral", value: 2.0, kind: "f64" }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=d call $sqrt(d "))).toBe(true)
  })

  test("abs maps to fabs in QBE", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "abs" },
      args: [{ type: "NumberLiteral", value: -1.5, kind: "f64" }],
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $fabs(d "))).toBe(true)
    // Should NOT contain $abs
    expect(ir.some(line => line.includes("call $abs("))).toBe(false)
  })

  test("sin, cos, floor all emit correct single-arg math calls", () => {
    for (const func of ["sin", "cos", "floor"]) {
      const gen = new QBECodeGen()
      const ir: string[] = []
      const expr = {
        type: "CallExpression",
        callee: { type: "Identifier", name: func },
        args: [{ type: "NumberLiteral", value: 1.0, kind: "f64" }],
      }
      const result = gen.generateExpression(ir, expr)
      expect(result).toMatch(/^%v\.\d+$/)
      expect(ir.some(line => line.includes(`=d call $${func}(d `))).toBe(true)
    }
  })

  // --- Math builtins (two-arg) ---
  test("pow emits two-arg d call", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "pow" },
      args: [
        { type: "NumberLiteral", value: 2.0, kind: "f64" },
        { type: "NumberLiteral", value: 3.0, kind: "f64" },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=d call $pow(d ") && line.includes(", d "))).toBe(true)
  })

  test("min maps to fmin", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "min" },
      args: [
        { type: "NumberLiteral", value: 1.0, kind: "f64" },
        { type: "NumberLiteral", value: 2.0, kind: "f64" },
      ],
    }
    gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $fmin(d "))).toBe(true)
  })

  // --- Conversion functions ---
  test("str() emits i64_to_string call", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "str" },
      args: [{ type: "NumberLiteral", value: 42 }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $i64_to_string(l "))).toBe(true)
  })

  test("f64_to_string emits d-typed arg call", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "f64_to_string" },
      args: [{ type: "NumberLiteral", value: 3.14, kind: "f64" }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $f64_to_string(d "))).toBe(true)
  })

  test("float_from_string returns d type", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "float_from_string" },
      args: [{ type: "StringLiteral", value: "3.14" }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=d call $float_from_string(l "))).toBe(true)
  })

  // --- Input functions ---
  test("input_i64 emits no-arg call returning l", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "input_i64" },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $input_i64()"))).toBe(true)
  })

  test("input_f64 returns d type", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "input_f64" },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("=d call $input_f64()"))).toBe(true)
  })

  test("input_string returns l type", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "input_string" },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("=l call $input_string()"))).toBe(true)
  })

  // --- tensor_print ---
  test("tensor_print emits void call", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "tensor_print" },
      args: [{ type: "Identifier", name: "t" }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("0")
    expect(ir.some(line => line.includes("call $tensor_print(l "))).toBe(true)
  })

  // --- Tensor member expression method calls ---
  test("tensor .sum() emits =d call $tensor_sum", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("t", new TensorType(new FloatType("f64")))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "t" },
        property: "sum",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=d call $tensor_sum(l "))).toBe(true)
  })

  test("tensor .mean() emits =d call $tensor_mean", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("t", new TensorType(new FloatType("f64")))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "t" },
        property: "mean",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=d call $tensor_mean(l "))).toBe(true)
  })

  test("tensor .matmul(other) emits =l call $tensor_matmul with two args", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("a", new TensorType(new FloatType("f64")))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "a" },
        property: "matmul",
      },
      args: [{ type: "Identifier", name: "b" }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $tensor_matmul(l ") && line.includes(", l "))).toBe(true)
  })

  test("tensor .reshape(shape) emits =l call $tensor_reshape with two args", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("t", new TensorType(new FloatType("f64")))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "t" },
        property: "reshape",
      },
      args: [{ type: "Identifier", name: "new_shape" }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $tensor_reshape(l ") && line.includes(", l "))).toBe(true)
  })

  test("tensor .print() emits void call $tensor_print", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("t", new TensorType(new FloatType("f64")))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "t" },
        property: "print",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("0")
    expect(ir.some(line => line.includes("call $tensor_print(l "))).toBe(true)
  })

  test("tensor .shape() emits =l call $tensor_shape", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("t", new TensorType(new FloatType("f64")))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "t" },
        property: "shape",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $tensor_shape(l "))).toBe(true)
  })

  test("tensor .ndim() emits =l call $tensor_ndim", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("t", new TensorType(new FloatType("f64")))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "t" },
        property: "ndim",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $tensor_ndim(l "))).toBe(true)
  })

  test("tensor .size() emits =l call $tensor_size", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("t", new TensorType(new FloatType("f64")))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "t" },
        property: "size",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $tensor_size(l "))).toBe(true)
  })

  // --- GC functions ---
  test("gc_collect emits void no-arg call", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "gc_collect" },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("0")
    expect(ir.some(line => line.includes("call $gc_collect()"))).toBe(true)
  })

  // --- General function calls ---
  test("general function call with void return emits no register assignment", () => {
    const gen = new QBECodeGen() as any
    gen.functionTypes.set("my_void_func", new VoidType())
    gen.functionParamInfo.set("my_void_func", [
      { name: "x", paramType: new IntegerType("i64") },
    ])
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "my_void_func" },
      args: [{ type: "NumberLiteral", value: 10 }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("0")
    expect(ir.some(line => line.match(/^\s*call \$my_void_func\(l /))).toBe(true)
    // Should NOT have a register assignment
    expect(ir.some(line => line.includes("=l call $my_void_func"))).toBe(false)
  })

  test("general function call with int return emits l register assignment", () => {
    const gen = new QBECodeGen() as any
    gen.functionTypes.set("add_nums", new IntegerType("i64"))
    gen.functionParamInfo.set("add_nums", [
      { name: "a", paramType: new IntegerType("i64") },
      { name: "b", paramType: new IntegerType("i64") },
    ])
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "add_nums" },
      args: [
        { type: "NumberLiteral", value: 1 },
        { type: "NumberLiteral", value: 2 },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $add_nums(l "))).toBe(true)
  })

  test("general function call with float return emits d register assignment", () => {
    const gen = new QBECodeGen() as any
    gen.functionTypes.set("compute", new FloatType("f64"))
    gen.functionParamInfo.set("compute", [
      { name: "x", paramType: new FloatType("f64") },
    ])
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "compute" },
      args: [{ type: "NumberLiteral", value: 1.5, kind: "f64" }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=d call $compute(d "))).toBe(true)
  })

  // --- Member expression calls: package-qualified ---
  test("package-qualified call emits pkg__method", () => {
    const gen = new QBECodeGen() as any
    gen.importedPackages.set("math", "math")
    gen.functionTypes.set("math__factorial", new IntegerType("i64"))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "math" },
        property: "factorial",
      },
      args: [{ type: "NumberLiteral", value: 5 }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("call $math__factorial(l "))).toBe(true)
  })

  // --- Member expression calls: string methods ---
  test("string .upper() calls $string_upper", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("s", new StringType())
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "s" },
        property: "upper",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("call $string_upper(l "))).toBe(true)
  })

  test("string .contains(sub) passes object and arg", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("s", new StringType())
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "s" },
        property: "contains",
      },
      args: [{ type: "StringLiteral", value: "foo" }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("call $string_contains(l ") && line.includes(", l "))).toBe(true)
  })

  test("string .replace(old, new) passes object and two args", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("s", new StringType())
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "s" },
        property: "replace",
      },
      args: [
        { type: "StringLiteral", value: "old" },
        { type: "StringLiteral", value: "new" },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("call $string_replace(l "))).toBe(true)
  })

  // --- Member expression calls: array methods ---
  test("array .push(v) emits void call", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("arr", new ArrayType(new IntegerType("i64"), []))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "arr" },
        property: "push",
      },
      args: [{ type: "NumberLiteral", value: 99 }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("0")
    expect(ir.some(line => line.includes("call $array_push(l "))).toBe(true)
  })

  test("array .len() returns l value", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("arr", new ArrayType(new IntegerType("i64"), []))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "arr" },
        property: "len",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $array_len(l "))).toBe(true)
  })

  test("array .pop() returns l value", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("arr", new ArrayType(new IntegerType("i64"), []))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "arr" },
        property: "pop",
      },
      args: [],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $array_pop(l "))).toBe(true)
  })

  // --- Indirect / closure calls ---
  test("indirect call loads fn_ptr and env_ptr from closure struct", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("callback", new IntegerType("i64")) // opaque ptr
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "callback" },
      args: [{ type: "NumberLiteral", value: 10 }],
    }
    // callback is not a print/math/input/gc function, and not in functionTypes,
    // so it falls through to the general case, which calls $callback(l 10)
    // For a true indirect call, the callee should not be an Identifier
    // Let's test with a non-Identifier callee instead:
    const indirectExpr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "closures" },
        property: "0",
      },
      args: [{ type: "NumberLiteral", value: 5 }],
    }
    // The indirect call path is reached when callee is not Identifier and not MemberExpression
    // with recognized patterns. Let's test the actual closure path with an IndexExpression callee:
    const closureExpr = {
      type: "CallExpression",
      callee: {
        type: "IndexExpression",
        object: { type: "Identifier", name: "fns" },
        index: { type: "NumberLiteral", value: 0 },
      },
      args: [{ type: "NumberLiteral", value: 7 }],
    }
    const ir2: string[] = []
    gen.generateExpression(ir2, closureExpr)
    // Should load fn_ptr (loadl), env offset (+8), env_ptr (loadl), then call
    expect(ir2.some(line => line.includes("=l loadl"))).toBe(true)
    expect(ir2.some(line => line.includes("=l add") && line.includes(", 8"))).toBe(true)
    // The call should use a register (not $name)
    expect(ir2.some(line => line.match(/call %v\.\d+\(/))).toBe(true)
  })

  // --- Unknown function falls through to general call ---
  test("unknown function without type info still emits call with l return", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: { type: "Identifier", name: "unknown_func" },
      args: [{ type: "NumberLiteral", value: 1 }],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("=l call $unknown_func(l "))).toBe(true)
  })
})

describe("QBE Codegen - Template Literals", () => {
  test("template literal with only a string part returns string constant", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "TemplateLiteral",
      parts: ["hello"],
    }
    const result = gen.generateTemplateLiteral(ir, expr)
    expect(result).toMatch(/^\$str\.\d+$/)
    expect(ir.length).toBe(0) // no instructions needed, just a constant
  })

  test("template literal with string and int expression concatenates", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "TemplateLiteral",
      parts: [
        "count: ",
        { type: "NumberLiteral", value: 42 },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $i64_to_string"))).toBe(true)
    expect(ir.some(line => line.includes("call $string_concat"))).toBe(true)
  })

  test("template literal with float expression calls f64_to_string", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "TemplateLiteral",
      parts: [
        "pi: ",
        { type: "NumberLiteral", value: 3.14, kind: "f64" },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $f64_to_string"))).toBe(true)
    expect(ir.some(line => line.includes("call $string_concat"))).toBe(true)
  })

  test("template literal with string-typed identifier skips conversion", () => {
    const gen = new QBECodeGen() as any
    gen.variableTypes.set("name", new StringType())
    const ir: string[] = []
    const expr = {
      type: "TemplateLiteral",
      parts: [
        "hello ",
        { type: "Identifier", name: "name" },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    // Should NOT convert string to string — no i64_to_string or f64_to_string
    expect(ir.some(line => line.includes("call $i64_to_string"))).toBe(false)
    expect(ir.some(line => line.includes("call $f64_to_string"))).toBe(false)
    // Should still concatenate the parts
    expect(ir.some(line => line.includes("call $string_concat"))).toBe(true)
  })

  test("template literal with multiple interpolations chains concats", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "TemplateLiteral",
      parts: [
        "a",
        { type: "NumberLiteral", value: 1 },
        "b",
        { type: "NumberLiteral", value: 2 },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    const concatCount = ir.filter(line => line.includes("call $string_concat")).length
    expect(concatCount).toBe(3) // a+1, (a+1)+b, ((a+1)+b)+2
  })

  test("empty template literal returns empty string constant", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "TemplateLiteral",
      parts: [],
    }
    const result = gen.generateTemplateLiteral(ir, expr)
    expect(result).toMatch(/^\$str\.\d+$/)
  })

  test("template literal with StringLiteral node works", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "TemplateLiteral",
      parts: [
        { type: "StringLiteral", value: "hello " },
        { type: "NumberLiteral", value: 99 },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(ir.some(line => line.includes("call $i64_to_string"))).toBe(true)
    expect(ir.some(line => line.includes("call $string_concat"))).toBe(true)
  })

  // Helper to parse Mog source into AST
  function parse(source: string) {
    const tokens = tokenize(source).filter(t => t.type !== "WHITESPACE" && t.type !== "COMMENT")
    return parseTokens(tokens)
  }

  test("integration: f-string with println generates concat and conversion", () => {
    const ast = parse(`println(f"hello {42}")`)
    const ir = generateQBEIR(ast)
    expect(ir).toContain("call $i64_to_string")
    expect(ir).toContain("call $string_concat")
  })

  test("integration: f-string with multiple interpolations via println", () => {
    const ast = parse(`println(f"a{1}b{2}c")`)
    const ir = generateQBEIR(ast)
    expect(ir).toContain("call $i64_to_string")
    expect(ir).toContain("call $string_concat")
  })

  test("integration: f-string with only string content via println", () => {
    const ast = parse(`println(f"just a string")`)
    const ir = generateQBEIR(ast)
    // Should have the string data but no conversion calls
    expect(ir).toContain("just a string")
     expect(ir).not.toContain("call $i64_to_string")
  })
})

// ============================================================
// Literal Generation Tests
// ============================================================

describe("QBE Codegen - Number Literals", () => {
  test("integer literal returns value as string", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "NumberLiteral", value: 42 }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("42")
    expect(ir.length).toBe(0) // no IR needed for immediates
  })

  test("zero integer literal returns '0'", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "NumberLiteral", value: 0 }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("0")
  })

  test("negative integer literal returns negative string", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "NumberLiteral", value: -7 }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("-7")
  })

  test("f64 literal returns QBE double format", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "NumberLiteral", value: 3.14, kind: "f64" }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^d_[0-9a-f]{16}$/)
    expect(ir.length).toBe(0)
  })

  test("f32 literal returns QBE single format", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "NumberLiteral", value: 1.5, kind: "f32" }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^s_[0-9a-f]{8}$/)
    expect(ir.length).toBe(0)
  })

  test("decimal without kind is treated as f64", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "NumberLiteral", value: 2.718 }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^d_[0-9a-f]{16}$/)
  })

  test("large integer literal works", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "NumberLiteral", value: 1000000 }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("1000000")
  })
})

describe("QBE Codegen - String Literals", () => {
  test("string literal returns data section label", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "StringLiteral", value: "hello" }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^\$str\.\d+$/)
    expect(ir.length).toBe(0) // no IR instructions needed
  })

  test("duplicate strings return same label", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const r1 = gen.generateExpression(ir, { type: "StringLiteral", value: "hello" })
    const r2 = gen.generateExpression(ir, { type: "StringLiteral", value: "hello" })
    expect(r1).toBe(r2)
  })

  test("different strings return different labels", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const r1 = gen.generateExpression(ir, { type: "StringLiteral", value: "foo" })
    const r2 = gen.generateExpression(ir, { type: "StringLiteral", value: "bar" })
    expect(r1).not.toBe(r2)
  })

  test("empty string literal works", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "StringLiteral", value: "" }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^\$str\.\d+$/)
  })
})

describe("QBE Codegen - Boolean Literals", () => {
  test("true returns '1'", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const result = gen.generateExpression(ir, { type: "BooleanLiteral", value: true })
    expect(result).toBe("1")
  })

  test("false returns '0'", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const result = gen.generateExpression(ir, { type: "BooleanLiteral", value: false })
    expect(result).toBe("0")
  })
})

describe("QBE Codegen - Null/None Literals", () => {
  test("NullLiteral returns '0'", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const result = gen.generateExpression(ir, { type: "NullLiteral" })
    expect(result).toBe("0")
    expect(ir.length).toBe(0)
  })

  test("NoneLiteral returns '0'", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const result = gen.generateExpression(ir, { type: "NoneLiteral" })
    expect(result).toBe("0")
    expect(ir.length).toBe(0)
  })
})

describe("QBE Codegen - Array Literals", () => {
  test("empty array allocates header with zero-length", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "ArrayLiteral", elements: [] }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // Should allocate header (24 bytes) and data (min 8 bytes)
    expect(ir.filter(line => line.includes("call $gc_alloc")).length).toBe(2)
    // Should store len=0
    expect(ir.some(line => line.includes("storel 0,"))).toBe(true)
  })

  test("array with elements allocates and stores each", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "ArrayLiteral",
      elements: [
        { type: "NumberLiteral", value: 10 },
        { type: "NumberLiteral", value: 20 },
        { type: "NumberLiteral", value: 30 },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // Two gc_alloc calls: header + data
    expect(ir.filter(line => line.includes("call $gc_alloc")).length).toBe(2)
    // Should have storel for len, cap, data ptr, plus 3 elements = 6 storel total
    const storeCalls = ir.filter(line => line.includes("storel"))
    expect(storeCalls.length).toBe(6) // len + cap + data_ptr + 3 elements
    // First element stored at base, others at offsets
    expect(ir.some(line => line.includes("storel 10,"))).toBe(true)
    expect(ir.some(line => line.includes("storel 20,"))).toBe(true)
    expect(ir.some(line => line.includes("storel 30,"))).toBe(true)
  })

  test("array data allocation is count * 8", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "ArrayLiteral",
      elements: [
        { type: "NumberLiteral", value: 1 },
        { type: "NumberLiteral", value: 2 },
      ],
    }
    gen.generateExpression(ir, expr)
    // Data alloc should be 2*8=16
    expect(ir.some(line => line.includes("call $gc_alloc(l 16)"))).toBe(true)
    // Header alloc should always be 24
    expect(ir.some(line => line.includes("call $gc_alloc(l 24)"))).toBe(true)
  })
})

describe("QBE Codegen - Map Literals", () => {
  test("empty map calls map_new", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "MapLiteral", entries: [] }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("call $map_new()"))).toBe(true)
    // No map_set calls for empty map
    expect(ir.some(line => line.includes("call $map_set"))).toBe(false)
  })

  test("map with entries calls map_set for each", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "MapLiteral",
      entries: [
        { key: { type: "StringLiteral", value: "a" }, value: { type: "NumberLiteral", value: 1 } },
        { key: { type: "StringLiteral", value: "b" }, value: { type: "NumberLiteral", value: 2 } },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some(line => line.includes("call $map_new()"))).toBe(true)
    const setCalls = ir.filter(line => line.includes("call $map_set"))
    expect(setCalls.length).toBe(2)
  })
})

describe("QBE Codegen - ArrayFill", () => {
  test("array fill allocates header and data, loops to fill", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "ArrayFill",
      value: { type: "NumberLiteral", value: 0 },
      count: { type: "NumberLiteral", value: 5 },
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // Should allocate header and data
    expect(ir.filter(line => line.includes("call $gc_alloc")).length).toBe(2)
    // Should have a loop with jmp/jnz
    expect(ir.some(line => line.includes("jnz"))).toBe(true)
    expect(ir.filter(line => line.startsWith("@L.")).length).toBeGreaterThanOrEqual(3) // head, body, end labels
    // Should store len and cap
    expect(ir.some(line => line.includes("storel 5,"))).toBe(true)
  })
})

// --- Variable Declaration ---

describe("QBE Codegen - Variable Declaration", () => {
  test("VariableDeclaration with initializer allocates and stores", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "VariableDeclaration",
      name: "x",
      initializer: { type: "NumberLiteral", value: 42 },
    }
    gen.generateStatement(ir, stmt)
    // Should have an alloc in entryAllocs
    expect(gen.entryAllocs.some((line: string) => line.includes("alloc8 8"))).toBe(true)
    // Should store the value
    expect(ir.some(line => line.includes("storel 42,"))).toBe(true)
    // Should record the variable
    expect(gen.variables.has("x")).toBe(true)
  })

  test("VariableDeclaration without initializer stores 0", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "VariableDeclaration",
      name: "y",
    }
    gen.generateStatement(ir, stmt)
    expect(gen.entryAllocs.some((line: string) => line.includes("alloc8 8"))).toBe(true)
    expect(ir.some(line => line.includes("storel 0,"))).toBe(true)
    expect(gen.variables.has("y")).toBe(true)
  })

  test("VariableDeclaration tracks type annotation", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "VariableDeclaration",
      name: "z",
      typeAnnotation: new FloatType("f64"),
      initializer: { type: "NumberLiteral", value: 3.14, kind: "f64" },
    }
    gen.generateStatement(ir, stmt)
    expect(gen.variableTypes.get("z")).toBeInstanceOf(FloatType)
    // Float variables use stored instead of storel
    expect(ir.some(line => line.includes("stored"))).toBe(true)
  })
})

// --- Assignment Expression ---

describe("QBE Codegen - Assignment Expression", () => {
  test("declaration assignment (:=) allocates and stores", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "AssignmentExpression",
      name: "x",
      operator: ":=",
      value: { type: "NumberLiteral", value: 99 },
      isDeclaration: true,
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toBe("99")
    expect(gen.entryAllocs.some((line: string) => line.includes("alloc8 8"))).toBe(true)
    expect(ir.some(line => line.includes("storel 99,"))).toBe(true)
    expect(gen.variables.has("x")).toBe(true)
  })

  test("simple reassignment stores to existing variable", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    // First declare
    gen.generateStatement(ir, {
      type: "VariableDeclaration",
      name: "x",
      initializer: { type: "NumberLiteral", value: 1 },
    })
    // Then reassign
    const ir2: string[] = []
    const result = gen.generateExpression(ir2, {
      type: "AssignmentExpression",
      name: "x",
      operator: "=",
      value: { type: "NumberLiteral", value: 42 },
    })
    expect(result).toBe("42")
    expect(ir2.some(line => line.includes("storel 42,"))).toBe(true)
  })

  test("compound += loads, adds, and stores back", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    // Declare x = 10
    gen.generateStatement(ir, {
      type: "VariableDeclaration",
      name: "x",
      initializer: { type: "NumberLiteral", value: 10 },
    })
    const ir2: string[] = []
    const result = gen.generateExpression(ir2, {
      type: "AssignmentExpression",
      name: "x",
      operator: "+=",
      value: { type: "NumberLiteral", value: 5 },
    })
    // Should load current value
    expect(ir2.some(line => line.includes("loadl"))).toBe(true)
    // Should have add
    expect(ir2.some(line => line.includes("add"))).toBe(true)
    // Should store back
    expect(ir2.some(line => line.includes("storel"))).toBe(true)
    expect(result).toMatch(/^%v\.\d+$/)
  })
})

// ============================================================
// Module Support Tests
// ============================================================
describe("QBE Codegen - Module Support", () => {
  function parse(source: string) {
    const tokens = tokenize(source).filter(t => t.type !== "WHITESPACE" && t.type !== "COMMENT")
    return parseTokens(tokens)
  }

  test("generateModuleQBEIR mangles function names with package prefix", () => {
    const ir = generateModuleQBEIR(
      parse("pub fn add(a: int, b: int) -> int { return a + b; }"),
      "math"
    )
    expect(ir).toContain("function")
    expect(ir).toContain("$math__add")
    // Should NOT contain un-mangled $add
    expect(ir).not.toMatch(/\$add[^_]/)
  })

  test("pub functions get export keyword in QBE output", () => {
    const ir = generateModuleQBEIR(
      parse("pub fn add(a: int, b: int) -> int { return a + b; }"),
      "math"
    )
    expect(ir).toContain("export")
    expect(ir).toContain("export function")
    expect(ir).toContain("$math__add")
  })

  test("non-pub functions do NOT get export keyword", () => {
    const ir = generateModuleQBEIR(
      parse("fn helper(x: int) -> int { return x; }"),
      "math"
    )
    expect(ir).toContain("$math__helper")
    // The function line should not have export
    const lines = ir.split("\n")
    const funcLine = lines.find(l => l.includes("$math__helper"))
    expect(funcLine).toBeDefined()
    expect(funcLine!).not.toContain("export")
  })

  test("multiple functions all get mangled with package prefix", () => {
    const ir = generateModuleQBEIR(
      parse(`
        pub fn add(a: int, b: int) -> int { return a + b; }
        fn sub(a: int, b: int) -> int { return a - b; }
        pub fn mul(a: int, b: int) -> int { return a * b; }
      `),
      "math"
    )
    expect(ir).toContain("$math__add")
    expect(ir).toContain("$math__sub")
    expect(ir).toContain("$math__mul")
  })

  test("cross-package call emits mangled name via importedPackages", () => {
    const gen = new QBECodeGen() as any
    gen.importedPackages.set("math", "math")
    gen.functionTypes.set("math__add", new IntegerType("i64"))
    const ir: string[] = []
    const expr = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "math" },
        property: "add",
      },
      args: [
        { type: "NumberLiteral", value: 1 },
        { type: "NumberLiteral", value: 2 },
      ],
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some((line: string) => line.includes("call $math__add("))).toBe(true)
  })

  test("import declarations populate importedPackages for qualified access", () => {
    // Parse source that has an import and a call to the imported package
    const ast = parse('import "math"')
    // Use single-package form — the import should get picked up
    const gen = new QBECodeGen()
    gen.packagePrefix = "app__"
    for (const stmt of (ast.statements || [])) {
      if (stmt.type === "ImportDeclaration" && (stmt as any).paths) {
        for (const path of (stmt as any).paths) {
          gen.importedPackages.set(path, path)
        }
      }
    }
    expect(gen.importedPackages.has("math")).toBe(true)
    expect(gen.importedPackages.get("math")).toBe("math")
  })

  test("multi-package form still works (backward compatibility)", () => {
    const mainAST = parse("fn main() { }")
    const mathAST = parse("pub fn add(a: int, b: int) -> int { return a + b; }")
    const packages = new Map<string, any>()
    packages.set("main", mainAST)
    packages.set("math", mathAST)
    const ir = generateModuleQBEIR(packages)
    expect(ir).toContain("$math__add")
  })
})

describe("QBE Codegen - Compound Assignment (continued)", () => {
  test("compound *= loads, multiplies, and stores back", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.generateStatement(ir, {
      type: "VariableDeclaration",
      name: "n",
      initializer: { type: "NumberLiteral", value: 5 },
    })
    const ir2: string[] = []
    gen.generateExpression(ir2, {
      type: "AssignmentExpression",
      name: "n",
      operator: "*=",
      value: { type: "NumberLiteral", value: 4 },
    })
    expect(ir2.some(line => line.includes("mul"))).toBe(true)
    expect(ir2.some(line => line.includes("storel"))).toBe(true)
  })

  test("index assignment computes element pointer and stores", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    // Declare arr variable first
    gen.generateStatement(ir, {
      type: "VariableDeclaration",
      name: "arr",
      typeAnnotation: new ArrayType(new IntegerType("i64")),
      initializer: { type: "NumberLiteral", value: 0 }, // placeholder
    })
    const ir2: string[] = []
    const result = gen.generateExpression(ir2, {
      type: "AssignmentExpression",
      target: {
        type: "IndexExpression",
        object: { type: "Identifier", name: "arr" },
        index: { type: "NumberLiteral", value: 2 },
      },
      operator: "=",
      value: { type: "NumberLiteral", value: 99 },
    })
    expect(result).toBe("99")
    // Should compute data pointer (offset 16 from header)
    expect(ir2.some(line => line.includes("add") && line.includes("16"))).toBe(true)
    // Should compute element offset (index * 8)
    expect(ir2.some(line => line.includes("mul") && line.includes("8"))).toBe(true)
    // Should store the value
    expect(ir2.some(line => line.includes("storel 99,"))).toBe(true)
  })

  test("map index assignment calls $map_set", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.generateStatement(ir, {
      type: "VariableDeclaration",
      name: "m",
      typeAnnotation: new MapType(new StringType(), new IntegerType("i64")),
      initializer: { type: "NumberLiteral", value: 0 },
    })
    const ir2: string[] = []
    gen.generateExpression(ir2, {
      type: "AssignmentExpression",
      target: {
        type: "IndexExpression",
        object: { type: "Identifier", name: "m" },
        index: { type: "StringLiteral", value: "key" },
      },
      operator: "=",
      value: { type: "NumberLiteral", value: 42 },
    })
    expect(ir2.some(line => line.includes("call $map_set"))).toBe(true)
  })

  test("member assignment stores at field offset", () => {
    const gen = new QBECodeGen() as any
    // Register a struct definition
    gen.structDefs.set("Point", [
      { name: "x", fieldType: new IntegerType("i64") },
      { name: "y", fieldType: new IntegerType("i64") },
    ])
    const ir: string[] = []
    // Declare a Point variable
    gen.generateStatement(ir, {
      type: "VariableDeclaration",
      name: "p",
      typeAnnotation: new StructType("Point"),
      initializer: { type: "NumberLiteral", value: 0 },
    })
    const ir2: string[] = []
    gen.generateExpression(ir2, {
      type: "AssignmentExpression",
      target: {
        type: "MemberExpression",
        object: { type: "Identifier", name: "p" },
        property: "y",
      },
      operator: "=",
      value: { type: "NumberLiteral", value: 10 },
    })
    // Field y is at index 1, so offset = 8
    expect(ir2.some(line => line.includes("add") && line.includes("8"))).toBe(true)
    expect(ir2.some(line => line.includes("storel 10,"))).toBe(true)
  })
})

// --- Identifier ---

describe("QBE Codegen - Identifier", () => {
  test("identifier loads from variable slot", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    // Declare a variable first
    gen.generateStatement(ir, {
      type: "VariableDeclaration",
      name: "x",
      initializer: { type: "NumberLiteral", value: 42 },
    })
    const ir2: string[] = []
    const result = gen.generateExpression(ir2, { type: "Identifier", name: "x" })
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir2.some(line => line.includes("loadl"))).toBe(true)
  })

  test("identifier returns function reference for known functions", () => {
    const gen = new QBECodeGen() as any
    gen.functionTypes.set("my_func", new VoidType())
    const ir: string[] = []
    const result = gen.generateExpression(ir, { type: "Identifier", name: "my_func" })
    expect(result).toBe("$my_func")
    // No load needed for function references
    expect(ir.length).toBe(0)
  })

  test("identifier returns 0 for unknown names", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const result = gen.generateExpression(ir, { type: "Identifier", name: "unknown" })
    expect(result).toBe("0")
  })

  test("float identifier uses loadd", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.generateStatement(ir, {
      type: "VariableDeclaration",
      name: "f",
      typeAnnotation: new FloatType("f64"),
      initializer: { type: "NumberLiteral", value: 1.5, kind: "f64" },
    })
    const ir2: string[] = []
    const result = gen.generateExpression(ir2, { type: "Identifier", name: "f" })
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir2.some(line => line.includes("loadd"))).toBe(true)
  })
})

// --- Integration tests via parse + generateQBEIR ---

describe("QBE Codegen - Variable Integration", () => {
  function parse(source: string) {
    const tokens = tokenize(source).filter(t => t.type !== "WHITESPACE" && t.type !== "COMMENT")
    return parseTokens(tokens)
  }

  test("integration: x := 42 generates alloc and store", () => {
    const ast = parse("x := 42")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("alloc8 8")
    expect(ir).toContain("storel 42,")
  })

  test("integration: variable declaration with type annotation", () => {
    const ast = parse("x: int = 10;")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("alloc8 8")
    expect(ir).toContain("storel 10,")
  })

  test("integration: variable used in expression after declaration", () => {
    const ast = parse("x := 5\nprintln(x)")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("alloc8 8")
    expect(ir).toContain("storel 5,")
    // x should be loaded before being passed to println
    expect(ir).toContain("loadl")
  })
})

// --- Control Flow ---

describe("QBE Codegen - Conditional (if/else)", () => {
  test("generateConditional produces jnz with then/else/endif labels", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "Conditional",
      condition: { type: "BooleanLiteral", value: true },
      trueBranch: { body: [] },
      falseBranch: null,
    }
    gen.generateConditional(ir, stmt)
    expect(ir.some((line: string) => line.includes("jnz"))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@then."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@else."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@endif."))).toBe(true)
  })

  test("generateConditional with else branch", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "Conditional",
      condition: { type: "BooleanLiteral", value: true },
      trueBranch: { body: [] },
      falseBranch: { body: [] },
    }
    gen.generateConditional(ir, stmt)
    const jnzLine = ir.find((line: string) => line.includes("jnz"))
    expect(jnzLine).toBeDefined()
    expect(jnzLine).toContain("@then.")
    expect(jnzLine).toContain("@else.")
    const jmpLines = ir.filter((line: string) => line.includes("jmp") && line.includes("@endif."))
    expect(jmpLines.length).toBeGreaterThanOrEqual(2)
  })

  test("generateConditional with else-if chain", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "Conditional",
      condition: { type: "BooleanLiteral", value: true },
      trueBranch: { body: [] },
      falseBranch: {
        type: "Conditional",
        condition: { type: "BooleanLiteral", value: false },
        trueBranch: { body: [] },
        falseBranch: null,
      },
    }
    gen.generateConditional(ir, stmt)
    const jnzLines = ir.filter((line: string) => line.includes("jnz"))
    expect(jnzLines.length).toBe(2)
  })

  test("condition is converted to w type for jnz", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "Conditional",
      condition: { type: "NumberLiteral", value: 42 },
      trueBranch: { body: [] },
      falseBranch: null,
    }
    gen.generateConditional(ir, stmt)
    expect(ir.some((line: string) => line.includes("=w cnel"))).toBe(true)
  })
})

describe("QBE Codegen - While Loop", () => {
  test("generateWhileLoop produces condition check and loop structure", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "WhileLoop",
      test: { type: "BooleanLiteral", value: true },
      body: { body: [] },
    }
    gen.generateWhileLoop(ir, stmt)
    expect(ir.some((line: string) => line.startsWith("@while.cond."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@while.body."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@while.end."))).toBe(true)
    expect(ir.some((line: string) => line.includes("jnz"))).toBe(true)
    expect(ir.some((line: string) => line.includes("jmp @while.cond."))).toBe(true)
  })

  test("while loop emits interrupt check", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "WhileLoop",
      test: { type: "BooleanLiteral", value: true },
      body: { body: [] },
    }
    gen.generateWhileLoop(ir, stmt)
    expect(ir.some((line: string) => line.includes("$mog_interrupt_flag"))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@while.back."))).toBe(true)
  })

  test("while loop condition converted to w type", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "WhileLoop",
      test: { type: "NumberLiteral", value: 1 },
      body: { body: [] },
    }
    gen.generateWhileLoop(ir, stmt)
    expect(ir.some((line: string) => line.includes("=w cnel"))).toBe(true)
  })
})

describe("QBE Codegen - For Loop", () => {
  test("generateForLoop produces counter init, condition, body, step", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "ForLoop",
      variable: "i",
      start: { type: "NumberLiteral", value: 0 },
      end: { type: "NumberLiteral", value: 10 },
      body: { body: [] },
    }
    gen.generateForLoop(ir, stmt)
    expect(ir.some((line: string) => line.includes("storel 0,"))).toBe(true)
    expect(ir.some((line: string) => line.includes("storel 10,"))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@for.cond."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@for.body."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@for.step."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@for.end."))).toBe(true)
    expect(ir.some((line: string) => line.includes("csltl"))).toBe(true)
    expect(ir.some((line: string) => line.includes("add") && line.includes("1"))).toBe(true)
    expect(ir.some((line: string) => line.includes("$mog_interrupt_flag"))).toBe(true)
  })

  test("generateForLoop with step expression", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "ForLoop",
      variable: "i",
      start: { type: "NumberLiteral", value: 0 },
      end: { type: "NumberLiteral", value: 100 },
      step: { type: "NumberLiteral", value: 2 },
      body: { body: [] },
    }
    gen.generateForLoop(ir, stmt)
    expect(ir.some((line: string) => line.includes("add") && line.includes("2"))).toBe(true)
  })

  test("generateForInRange delegates to generateForLoop", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "ForInRange",
      variable: "i",
      start: { type: "NumberLiteral", value: 0 },
      end: { type: "NumberLiteral", value: 5 },
      body: { body: [] },
    }
    gen.generateForInRange(ir, stmt)
    expect(ir.some((line: string) => line.startsWith("@for.cond."))).toBe(true)
    expect(ir.some((line: string) => line.includes("jnz"))).toBe(true)
  })
})

describe("QBE Codegen - ForEach Loop", () => {
  test("generateForEachLoop loads array length and iterates", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.variables.set("arr", "%arr.slot")
    const stmt = {
      type: "ForEachLoop",
      variable: "item",
      array: { type: "Identifier", name: "arr" },
      body: { body: [] },
    }
    gen.generateForEachLoop(ir, stmt)
    expect(ir.some((line: string) => line.includes("loadl"))).toBe(true)
    expect(ir.some((line: string) => line.includes("add") && line.includes("16"))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@foreach.cond."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@foreach.body."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@foreach.step."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@foreach.end."))).toBe(true)
    expect(ir.some((line: string) => line.includes("mul") && line.includes("8"))).toBe(true)
  })
})

describe("QBE Codegen - ForInIndex Loop", () => {
  test("generateForInIndex exposes both index and value variables", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.variables.set("arr", "%arr.slot")
    const stmt = {
      type: "ForInIndex",
      indexVariable: "idx",
      valueVariable: "val",
      iterable: { type: "Identifier", name: "arr" },
      body: { body: [] },
    }
    gen.generateForInIndex(ir, stmt)
    expect(ir.some((line: string) => line.startsWith("@forindex.cond."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@forindex.body."))).toBe(true)
    expect(gen.variables.has("idx")).toBe(true)
    expect(gen.variables.has("val")).toBe(true)
  })
})

describe("QBE Codegen - ForInMap Loop", () => {
  test("generateForInMap creates iterator and iterates", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.variables.set("m", "%m.slot")
    const stmt = {
      type: "ForInMap",
      indexVariable: "k",
      valueVariable: "v",
      iterable: { type: "Identifier", name: "m" },
      body: { body: [] },
    }
    gen.generateForInMap(ir, stmt)
    expect(ir.some((line: string) => line.includes("call $map_iter_new"))).toBe(true)
    expect(ir.some((line: string) => line.includes("call $map_iter_next"))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@formap.cond."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@formap.body."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@formap.end."))).toBe(true)
  })
})

describe("QBE Codegen - Break and Continue", () => {
  test("generateBreak emits jmp to break label", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.loopStack.push({ breakLabel: "@while.end.0", continueLabel: "@while.cond.0" })
    gen.generateBreak(ir)
    expect(ir).toEqual(["  jmp @while.end.0"])
    expect(gen.blockTerminated).toBe(true)
  })

  test("generateContinue emits jmp to continue label", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.loopStack.push({ breakLabel: "@while.end.0", continueLabel: "@while.cond.0" })
    gen.generateContinue(ir)
    expect(ir).toEqual(["  jmp @while.cond.0"])
    expect(gen.blockTerminated).toBe(true)
  })

  test("break outside loop does nothing", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.generateBreak(ir)
    expect(ir).toEqual([])
  })

  test("continue outside loop does nothing", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.generateContinue(ir)
    expect(ir).toEqual([])
  })

  test("nested loops use correct break/continue labels", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.loopStack.push({ breakLabel: "@outer.end", continueLabel: "@outer.cond" })
    gen.loopStack.push({ breakLabel: "@inner.end", continueLabel: "@inner.cond" })
    gen.generateBreak(ir)
    expect(ir).toEqual(["  jmp @inner.end"])
    ir.length = 0
    gen.blockTerminated = false
    gen.generateContinue(ir)
    expect(ir).toEqual(["  jmp @inner.cond"])
  })
})

describe("QBE Codegen - Return Statement", () => {
  test("generateReturn with value emits ret", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "Return",
      value: { type: "NumberLiteral", value: 42 },
    }
    gen.generateReturn(ir, stmt)
    expect(ir.some((line: string) => line.includes("ret 42"))).toBe(true)
    expect(gen.blockTerminated).toBe(true)
  })

  test("generateReturn without value emits bare ret", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "Return",
      value: null,
    }
    gen.generateReturn(ir, stmt)
    expect(ir).toEqual(["  ret"])
    expect(gen.blockTerminated).toBe(true)
  })
})

describe("QBE Codegen - If Expression", () => {
  test("generateIfExpression produces conditional value", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "IfExpression",
      condition: { type: "BooleanLiteral", value: true },
      consequent: { type: "NumberLiteral", value: 1 },
      alternate: { type: "NumberLiteral", value: 0 },
    }
    const result = gen.generateIfExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some((line: string) => line.startsWith("@ife.then."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@ife.else."))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@ife.end."))).toBe(true)
    expect(ir.some((line: string) => line.includes("jnz"))).toBe(true)
    expect(ir.filter((line: string) => line.includes("storel")).length).toBeGreaterThanOrEqual(2)
    expect(ir.some((line: string) => line.includes("loadl"))).toBe(true)
  })
})

describe("QBE Codegen - Block", () => {
  test("generateBlock iterates body statements", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const stmt = {
      type: "Block",
      body: [
        { type: "ExpressionStatement", expression: { type: "NumberLiteral", value: 1 } },
        { type: "ExpressionStatement", expression: { type: "NumberLiteral", value: 2 } },
      ],
    }
    gen.generateBlock(ir, stmt)
    // Block should process without error
    expect(true).toBe(true)
  })
})

describe("QBE Codegen - Interrupt Check", () => {
  test("emitInterruptCheck loads flag and branches", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    gen.emitInterruptCheck(ir, "@loop.cond.0", "@loop.end.0", "@loop.back.0")
    expect(ir.some((line: string) => line.includes("loadl $mog_interrupt_flag"))).toBe(true)
    expect(ir.some((line: string) => line.includes("cnel"))).toBe(true)
    expect(ir.some((line: string) => line.includes("jnz") && line.includes("@loop.end.0") && line.includes("@loop.back.0"))).toBe(true)
    expect(ir.some((line: string) => line.startsWith("@loop.back.0"))).toBe(true)
    expect(ir.some((line: string) => line.includes("jmp @loop.cond.0"))).toBe(true)
  })
})

// --- Control Flow Integration Tests ---

describe("QBE Codegen - Control Flow Integration", () => {
  function parse(source: string) {
    const tokens = tokenize(source).filter(t => t.type !== "WHITESPACE" && t.type !== "COMMENT")
    return parseTokens(tokens)
  }

  test("integration: if statement generates jnz and labels", () => {
    const ast = parse('if true { println("yes") }')
    const ir = generateQBEIR(ast)
    expect(ir).toContain("jnz")
    expect(ir).toContain("@then.")
    expect(ir).toContain("@else.")
    expect(ir).toContain("@endif.")
  })

  test("integration: if/else generates both branches", () => {
    const ast = parse('if false { println("a") } else { println("b") }')
    const ir = generateQBEIR(ast)
    expect(ir).toContain("jnz")
    expect(ir).toContain("@then.")
    expect(ir).toContain("@else.")
    expect(ir).toContain("@endif.")
    const printCalls = ir.split("\n").filter(line => line.includes("call $println"))
    expect(printCalls.length).toBeGreaterThanOrEqual(2)
  })

  test("integration: while loop generates loop structure", () => {
    const ast = parse("x := 0\nwhile (x < 10) { println(x) }")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("@while.cond.")
    expect(ir).toContain("@while.body.")
    expect(ir).toContain("@while.end.")
    expect(ir).toContain("jnz")
    expect(ir).toContain("$mog_interrupt_flag")
  })

  test("integration: for-in range generates loop with counter", () => {
    const ast = parse("for i in 0..10 { println(i) }")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("@for.cond.")
    expect(ir).toContain("@for.body.")
    expect(ir).toContain("@for.step.")
    expect(ir).toContain("@for.end.")
    expect(ir).toContain("csltl")
    expect(ir).toContain("$mog_interrupt_flag")
  })
})

// ============================================================
// Function Declaration Tests
// ============================================================

describe("QBE Codegen - Function Declaration", () => {
  function parse(source: string) {
    const tokens = tokenize(source).filter(t => t.type !== "WHITESPACE" && t.type !== "COMMENT")
    return parseTokens(tokens)
  }

  test("simple function with two params generates QBE function", () => {
    const ast = parse("fn add(a: int, b: int) -> int { return a + b; }")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("function")
    expect(ir).toContain("$add")
    expect(ir).toContain("@start")
    expect(ir).toContain("alloc8 8")
    // Should have storel for parameters
    expect(ir).toContain("storel %a,")
    expect(ir).toContain("storel %b,")
    // Should have add instruction
    expect(ir).toContain("add")
    expect(ir).toContain("ret")
  })

  test("function named main becomes program_user", () => {
    const ast = parse('fn main() { println("hello") }')
    const ir = generateQBEIR(ast)
    expect(ir).toContain("$program_user")
    expect(ir).toContain("@start")
  })

  test("void function omits return value", () => {
    const ast = parse('fn greet() { println("hi") }')
    const ir = generateQBEIR(ast)
    expect(ir).toContain("$greet")
    expect(ir).toContain("@start")
    // Should have a return (default ret 0 since return type defaults to l)
    expect(ir).toContain("ret")
  })

  test("function with return statement generates ret with value", () => {
    const ast = parse("fn double(x: int) -> int { return x * 2; }")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("$double")
    expect(ir).toContain("storel %x,")
    expect(ir).toContain("mul")
    expect(ir).toContain("ret")
  })

  test("function generates gc_push_frame and gc_pop_frame", () => {
    const ast = parse("fn foo() { return 1; }")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("call $gc_push_frame()")
  })

  test("multiple functions are generated separately", () => {
    const ast = parse("fn foo() -> int { return 1; }\nfn bar() -> int { return 2; }")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("$foo")
    expect(ir).toContain("$bar")
    // Each function should have its own @start
    const starts = ir.split("\n").filter(line => line.trim() === "@start")
    expect(starts.length).toBeGreaterThanOrEqual(2)
  })

  test("function with no params generates empty param list", () => {
    const ast = parse("fn nothing() -> int { return 42; }")
    const ir = generateQBEIR(ast)
    expect(ir).toContain("$nothing()")
  })
})

// ============================================================
// Struct Literal Tests
// ============================================================

describe("QBE Codegen - Struct Literal", () => {
  test("struct literal allocates and stores fields", () => {
    const gen = new QBECodeGen() as any
    gen.structDefs.set("Point", [
      { name: "x", fieldType: new IntegerType("i64") },
      { name: "y", fieldType: new IntegerType("i64") }
    ])
    const ir: string[] = []
    const expr = {
      type: "StructLiteral",
      structName: "Point",
      fields: [
        { name: "x", value: { type: "NumberLiteral", value: 10 } },
        { name: "y", value: { type: "NumberLiteral", value: 20 } }
      ]
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // Should allocate via gc_alloc
    expect(ir.some((line: string) => line.includes("call $gc_alloc(l 16)"))).toBe(true)
    // Should store field values
    expect(ir.some((line: string) => line.includes("storel 10,"))).toBe(true)
    expect(ir.some((line: string) => line.includes("storel 20,"))).toBe(true)
  })

  test("struct literal with 3 fields allocates 24 bytes", () => {
    const gen = new QBECodeGen() as any
    gen.structDefs.set("Vec3", [
      { name: "x", fieldType: new IntegerType("i64") },
      { name: "y", fieldType: new IntegerType("i64") },
      { name: "z", fieldType: new IntegerType("i64") }
    ])
    const ir: string[] = []
    const expr = {
      type: "StructLiteral",
      structName: "Vec3",
      fields: [
        { name: "x", value: { type: "NumberLiteral", value: 1 } },
        { name: "y", value: { type: "NumberLiteral", value: 2 } },
        { name: "z", value: { type: "NumberLiteral", value: 3 } }
      ]
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some((line: string) => line.includes("call $gc_alloc(l 24)"))).toBe(true)
  })

  test("struct literal with unknown struct still works", () => {
    const gen = new QBECodeGen() as any
    const ir: string[] = []
    const expr = {
      type: "StructLiteral",
      structName: null,
      fields: [
        { name: "a", value: { type: "NumberLiteral", value: 42 } }
      ]
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some((line: string) => line.includes("call $gc_alloc"))).toBe(true)
    expect(ir.some((line: string) => line.includes("storel 42,"))).toBe(true)
  })
})

// ============================================================
// Member Expression Tests
// ============================================================

describe("QBE Codegen - Member Expression", () => {
  test("struct member access loads field at correct offset", () => {
    const gen = new QBECodeGen() as any
    gen.structDefs.set("Point", [
      { name: "x", fieldType: new IntegerType("i64") },
      { name: "y", fieldType: new IntegerType("i64") }
    ])
    // Set up variable with struct type
    gen.variables.set("p", "%p.slot")
    gen.variableTypes.set("p", new StructType("Point"))
    const ir: string[] = []
    const expr = {
      type: "MemberExpression",
      object: { type: "Identifier", name: "p" },
      property: "x"
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // x is at offset 0, so should loadl directly from obj
    expect(ir.some((line: string) => line.includes("loadl"))).toBe(true)
  })

  test("struct member access at non-zero offset adds offset", () => {
    const gen = new QBECodeGen() as any
    gen.structDefs.set("Point", [
      { name: "x", fieldType: new IntegerType("i64") },
      { name: "y", fieldType: new IntegerType("i64") }
    ])
    gen.variables.set("p", "%p.slot")
    gen.variableTypes.set("p", new StructType("Point"))
    const ir: string[] = []
    const expr = {
      type: "MemberExpression",
      object: { type: "Identifier", name: "p" },
      property: "y"
    }
    const result = gen.generateExpression(ir, expr)
    // y is at offset 8, should have add <obj>, 8
    expect(ir.some((line: string) => line.includes("add") && line.includes("8"))).toBe(true)
    expect(ir.some((line: string) => line.includes("loadl"))).toBe(true)
  })

  test("array .len loads from offset 0", () => {
    const gen = new QBECodeGen() as any
    gen.variables.set("arr", "%arr.slot")
    gen.variableTypes.set("arr", new ArrayType(new IntegerType("i64"), []))
    const ir: string[] = []
    const expr = {
      type: "MemberExpression",
      object: { type: "Identifier", name: "arr" },
      property: "len"
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // Should load from the array header directly (offset 0 = length)
    expect(ir.some((line: string) => line.includes("loadl"))).toBe(true)
  })

  test("float struct field uses loadd", () => {
    const gen = new QBECodeGen() as any
    gen.structDefs.set("Particle", [
      { name: "mass", fieldType: new FloatType("f64") }
    ])
    gen.variables.set("p", "%p.slot")
    gen.variableTypes.set("p", new StructType("Particle"))
    const ir: string[] = []
    const expr = {
      type: "MemberExpression",
      object: { type: "Identifier", name: "p" },
      property: "mass"
    }
    const result = gen.generateExpression(ir, expr)
    expect(ir.some((line: string) => line.includes("loadd"))).toBe(true)
  })
})

// ============================================================
// Index Expression Tests
// ============================================================

describe("QBE Codegen - Index Expression", () => {
  test("array index loads data ptr and computes element offset", () => {
    const gen = new QBECodeGen() as any
    gen.variables.set("arr", "%arr.slot")
    gen.variableTypes.set("arr", new ArrayType(new IntegerType("i64"), []))
    const ir: string[] = []
    const expr = {
      type: "IndexExpression",
      object: { type: "Identifier", name: "arr" },
      index: { type: "NumberLiteral", value: 2 }
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // Should load data ptr from offset 16
    expect(ir.some((line: string) => line.includes("add") && line.includes("16"))).toBe(true)
    // Should multiply index by 8
    expect(ir.some((line: string) => line.includes("mul") && line.includes("8"))).toBe(true)
    // Should loadl the element
    expect(ir.some((line: string) => line.includes("loadl"))).toBe(true)
  })

  test("map index uses map_get", () => {
    const gen = new QBECodeGen() as any
    gen.variables.set("m", "%m.slot")
    gen.variableTypes.set("m", new MapType(new StringType(), new IntegerType("i64")))
    const ir: string[] = []
    const expr = {
      type: "IndexExpression",
      object: { type: "Identifier", name: "m" },
      index: { type: "StringLiteral", value: "key" }
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    expect(ir.some((line: string) => line.includes("call $map_get"))).toBe(true)
  })

  test("float array index uses loadd", () => {
    const gen = new QBECodeGen() as any
    gen.variables.set("arr", "%arr.slot")
    gen.variableTypes.set("arr", new ArrayType(new FloatType("f64"), []))
    const ir: string[] = []
    const expr = {
      type: "IndexExpression",
      object: { type: "Identifier", name: "arr" },
      index: { type: "NumberLiteral", value: 0 }
    }
    const result = gen.generateExpression(ir, expr)
    expect(ir.some((line: string) => line.includes("loadd"))).toBe(true)
  })
})

// ============================================================
// Lambda Expression Tests
// ============================================================

describe("QBE Codegen - Lambda Expression", () => {
  test("lambda generates closure pair and separate function", () => {
    const gen = new QBECodeGen() as any
    gen.inFunction = true
    gen.currentFunc = []
    gen.entryAllocs = []
    const ir: string[] = []
    const expr = {
      type: "Lambda",
      params: [{ name: "x" }],
      returnType: null,
      body: {
        type: "BinaryExpression",
        operator: "+",
        left: { type: "Identifier", name: "x" },
        right: { type: "NumberLiteral", value: 1 }
      },
      captures: []
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // Should allocate closure pair (16 bytes)
    expect(ir.some((line: string) => line.includes("call $gc_alloc(l 16)"))).toBe(true)
    // Should store function pointer
    expect(ir.some((line: string) => line.includes("storel $lambda."))).toBe(true)
    // Lambda function should be in lambdaFuncs
    expect(gen.lambdaFuncs.length).toBeGreaterThan(0)
    expect(gen.lambdaFuncs.some((line: string) => line.includes("$lambda.0"))).toBe(true)
  })

  test("lambda with captures stores captured values in env", () => {
    const gen = new QBECodeGen() as any
    gen.inFunction = true
    gen.currentFunc = []
    gen.entryAllocs = []
    // Set up an outer variable
    gen.variables.set("y", "%y.slot")
    gen.variableTypes.set("y", new IntegerType("i64"))
    const ir: string[] = []
    const expr = {
      type: "Lambda",
      params: [{ name: "x" }],
      returnType: null,
      body: {
        type: "BinaryExpression",
        operator: "+",
        left: { type: "Identifier", name: "x" },
        right: { type: "Identifier", name: "y" }
      },
      captures: ["y"]
    }
    const result = gen.generateExpression(ir, expr)
    // Should allocate env for captures (8 bytes for 1 capture)
    expect(ir.some((line: string) => line.includes("call $gc_alloc(l 8)"))).toBe(true)
    // Should allocate closure pair (16 bytes)
    expect(ir.some((line: string) => line.includes("call $gc_alloc(l 16)"))).toBe(true)
  })

  test("lambda with block body generates statements", () => {
    const gen = new QBECodeGen() as any
    gen.inFunction = true
    gen.currentFunc = []
    gen.entryAllocs = []
    const ir: string[] = []
    const expr = {
      type: "Lambda",
      params: [{ name: "x" }],
      returnType: null,
      body: {
        body: [
          {
            type: "ReturnStatement",
            value: { type: "BinaryExpression", operator: "*", left: { type: "Identifier", name: "x" }, right: { type: "NumberLiteral", value: 2 } }
          }
        ]
      },
      captures: []
    }
    const result = gen.generateExpression(ir, expr)
    expect(result).toMatch(/^%v\.\d+$/)
    // Lambda should contain a ret instruction
    expect(gen.lambdaFuncs.some((line: string) => line.includes("ret"))).toBe(true)
    expect(gen.lambdaFuncs.some((line: string) => line.includes("mul"))).toBe(true)
  })
})

// ============================================================
// Match Expression Tests
// ============================================================
describe("QBE Codegen - Match Expression", () => {
  function parse(source: string) {
    const tokens = tokenize(source).filter(t => t.type !== "WHITESPACE" && t.type !== "COMMENT")
    return parseTokens(tokens)
  }

  test("match expression generates arm labels and end label", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "MatchExpression",
      value: { type: "NumberLiteral", value: 42 },
      arms: [
        { pattern: { type: "IntegerLiteral", value: 1 }, body: { type: "NumberLiteral", value: 10 } },
        { pattern: { type: "Identifier", name: "_" }, body: { type: "NumberLiteral", value: 0 } }
      ]
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("@match.arm.")
    expect(irStr).toContain("@match.body.")
    expect(irStr).toContain("@match.end.")
    expect(irStr).toContain("@match.fall.")
    expect(irStr).toContain("ceql")
    expect(irStr).toContain("jnz")
    expect(irStr).toContain("storel")
    expect(irStr).toContain("loadl")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("match with wildcard pattern jumps directly to body", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "MatchExpression",
      value: { type: "NumberLiteral", value: 5 },
      arms: [
        { pattern: { type: "Identifier", name: "_" }, body: { type: "NumberLiteral", value: 99 } }
      ]
    }
    gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Wildcard arm should have jmp directly to body (not jnz)
    expect(irStr).toContain("jmp @match.body.")
  })

  test("match with string pattern uses string_eq", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "MatchExpression",
      value: { type: "Identifier", name: "x" },
      arms: [
        { pattern: { type: "StringLiteral", value: "hello" }, body: { type: "NumberLiteral", value: 1 } }
      ]
    }
    gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("$string_eq")
  })

  test("match with range pattern generates >= and <= checks", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "MatchExpression",
      value: { type: "NumberLiteral", value: 5 },
      arms: [
        { pattern: { type: "RangePattern", start: { value: 1 }, end: { value: 10 } }, body: { type: "NumberLiteral", value: 1 } }
      ]
    }
    gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("csgel")
    expect(irStr).toContain("cslel")
  })

  test("match with IsOk/IsErr patterns checks tag", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "MatchExpression",
      value: { type: "Identifier", name: "r" },
      arms: [
        { pattern: { type: "IsOk" }, body: { type: "NumberLiteral", value: 1 } },
        { pattern: { type: "IsErr" }, body: { type: "NumberLiteral", value: 0 } }
      ]
    }
    gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Should load tag and compare with 0 (Ok) and 1 (Err)
    expect(irStr).toContain("loadl")
    expect(irStr).toContain("ceql")
  })
})

// ============================================================
// Result/Optional Type Tests
// ============================================================
describe("QBE Codegen - Result and Optional Types", () => {
  test("Ok expression allocates 16 bytes and stores tag 0", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "Ok",
      value: { type: "NumberLiteral", value: 42 }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("call $gc_alloc(l 16)")
    expect(irStr).toContain("storel 0")  // tag = Ok
    expect(irStr).toContain("add")       // offset to payload
    expect(irStr).toContain("storel 42") // payload
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("Err expression allocates 16 bytes and stores tag 1", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "Err",
      value: { type: "NumberLiteral", value: 99 }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("call $gc_alloc(l 16)")
    expect(irStr).toContain("storel 1")  // tag = Err
    expect(irStr).toContain("storel 99") // payload
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("Some expression allocates 16 bytes and stores tag 0", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "Some",
      value: { type: "NumberLiteral", value: 7 }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("call $gc_alloc(l 16)")
    expect(irStr).toContain("storel 0")  // tag = Some
    expect(irStr).toContain("storel 7")  // payload
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("None expression allocates 16 bytes with tag 1 and payload 0", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = { type: "None" }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("call $gc_alloc(l 16)")
    expect(irStr).toContain("storel 1")  // tag = None
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("PropagateExpression loads tag and branches", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "PropagateExpression",
      value: { type: "Identifier", name: "result" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("loadl")        // load tag
    expect(irStr).toContain("ceql")          // compare tag
    expect(irStr).toContain("jnz")           // branch
    expect(irStr).toContain("@prop.ok.")
    expect(irStr).toContain("@prop.err.")
    expect(irStr).toContain("ret")           // early return on error
    expect(irStr).toContain("add")           // offset to payload
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("IsOk expression loads tag and compares with 0", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "IsOk",
      value: { type: "Identifier", name: "r" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("loadl")
    expect(irStr).toContain("ceql")
    expect(irStr).toContain("extsw")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("IsErr expression loads tag and compares with 1", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "IsErr",
      value: { type: "Identifier", name: "r" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("loadl")
    expect(irStr).toContain("ceql")
    // Verify it checks against 1 (Err tag)
    const lines = irStr.split("\n")
    const ceqLine = lines.find(l => l.includes("ceql") && l.includes(", 1"))
    expect(ceqLine).toBeDefined()
  })

  test("IsSome expression loads tag and compares with 0", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "IsSome",
      value: { type: "Identifier", name: "opt" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("loadl")
    expect(irStr).toContain("ceql")
    expect(irStr).toContain("extsw")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("IsNone expression loads tag and compares with 1", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "IsNone",
      value: { type: "Identifier", name: "opt" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("loadl")
    expect(irStr).toContain("ceql")
    expect(irStr).toContain("extsw")
    expect(result).toMatch(/^%v\.\d+$/)
  })
})

// ============================================================
// Capability Call Tests
// ============================================================
describe("QBE Codegen - Capability Calls", () => {
  test("capability call allocates args buffer and calls dispatcher", () => {
    const gen = new QBECodeGen()
    gen.setCapabilities(["fs"])
    const ir: string[] = []
    const result = (gen as any).generateCapabilityCall(
      ir, "fs", "readFile",
      ["%v.0", "%v.1"],
      { type: "CallExpression" }
    )
    const irStr = ir.join("\n")
    expect(irStr).toContain("call $gc_alloc")            // args buffer
    expect(irStr).toContain("storel %v.0")               // first arg
    expect(irStr).toContain("storel %v.1")               // second arg
    expect(irStr).toContain("call $mog_cap_call_out")    // dispatcher
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("capability call creates string constants for names", () => {
    const gen = new QBECodeGen()
    gen.setCapabilities(["net"])
    const ir: string[] = []
    ;(gen as any).generateCapabilityCall(
      ir, "net", "fetch",
      ["%v.0"],
      { type: "CallExpression" }
    )
    const irStr = ir.join("\n")
    // Should reference string constants for cap and func names
    expect(irStr).toContain("$str.")
    expect(irStr).toContain("$mog_cap_call_out")
  })

  test("capability call with zero args still allocates buffer", () => {
    const gen = new QBECodeGen()
    gen.setCapabilities(["timer"])
    const ir: string[] = []
    ;(gen as any).generateCapabilityCall(
      ir, "timer", "now",
      [],
      { type: "CallExpression" }
    )
    const irStr = ir.join("\n")
    expect(irStr).toContain("call $gc_alloc")
    expect(irStr).toContain("$mog_cap_call_out")
    // arg count should be 0
    expect(irStr).toContain(", l 0)")
  })
})

// ============================================================
// Cast Expression Tests
// ============================================================
describe("QBE Codegen - Cast Expression", () => {
  test("cast int to float generates swtof", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CastExpression",
      value: { type: "NumberLiteral", value: 42 },
      targetType: { name: "float" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("swtof")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("cast float to int generates dtosi", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CastExpression",
      value: { type: "Identifier", name: "x" },
      targetType: { name: "int" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("dtosi")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("cast to bool generates comparison != 0", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CastExpression",
      value: { type: "NumberLiteral", value: 5 },
      targetType: { name: "bool" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("cnel")
    expect(irStr).toContain("extsw")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("cast to string calls int_to_string", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "CastExpression",
      value: { type: "NumberLiteral", value: 42 },
      targetType: { name: "string" }
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("call $int_to_string")
    expect(result).toMatch(/^%v\.\d+$/)
  })
})

// ============================================================
// Async Function Declaration Tests
// ============================================================
describe("QBE Codegen - Async Functions", () => {
  test("async function creates future and returns it", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const stmt = {
      type: "AsyncFunctionDeclaration",
      name: "fetchData",
      isAsync: true,
      params: [],
      body: { body: [] },
    }
    ;(gen as any).generateAsyncFunctionDeclaration(ir, stmt)
    const irStr = ir.join("\n")
    // Should create a future
    expect(irStr).toContain("call $mog_future_new()")
    // Should complete future with 0 (no explicit return)
    expect(irStr).toContain("call $mog_future_complete(l %future, l 0)")
    // Should return the future pointer
    expect(irStr).toContain("ret %future")
    // Should have function signature with l return type
    expect(irStr).toContain("function l $fetchData")
    // Should have gc frame management
    expect(irStr).toContain("call $gc_push_frame()")
    expect(irStr).toContain("call $gc_pop_frame()")
  })

  test("async function with params allocates stack slots", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const stmt = {
      type: "AsyncFunctionDeclaration",
      name: "compute",
      isAsync: true,
      params: [
        { name: "x", paramType: { name: "int" } },
        { name: "y", paramType: { name: "int" } },
      ],
      body: { body: [] },
    }
    ;(gen as any).generateAsyncFunctionDeclaration(ir, stmt)
    const irStr = ir.join("\n")
    expect(irStr).toContain("function l $compute(l %x, l %y)")
    expect(irStr).toContain("alloc8 8")
    expect(irStr).toContain("storel %x,")
    expect(irStr).toContain("storel %y,")
  })

  test("async function with return completes future with value", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const stmt = {
      type: "AsyncFunctionDeclaration",
      name: "getValue",
      isAsync: true,
      params: [],
      body: {
        body: [
          { type: "ReturnStatement", value: { type: "NumberLiteral", value: 42 } },
        ],
      },
    }
    ;(gen as any).generateAsyncFunctionDeclaration(ir, stmt)
    const irStr = ir.join("\n")
    // Should complete future with the value
    expect(irStr).toContain("call $mog_future_complete(l %future, l 42)")
    expect(irStr).toContain("ret %future")
  })
})

// ============================================================
// Await Expression Tests
// ============================================================
describe("QBE Codegen - Await Expression", () => {
  test("await calls mog_await and mog_future_get_result", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "AwaitExpression",
      argument: { type: "Identifier", name: "f" },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Should call mog_await with the future and 0 coro handle
    expect(irStr).toContain("call $mog_await(")
    expect(irStr).toContain(", l 0)")
    // Should get the result
    expect(irStr).toContain("call $mog_future_get_result(")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("await generates result from nested call expression", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "AwaitExpression",
      argument: {
        type: "CallExpression",
        callee: { type: "Identifier", name: "fetchData" },
        arguments: [],
      },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Should generate the call first
    expect(irStr).toContain("call $fetchData(")
    // Then await and get result
    expect(irStr).toContain("call $mog_await(")
    expect(irStr).toContain("call $mog_future_get_result(")
    expect(result).toMatch(/^%v\.\d+$/)
  })
})

// ============================================================
// Spawn Expression Tests
// ============================================================
describe("QBE Codegen - Spawn Expression", () => {
  test("spawn generates expression and enqueues on loop", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "SpawnExpression",
      expression: {
        type: "CallExpression",
        callee: { type: "Identifier", name: "doWork" },
        arguments: [],
      },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Should call the function
    expect(irStr).toContain("call $doWork(")
    // Should enqueue on the event loop
    expect(irStr).toContain("call $mog_loop_enqueue_ready(l 0,")
    // Returns the future pointer
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("spawn with simple expression enqueues and returns value", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "SpawnExpression",
      expression: { type: "NumberLiteral", value: 99 },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    expect(irStr).toContain("call $mog_loop_enqueue_ready(")
    // The literal 99 is the "future" — returned as-is
    expect(result).toBe("99")
  })
})

// ============================================================
// SoA Constructor Tests
// ============================================================
describe("QBE Codegen - SoA Constructor", () => {
  test("SoA constructor allocates header and per-field arrays", () => {
    const gen = new QBECodeGen()
    // Pre-register a struct with 3 fields
    ;(gen as any).structDefs.set("Particle", [
      { name: "x", fieldType: { name: "float" } },
      { name: "y", fieldType: { name: "float" } },
      { name: "mass", fieldType: { name: "float" } },
    ])
    const ir: string[] = []
    const expr = {
      type: "SoAConstructor",
      name: "Particle",
      count: { type: "NumberLiteral", value: 1000 },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Header: (3 fields + 1 count) * 8 = 32 bytes
    expect(irStr).toContain("call $gc_alloc(l 32)")
    // Should store count at offset 0
    expect(irStr).toContain("storel 1000,")
    // 3 field arrays allocated (each count * 8)
    const fieldAllocs = ir.filter(line => line.includes("call $gc_alloc") && !line.includes("l 32)"))
    expect(fieldAllocs.length).toBe(3)
    // Each field array pointer stored at offsets 8, 16, 24
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("SoA constructor with dynamic count computes sizes at runtime", () => {
    const gen = new QBECodeGen()
    ;(gen as any).structDefs.set("Vec2", [
      { name: "x", fieldType: { name: "float" } },
      { name: "y", fieldType: { name: "float" } },
    ])
    const ir: string[] = []
    const expr = {
      type: "SoAConstructor",
      name: "Vec2",
      count: { type: "Identifier", name: "n" },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Header: (2 fields + 1 count) * 8 = 24 bytes
    expect(irStr).toContain("call $gc_alloc(l 24)")
    // Should have mul instructions for dynamic sizes
    expect(irStr).toContain("mul")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("SoA constructor with no struct def allocates header with count only", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "SoAConstructor",
      name: "Unknown",
      count: { type: "NumberLiteral", value: 10 },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Header: (0 fields + 1 count) * 8 = 8 bytes
    expect(irStr).toContain("call $gc_alloc(l 8)")
    // Only stores count
    expect(irStr).toContain("storel 10,")
    expect(result).toMatch(/^%v\.\d+$/)
  })
})

// ============================================================
// Slice Expression Tests
// ============================================================
describe("QBE Codegen - Slice Expression", () => {
  test("slice with start and end creates new array with copy loop", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "SliceExpression",
      object: { type: "Identifier", name: "arr" },
      start: { type: "NumberLiteral", value: 1 },
      end: { type: "NumberLiteral", value: 4 },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Should load source length and data ptr
    expect(irStr).toContain("loadl")
    // Should compute new length: end - start
    expect(irStr).toContain("sub 4, 1")
    // Should allocate new header (24 bytes) and data
    expect(ir.filter(line => line.includes("call $gc_alloc")).length).toBe(2)
    // Should have a copy loop with labels
    expect(irStr).toContain("@L.")
    expect(irStr).toContain("jnz")
    expect(irStr).toContain("jmp")
    // Should store len, cap, data ptr in new header
    const storeLines = ir.filter(line => line.includes("storel"))
    expect(storeLines.length).toBeGreaterThanOrEqual(3) // len + cap + data_ptr + loop stores
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("slice with no start defaults to 0", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "SliceExpression",
      object: { type: "Identifier", name: "arr" },
      end: { type: "NumberLiteral", value: 3 },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Should subtract from 0: end - 0
    expect(irStr).toContain("sub 3, 0")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("slice with no end defaults to array length", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "SliceExpression",
      object: { type: "Identifier", name: "arr" },
      start: { type: "NumberLiteral", value: 2 },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // End defaults to loaded length, so sub should use the loaded reg
    expect(irStr).toMatch(/sub %v\.\d+, 2/)
    expect(result).toMatch(/^%v\.\d+$/)
  })
})

// ============================================================
// Tensor Construction Tests
// ============================================================
describe("QBE Codegen - Tensor Construction", () => {
  test("1D tensor construction calls tensor_create", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "TensorConstruction",
      data: { type: "Identifier", name: "data" },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Should load data ptr from offset 16
    expect(irStr).toContain("add")
    expect(irStr).toContain(", 16")
    // Should load length from offset 0
    expect(irStr).toContain("loadl")
    // Should call tensor_create
    expect(irStr).toContain("call $tensor_create(")
    expect(result).toMatch(/^%v\.\d+$/)
  })

  test("N-dimensional tensor calls tensor_from_array with shape", () => {
    const gen = new QBECodeGen()
    const ir: string[] = []
    const expr = {
      type: "TensorConstruction",
      data: { type: "Identifier", name: "data" },
      shape: { type: "Identifier", name: "shape" },
    }
    const result = gen.generateExpression(ir, expr)
    const irStr = ir.join("\n")
    // Should call tensor_from_array
    expect(irStr).toContain("call $tensor_from_array(")
    // Should load ndim from shape length (offset 0)
    expect(irStr).toContain("loadl")
    // Should load shape data pointer (offset 16)
    expect(irStr).toContain(", 16")
    expect(result).toMatch(/^%v\.\d+$/)
  })
})
