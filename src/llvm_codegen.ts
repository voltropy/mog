import type { ProgramNode, StatementNode, ExpressionNode } from "./analyzer.js"
import type { ArrayType } from "./types.js"
import { isArrayType, isMapType, isFloatType, IntegerType, ResultType, OptionalType } from "./types.js"

type LLVMType = "i8" | "i16" | "i32" | "i64" | "i128" | "i256" | "half" | "float" | "double" | "fp128" | "void" | "ptr"

type LLVMValue = {
  name: string
  type: LLVMType
  isConstant?: boolean
}

type LLVMFunction = {
  name: string
  returnType: LLVMType
  params: LLVMValue[]
  body: string[]
}

type LLVMGlobal = {
  name: string
  type: LLVMType
  initValue?: string
}

type OptimizationOptions = {
  /** Enable release mode optimizations (bounds check elision) */
  releaseMode: boolean
  /** Enable vectorization hints for array operations */
  vectorization: boolean
  /** Inline threshold: functions with fewer basic blocks will be marked alwaysinline */
  inlineThreshold: number
}

const defaultOptimizationOptions: OptimizationOptions = {
  releaseMode: process.env.MOG_RELEASE === "1",
  vectorization: true,
  inlineThreshold: 3,
}

class LLVMIRGenerator {
  private functions: Map<string, LLVMFunction> = new Map()
  private globals: LLVMGlobal[] = []
  private currentFunction: LLVMFunction | null = null
  private blockCounter = 0
  private valueCounter = 0
  private variableTypes: Map<string, any> = new Map()
  private functionTypes: Map<string, any> = new Map()
  private loopStack: { breakLabel: string; continueLabel: string }[] = []
  private blockTerminated = false
  private opts: OptimizationOptions
  private currentFunctionBasicBlocks = 0

  constructor(options: Partial<OptimizationOptions> = {}) {
    this.opts = { ...defaultOptimizationOptions, ...options }
  }

  setCapabilities(caps: string[]): void {
    for (const cap of caps) {
      this.capabilities.add(cap)
    }
  }

  private resetValueCounter(start: number = 0): void {
    this.valueCounter = start
  }
  private labelCounter = 0
  private stringConstants: string[] = []
  private stringCounter = 0
  private stringNameMap: Map<string, string> = new Map()
  private lambdaCounter = 0
  private lambdaIR: string[] = []
  // Track function parameter info for named arg / default arg resolution
  private functionParamInfo: Map<string, { name: string; paramType: any; defaultValue?: any }[]> = new Map()
  // Struct definitions: maps struct name -> ordered list of { name, type } fields
  private structDefs: Map<string, { name: string; fieldType: any }[]> = new Map()
  // Capability tracking for Host FFI
  private capabilities: Set<string> = new Set()
  private capCallDeclared = false
  private capStringConstants: string[] = []
  private resetStringCounter(): void {
    this.stringCounter = 0
    this.stringNameMap.clear()
  }

  generate(ast: ProgramNode): string {
    const ir: string[] = []

    ir.push("; Mog LLVM IR")
    ir.push("; Generated by Mog compiler")
    ir.push("")

    const platform = process.platform === "darwin" ? "aarch64-apple-darwin" :
                     process.platform === "win32" ? "x86_64-pc-windows-msvc" :
                     "x86_64-unknown-linux-gnu"
    ir.push(`target triple = "${platform}"`)
    ir.push("")

    this.setupDeclarations(ir)
    this.generatePrintDeclarations(ir)
    this.generateSocketDeclarations(ir)
    if (this.capabilities.size > 0) {
      this.generateCapabilityDeclarations(ir)
    }

    this.resetValueCounter(0)
    this.resetStringCounter()
    this.stringConstants = []  // Clear string constants

    // First: collect all string constants from AST
    this.collectStringConstants(ast)
    // Reset counter for code generation pass
    this.stringCounter = 0

    // Collect struct/SoA definitions from top-level statements
    for (const stmt of ast.statements) {
      if (stmt.type === "StructDeclaration") {
        const fields = (stmt as any).fields?.map((f: any) => ({
          name: f.name,
          fieldType: f.fieldType
        })) || []
        this.structDefs.set((stmt as any).name, fields)
      } else if (stmt.type === "SoADeclaration") {
        const soaFields = (stmt as any).fields?.map((f: any) => ({
          name: f.name,
          fieldType: f.fieldType
        })) || []
        this.structDefs.set((stmt as any).name, soaFields)
      }
    }

    // Collect function declarations first to identify strings in functions
    const functionDeclarations = this.collectFunctionDeclarations(ast)

    // Check if user has defined a main() function
    const mainFunc = functionDeclarations.find((f: any) => f.name === "main")
    const hasMain = !!mainFunc

    // Insert string constants before function declarations
    ir.push("; String constants")
    for (const str of this.stringConstants) {
      ir.push(str)
    }
    ir.push("")

    ir.push("; Function declarations")
    // First pass: register all function types before generating code
    for (const funcDecl of functionDeclarations) {
      this.functionTypes.set(funcDecl.name, funcDecl.returnType)
    }
    // Register function parameter info for named/default arg handling
    for (const funcDecl of functionDeclarations) {
      this.functionParamInfo.set(funcDecl.name === "main" ? "program_user" : funcDecl.name, funcDecl.params)
    }
    for (const funcDecl of functionDeclarations) {
      // Rename user's main() to @program_user to avoid conflict
      if (funcDecl.name === "main") {
        funcDecl.name = "program_user"
      }
      this.generateFunctionDeclaration(ir, funcDecl)
    }
    ir.push("")

    // Emit lifted lambda functions
    if (this.lambdaIR.length > 0) {
      ir.push("; Lambda functions")
      ir.push(...this.lambdaIR)
      ir.push("")
    }

    if (hasMain) {
      // User defined main() - generate wrapper at @main
      ir.push("; Main entry point (calls user's main)")
      
      const hasParams = mainFunc && mainFunc.params.length >= 2
      
      if (hasParams) {
        ir.push("define i32 @main(i32 %argc, ptr %argv) {")
        ir.push("entry:")
        ir.push("  call void @gc_init()")
        ir.push("  call void @gc_push_frame()")
        
        // Build array of length argc with argv pointers
        ir.push("  %args_array = call ptr @array_alloc(i64 8, i64 1, i64 %argc)")
        
        // Loop through argv and store pointers in array
        ir.push("  %args_array_data = getelementptr ptr, ptr %args_array, i64 0")
        
        // Process first 10 arguments (to keep code size reasonable)
        for (let i = 0; i < 10; i++) {
          ir.push(`  ; Process argv[${i}]`)
          ir.push(`  %argv_gep_${i} = getelementptr ptr, ptr %argv, i64 ${i}`)
          ir.push(`  %argv_ptr_${i} = load ptr, ptr %argv_gep_${i}`)
          ir.push(`  %in_bounds_${i} = icmp ult i64 ${i}, %argc`)
          ir.push(`  br i1 %in_bounds_${i}, label %store_argv_${i}, label %argv_done_${i}`)
          ir.push(`store_argv_${i}:`)
          ir.push(`  %array_gep_${i} = getelementptr i64, ptr %args_array_data, i64 ${i}`)
          ir.push(`  %argv_int_${i} = ptrtoint ptr %argv_ptr_${i} to i64`)
          ir.push(`  store i64 %argv_int_${i}, ptr %array_gep_${i}`)
          ir.push(`  br label %argv_done_${i}`)
          ir.push(`argv_done_${i}:`)
        }
        ir.push(`  ; Skip remaining argv elements (10..)`)
        
        // Create CLI args table (argc + args array)
        ir.push("  %cli_table = call ptr @map_new(i64 2)")
        ir.push("  %argc_key = alloca [5 x i8]")
        ir.push("  store [5 x i8] c\"argc\\00\", ptr %argc_key")
        ir.push("  call void @map_set(ptr %cli_table, ptr %argc_key, i64 4, i64 %argc)")
        
        ir.push("  %args_key = alloca [5 x i8]")
        ir.push("  store [5 x i8] c\"args\\00\", ptr %args_key")
        ir.push("  %args_int = ptrtoint ptr %args_array to i64")
        ir.push("  call void @map_set(ptr %cli_table, ptr %args_key, i64 4, i64 %args_int)")
        
        ir.push("  %cli_table_int = ptrtoint ptr %cli_table to i64")
        
        // Call user's main with CLI args table
        ir.push("  %result = call i64 @program_user(i64 %argc, i64 %cli_table_int)")
      } else {
        ir.push("define i32 @main(i32 %argc, ptr %argv) {")
        ir.push("entry:")
        ir.push("  call void @gc_init()")
        ir.push("  call void @gc_push_frame()")
        ir.push("  %result = call i64 @program_user()")
      }
      
      ir.push("  %truncated = trunc i64 %result to i32")
      ir.push("  call void @gc_pop_frame()")
      ir.push("  ret i32 %truncated")
      ir.push("}")
    } else {
      // No main() - use program() entry point
      this.resetValueCounter(10)
      
      ir.push("define void @program() {")
      ir.push("entry:")

      this.blockTerminated = false
      for (const statement of ast.statements) {
        this.generateStatement(ir, statement)
        if (this.blockTerminated) break
      }

      if (!this.blockTerminated) {
        ir.push("  ret void")
      }
      ir.push("}")

      this.setupMainFunction(ir)
    }

    this.generateRuntimeFunctions(ir)
    this.generatePOSIXDeclarations(ir)

    return ir.join("\n")
  }

  private collectFunctionDeclarations(ast: ProgramNode): any[] {
    const functions: any[] = []
    const declarations = this.findFunctionDeclarationsRecursive(ast.statements)
    functions.push(...declarations)
    return functions
  }

  private findFunctionDeclarationsRecursive(statements: any[]): any[] {
    const functions: any[] = []
    for (const stmt of statements) {
      if (stmt.type === "FunctionDeclaration") {
        functions.push(stmt)
        // Recursively find nested function declarations in the function body
        if (stmt.body?.statements) {
          functions.push(...this.findFunctionDeclarationsRecursive(stmt.body.statements))
        }
      } else if (stmt.type === "Block") {
        functions.push(...this.findFunctionDeclarationsRecursive(stmt.statements))
      }
    }
    return functions
  }

  private setupDeclarations(ir: string[]): void {
    ir.push("; Declare external LLM function")
    ir.push("declare ptr @llm_call(ptr %prompt, ptr %options, ptr %return_type)")
    ir.push("")

    ir.push("; Declare GC functions")
    ir.push("declare void @gc_init()")
    ir.push("declare ptr @gc_alloc(i64)")
    ir.push("declare void @gc_collect()")
    ir.push("declare void @gc_push_frame()")
    ir.push("declare void @gc_pop_frame()")
    ir.push("declare void @gc_benchmark_stats()")
    ir.push("declare void @gc_reset_stats()")
    ir.push("")

    ir.push("; Declare array functions")
    ir.push("declare ptr @array_alloc(i64 %element_size, i64 %dimension_count, ptr %dimensions)")
    ir.push("declare i64 @array_get(ptr %array, i64 %index)")
    ir.push("declare void @array_set(ptr %array, i64 %index, i64 %value)")
    ir.push("declare float @array_get_f32(ptr %array, i64 %index)")
    ir.push("declare void @array_set_f32(ptr %array, i64 %index, float %value)")
    ir.push("declare double @array_get_f64(ptr %array, i64 %index)")
    ir.push("declare void @array_set_f64(ptr %array, i64 %index, double %value)")
    ir.push("declare i64 @array_length(ptr %array)")
    ir.push("declare ptr @array_slice(ptr %array, i64 %start, i64 %end)")
    ir.push("declare ptr @array_slice_step(ptr %array, i64 %start, i64 %end, i64 %step)")
    ir.push("declare float @dot_f32(ptr %a, ptr %b)")
    ir.push("declare double @dot_f64(ptr %a, ptr %b)")
    ir.push("declare ptr @matmul(ptr %a, ptr %b)")
    ir.push("declare ptr @matrix_add(ptr %a, ptr %b)")
    ir.push("")

    ir.push("; Declare map functions")
    ir.push("declare ptr @map_new(i64 %initial_capacity)")
    ir.push("declare i64 @map_get(ptr %map, ptr %key, i64 %key_len)")
    ir.push("declare void @map_set(ptr %map, ptr %key, i64 %key_len, i64 %value)")
    ir.push("")

    ir.push("; Declare string functions")
    ir.push("declare i64 @string_length(ptr %str)")
    ir.push("declare ptr @string_concat(ptr %a, ptr %b)")
    ir.push("declare ptr @string_char_at(ptr %str, i64 %index)")
    ir.push("declare ptr @string_slice(ptr %str, i64 %start, i64 %end)")
    ir.push("declare ptr @i64_to_string(i64 %value)")
    ir.push("declare ptr @u64_to_string(i64 %value)")
    ir.push("declare ptr @f64_to_string(double %value)")
    ir.push("")

    ir.push("; Declare CLI argument helper functions")
    ir.push("declare i64 @get_argc_value(ptr %cli_table)")
    ir.push("declare i64 @get_argv_value(ptr %cli_table, i64 %index)")
    ir.push("")

    ir.push("; Declare Result/Optional helper functions")
    ir.push("declare ptr @mog_result_ok(i64 %value)")
    ir.push("declare ptr @mog_result_err(ptr %message)")
    ir.push("declare i64 @mog_result_is_ok(ptr %result)")
    ir.push("declare i64 @mog_result_unwrap(ptr %result)")
    ir.push("declare ptr @mog_result_unwrap_err(ptr %result)")
    ir.push("declare ptr @mog_optional_some(i64 %value)")
    ir.push("declare ptr @mog_optional_none()")
    ir.push("declare i64 @mog_optional_is_some(ptr %optional)")
    ir.push("declare i64 @mog_optional_unwrap(ptr %optional)")
    ir.push("")
  }

  private generateStatement(ir: string[], statement: StatementNode): void {
    // Skip if current block is already terminated
    if (this.blockTerminated) {
      return
    }

    switch (statement.type) {
      case "VariableDeclaration": {
        const llvmType = this.toLLVMType(statement.varType)
        const reg = `%${statement.name}`
        const isPointerLike = statement.varType?.type === "ArrayType" || statement.varType?.type === "PointerType" 
          || statement.varType?.type === "StructType" || statement.varType?.type === "CustomType"
          || statement.varType?.type === "SOAType" || statement.varType?.type === "FunctionType"
        const allocaType = isPointerLike ? "ptr" : llvmType
        ir.push(`  ${reg} = alloca ${allocaType}`)
        this.variableTypes.set(statement.name, statement.varType)
        if (statement.value) {
          const value = this.generateExpression(ir, statement.value)
          const isPointerLike2 = statement.varType?.type === "ArrayType" || statement.varType?.type === "PointerType"
            || statement.varType?.type === "StructType" || statement.varType?.type === "CustomType"
            || statement.varType?.type === "SOAType" || statement.varType?.type === "FunctionType"
          const storeType = isPointerLike2 ? "ptr" : llvmType
          ir.push(`  store ${storeType} ${value}, ptr ${reg}`)
        }
        break
      }
      case "Assignment": {
        const value = this.generateExpression(ir, statement.value)
        const varType = this.variableTypes.get(statement.name)
        const llvmType = this.toLLVMType(varType)
        ir.push(`  store ${llvmType} ${value}, ptr %${statement.name}`)
        break
      }
      case "ExpressionStatement":
        this.generateExpression(ir, statement.expression)
        break
      case "Block":
        this.blockTerminated = false
        for (const stmt of statement.statements) {
          this.generateStatement(ir, stmt)
          if (this.blockTerminated) break
        }
        break
      case "Return": {
        let value = null
        if (statement.value) {
          value = this.generateExpression(ir, statement.value)
        }
        ir.push("  call void @gc_pop_frame()")
        if (value) {
          const returnType = this.currentFunction?.returnType || "i64"
          ir.push(`  ret ${returnType} ${value}`)
        } else {
          ir.push(`  ret void`)
        }
        this.blockTerminated = true
        break
      }
      case "Conditional":
        this.generateConditional(ir, statement)
        break
      case "FunctionDeclaration":
        break
      case "StructDeclaration": {
        // Register struct field definitions for codegen
        const fields = (statement as any).fields?.map((f: any) => ({
          name: f.name,
          fieldType: f.fieldType
        })) || []
        this.structDefs.set((statement as any).name, fields)
        break
      }
      case "SoADeclaration": {
        // Register SoA definitions (similar to struct but fields are arrays)
        const soaFields = (statement as any).fields?.map((f: any) => ({
          name: f.name,
          fieldType: f.fieldType
        })) || []
        this.structDefs.set((statement as any).name, soaFields)
        break
      }
      case "WhileLoop":
        this.generateWhileLoop(ir, statement)
        break
      case "ForLoop":
        this.generateForLoop(ir, statement)
        break
      case "ForEachLoop":
        this.generateForEachLoop(ir, statement)
        break
      case "ForInRange":
        this.generateForInRange(ir, statement)
        break
      case "ForInIndex":
        this.generateForInIndex(ir, statement)
        break
      case "Break":
        this.generateBreak(ir)
        break
      case "Continue":
        this.generateContinue(ir)
        break
      case "TryCatch":
        this.generateTryCatch(ir, statement)
        break
      default:
        break
    }
  }

  private generateExpression(ir: string[], expr: any): string {
    switch (expr.type) {
      case "AssignmentExpression":
        return this.generateAssignmentExpression(ir, expr)
      case "NumberLiteral": {
        // Handle float literals - convert to integer bit pattern for storage
        const val = String(expr.value)
        // Check if it's a float literal (has decimal point or exponent)
        const isFloat = val.includes(".") || val.toLowerCase().includes("e")
        if (isFloat) {
          const numVal = parseFloat(val)
          // Determine target float type from literalType annotation
          const floatKind = expr.literalType?.kind || "f64"
          // Convert to integer bit pattern (not hex float format)
          return this.floatToIntBits(numVal, floatKind)
        }
        // Integer literal - parse octal if needed
        let intVal: number
        if (val.startsWith("0") && val.length > 1) {
          intVal = parseInt(val, 8)
        } else {
          intVal = parseInt(val, 10)
        }
        return `${intVal}`
      }
      case "POSIXConstant":
        return `${expr.value}`
      case "StringLiteral": {
        const name = this.generateStringLiteral(ir, expr.value)
        const ptrReg = `%${this.valueCounter++}`
        ir.push(`  ${ptrReg} = getelementptr [${expr.value.length + 1} x i8], ptr ${name}, i64 0, i64 0`)
        return ptrReg
      }
      case "TemplateLiteral":
        return this.generateTemplateLiteral(ir, expr)
      case "Identifier": {
        const name = expr.name
        const ptrReg = `%${name}_local`
        const valReg = `%${this.valueCounter++}`

        const varType = this.variableTypes.get(name)
        const isPointerLike = varType?.type === "ArrayType" || varType?.type === "PointerType" || 
                              varType?.type === "StructType" || varType?.type === "CustomType" || 
                              varType?.type === "SOAType" || varType?.type === "FunctionType"

        // Determine LLVM type for loading
        let llvmLoadType = "i64"
        if (varType?.type === "FloatType") {
          llvmLoadType = this.toLLVMType(varType)
        }

        if (this.currentFunction && this.currentFunction.params.find((p) => p.name === name)) {
          if (isPointerLike) {
            const loaded = `%${this.valueCounter++}`
            ir.push(`  ${loaded} = load ptr, ptr ${ptrReg}`)
            return loaded
          }
          ir.push(`  ${valReg} = load ${llvmLoadType}, ptr ${ptrReg}`)
          return valReg
        }

        if (isPointerLike) {
          const loaded = `%${this.valueCounter++}`
          ir.push(`  ${loaded} = load ptr, ptr %${name}`)
          return loaded
        }

        ir.push(`  ${valReg} = load ${llvmLoadType}, ptr %${name}`)
        return valReg
      }
      case "BinaryExpression":
        return this.generateBinaryExpression(ir, expr)
      case "UnaryExpression":
        return this.generateUnaryExpression(ir, expr)
      case "CallExpression":
        return this.generateCallExpression(ir, expr)
      case "ArrayLiteral":
        return this.generateArrayLiteral(ir, expr)
      case "ArrayFill":
        return this.generateArrayFill(ir, expr)
      case "MapLiteral":
        return this.generateMapLiteral(ir, expr)
      case "StructLiteral":
        return this.generateStructLiteral(ir, expr)
      case "SoALiteral":
        return this.generateSoALiteral(ir, expr)
      case "MemberExpression":
        return this.generateMemberExpression(ir, expr)
      case "IndexExpression":
        return this.generateIndexExpression(ir, expr)
      case "SliceExpression":
        return this.generateSliceExpression(ir, expr)
      case "LLMCall":
        return this.generateLLMCall(ir, expr)
      case "MapExpression":
        return this.generateMapExpression(ir, expr)
      case "CastExpression":
        return this.generateCastExpression(ir, expr)
      case "IfExpression":
        return this.generateIfExpression(ir, expr)
      case "MatchExpression":
        return this.generateMatchExpression(ir, expr)
      case "Lambda":
        return this.generateLambda(ir, expr)
      case "OkExpression":
        return this.generateOkExpression(ir, expr)
      case "ErrExpression":
        return this.generateErrExpression(ir, expr)
      case "SomeExpression":
        return this.generateSomeExpression(ir, expr)
      case "NoneExpression":
        return this.generateNoneExpression(ir)
      case "PropagateExpression":
        return this.generatePropagateExpression(ir, expr)
      case "IsSomeExpression":
        return this.generateIsSomeExpression(ir, expr)
      case "IsNoneExpression":
        return this.generateIsNoneExpression(ir, expr)
      case "IsOkExpression":
        return this.generateIsOkExpression(ir, expr)
      case "IsErrExpression":
        return this.generateIsErrExpression(ir, expr)
      default:
        return ""
    }
  }

  private generateStringLiteral(_ir: string[], value: string): string {
    // Look up the name from the map, or create a new one
    let name = this.stringNameMap.get(value)
    if (!name) {
      name = `@str${this.stringCounter++}`
      this.stringNameMap.set(value, name)
    }
    return name
  }

  private collectStringFromNode(node: any): void {
    if (!node) return

    if (node.type === "StringLiteral") {
      const name = `@str${this.stringCounter++}`
      this.stringNameMap.set(node.value, name)
      // Convert string to LLVM IR format
      // The node.value contains actual characters (\r becomes carriage return, etc.)
      // We need to escape for LLVM IR and convert control chars to LLVM escape sequences
      // node.value now contains decoded characters (actual \r, \n, etc.)
      // Need to convert to LLVM IR escape sequences
      let llvmEscaped = ""
      for (const char of node.value) {
        const code = char.charCodeAt(0)
        if (char === "\\") {
          llvmEscaped += "\\\\"
        } else if (char === '"') {
          llvmEscaped += '\\"'
        } else if (code === 10) {  // newline - actual \n char
          llvmEscaped += "\\0A"
        } else if (code === 13) {  // carriage return - actual \r char
          llvmEscaped += "\\0D"
        } else if (code === 9) {   // tab - actual \t char
          llvmEscaped += "\\09"
        } else if (code < 32 || code > 126) {
          // Other non-printable chars - use hex escape
          llvmEscaped += `\\${code.toString(16).padStart(2, "0").toUpperCase()}`
        } else {
          llvmEscaped += char
        }
      }
      const strDef = `${name} = private unnamed_addr constant [${node.value.length + 1} x i8] c"${llvmEscaped}\\00"`
      this.stringConstants.push(strDef)
      return
    }

    // Collect strings from template literals
    if (node.type === "TemplateLiteral") {
      for (const part of node.parts) {
        if (typeof part === "string") {
          const name = `@str${this.stringCounter++}`
          // Escape backslash and quote for LLVM IR, then convert escape sequences to LLVM format
          const llvmEscaped = part
            .replace(/\\/g, "\\\\")    // Escape backslash
            .replace(/"/g, '\\"')      // Escape quote
            .replace(/\n/g, "\\0A")     // Newline -> \0A
            .replace(/\r/g, "\\0D")     // Carriage return -> \0D
            .replace(/\t/g, "\\09")     // Tab -> \09
          const strDef = `${name} = private unnamed_addr constant [${part.length + 1} x i8] c"${llvmEscaped}\\00"`
          this.stringConstants.push(strDef)
        } else {
          this.collectStringFromNode(part)
        }
      }
      return
    }

    // Collect MemberExpression property names as string constants
    if (node.type === "MemberExpression") {
      const name = `@key_${node.property}_${this.stringCounter++}`
      const llvmEscaped = node.property
        .replace(/\\/g, "\\\\")    // Escape backslash
        .replace(/"/g, '\\"')      // Escape quote
        .replace(/\n/g, "\\0A")     // Newline -> \0A
        .replace(/\r/g, "\\0D")     // Carriage return -> \0D
        .replace(/\t/g, "\\09")     // Tab -> \09
      const strDef = `${name} = private unnamed_addr constant [${node.property.length + 1} x i8] c"${llvmEscaped}\\00"`
      this.stringConstants.push(strDef)
    }

    // Recursively collect from child nodes
    for (const key in node) {
      if (key === 'position' || key.startsWith('_')) continue
      const value = node[key]
      if (Array.isArray(value)) {
        value.forEach(child => this.collectStringFromNode(child))
      } else if (typeof value === 'object' && value !== null) {
        this.collectStringFromNode(value)
      }
    }
  }

  private collectStringConstants(ast: any): void {
    this.collectStringFromNode(ast)
  }

  private inferExpressionType(expr: any): string {
    // Infer the type of an expression for template literal conversion
    switch (expr.type) {
      case "StringLiteral":
        return "string"
      case "NumberLiteral": {
        const val = String(expr.value)
        if (val.includes(".") || val.toLowerCase().includes("e")) {
          return "f64"
        }
        return "i64"
      }
      case "Identifier": {
        const varType = this.variableTypes.get(expr.name)
        if (varType?.type === "FloatType") return varType.kind || "f64"
        if (varType?.type === "IntegerType") return varType.kind || "i64"
        if (varType?.type === "UnsignedType") return varType.kind || "u64"
        if (varType?.type === "ArrayType") return "string" // [u8] strings
        return "i64" // default
      }
      case "BinaryExpression": {
        // For binary expressions, determine based on operands
        if (this.isFloatOperand(expr.left) || this.isFloatOperand(expr.right)) {
          return "f64"
        }
        return "i64"
      }
      case "CallExpression": {
        const funcName = expr.function?.name || expr.callee?.name
        if (funcName) {
          const func = this.functions.get(funcName)
          if (func) {
            if (func.returnType.startsWith("f")) return "f64"
            if (func.returnType === "ptr") return "string"
          }
        }
        return "i64"
      }
      default:
        return "i64"
    }
  }

  private generateTemplateLiteral(ir: string[], expr: any): string {
    const parts = expr.parts as (string | any)[]
    if (parts.length === 0) {
      // Empty string
      const name = this.generateStringLiteral(ir, "")
      const ptrReg = `%${this.valueCounter++}`
      ir.push(`  ${ptrReg} = getelementptr [1 x i8], ptr ${name}, i64 0, i64 0`)
      return ptrReg
    }

    // Collect all string parts into registers
    const partRegs: string[] = []
    for (const part of parts) {
      if (typeof part === "string") {
        // String literal part
        const name = this.generateStringLiteral(ir, part)
        const ptrReg = `%${this.valueCounter++}`
        ir.push(`  ${ptrReg} = getelementptr [${part.length + 1} x i8], ptr ${name}, i64 0, i64 0`)
        partRegs.push(ptrReg)
      } else {
        // Expression part - generate it and convert to string
        const exprReg = this.generateExpression(ir, part)
        const exprType = this.inferExpressionType(part)

        // Convert non-string expressions to strings
        if (exprType === "string") {
          partRegs.push(exprReg)
        } else if (exprType === "f64" || exprType === "f32" || exprType === "f16" || exprType === "f128") {
          // Float to string
          const convertReg = `%${this.valueCounter++}`
          ir.push(`  ${convertReg} = call ptr @f64_to_string(double ${exprReg})`)
          partRegs.push(convertReg)
        } else if (exprType.startsWith("u")) {
          // Unsigned to string
          const convertReg = `%${this.valueCounter++}`
          ir.push(`  ${convertReg} = call ptr @u64_to_string(i64 ${exprReg})`)
          partRegs.push(convertReg)
        } else {
          // Signed integer to string
          const convertReg = `%${this.valueCounter++}`
          ir.push(`  ${convertReg} = call ptr @i64_to_string(i64 ${exprReg})`)
          partRegs.push(convertReg)
        }
      }
    }

    // Concatenate all parts using string_concat
    let result = partRegs[0]
    for (let i = 1; i < partRegs.length; i++) {
      const concatResult = `%${this.valueCounter++}`
      ir.push(`  ${concatResult} = call ptr @string_concat(ptr ${result}, ptr ${partRegs[i]})`)
      result = concatResult
    }

    return result
  }

  private generateBinaryExpression(ir: string[], expr: any): string {
    const left = this.generateExpression(ir, expr.left)
    const right = this.generateExpression(ir, expr.right)
    const reg = `%${this.valueCounter++}`

    // Handle logical operators specially - they work on i1 but we store as i64
    if (expr.operator === "&&" || expr.operator === "||") {
      // Convert operands to i1 (compare with 0), do logical op, then extend to i64
      const leftBool = `%${this.valueCounter++}`
      const rightBool = `%${this.valueCounter++}`
      ir.push(`  ${leftBool} = icmp ne i64 ${left}, 0`)
      ir.push(`  ${rightBool} = icmp ne i64 ${right}, 0`)
      const boolReg = `%${this.valueCounter++}`
      const logicOp = expr.operator === "&&" ? "and" : "or"
      ir.push(`  ${boolReg} = ${logicOp} i1 ${leftBool}, ${rightBool}`)
      const extReg = `%${this.valueCounter++}`
      ir.push(`  ${extReg} = zext i1 ${boolReg} to i64`)
      return extReg
    }

    // Check for matrix operations - both operands are 2D arrays
    if (this.isMatrixOperation(expr.left, expr.right)) {
      if (expr.operator === "*") {
        return this.generateMatrixMultiplication(ir, left, right)
      } else if (expr.operator === "+") {
        return this.generateMatrixAddition(ir, left, right)
      }
    }

    // Check for vector operations - at least one operand is an array
    if (this.isVectorOperation(expr.left, expr.right)) {
      return this.generateVectorOperation(ir, expr, left, right)
    }

    // Handle pointer arithmetic: ptr + offset or ptr - offset
    if (this.isPointerArithmetic(expr, left, right)) {
      return this.generatePointerArithmetic(ir, expr, left, right)
    }

    const opMap: Record<string, string[]> = {
      "+": ["add i64", "fadd"],
      "-": ["sub i64", "fsub"],
      "*": ["mul i64", "fmul"],
      "/": ["sdiv i64", "fdiv"],
      "%": ["srem i64", "frem"],
      "|": ["or i64", "or"],
      "&": ["and i64", "and"],
      "^": ["xor i64", "xor"],
      "<<": ["shl i64", "shl"],
      ">>": ["ashr i64", "ashr"],
    }

    // Comparison operators return i1, need to extend to i64
    const cmpMap: Record<string, string[]> = {
      "<": ["icmp slt i64", "fcmp olt"],
      ">": ["icmp sgt i64", "fcmp ogt"],
      "<=": ["icmp sle i64", "fcmp ole"],
      ">=": ["icmp sge i64", "fcmp oge"],
      "=": ["icmp eq i64", "fcmp oeq"],
      "==": ["icmp eq i64", "fcmp oeq"],
      "!=": ["icmp ne i64", "fcmp one"],
    }

    // Determine if operation is float-based by checking operand types
    const isFloat = this.isFloatOperand(expr.left) || this.isFloatOperand(expr.right)

    if (cmpMap[expr.operator]) {
      const [intOp, floatOp] = cmpMap[expr.operator]
      const floatType = isFloat ? this.getFloatTypeSize(expr) : "float"
      const cmpOp = isFloat ? `${floatOp} ${floatType} ${left}, ${right}` : `${intOp} ${left}, ${right}`
      const boolReg = `%${this.valueCounter++}`
      ir.push(`  ${boolReg} = ${cmpOp}`)
      const extReg = `%${this.valueCounter++}`
      ir.push(`  ${extReg} = zext i1 ${boolReg} to i64`)
      return extReg
    }

    const [intOp, floatOp] = opMap[expr.operator]
    if (isFloat) {
      const floatType = this.getFloatTypeSize(expr)
      ir.push(`  ${reg} = ${floatOp} ${floatType} ${left}, ${right}`)
    } else {
      ir.push(`  ${reg} = ${intOp} ${left}, ${right}`)
    }

    return reg
  }

  private isVectorOperation(leftExpr: any, rightExpr: any): boolean {
    // Check if at least one operand is an array type
    const leftArrayType = this.getExpressionArrayType(leftExpr)
    const rightArrayType = this.getExpressionArrayType(rightExpr)
    return leftArrayType !== null || rightArrayType !== null
  }

  private getExpressionArrayType(expr: any): any {
    if (!expr) return null

    // Check if the expression is an identifier with array type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "ArrayType") {
        return varType
      }
    }

    // Check if the expression itself has a resultType
    if (expr.resultType?.type === "ArrayType") {
      return expr.resultType
    }

    return null
  }

  private generateVectorOperation(ir: string[], expr: any, leftReg: string, rightReg: string): string {
    // Get element types for both operands
    const leftArrayType = this.getExpressionArrayType(expr.left)
    const rightArrayType = this.getExpressionArrayType(expr.right)

    // Determine which operand is the array and which is the scalar
    const isLeftArray = leftArrayType !== null
    const isRightArray = rightArrayType !== null

    if (!isLeftArray && !isRightArray) {
      throw new Error("Invalid vector operation: at least one operand must be an array")
    }

    // Use the array's element type
    const elementType = (leftArrayType || rightArrayType).elementType
    const isFloat = elementType?.type === "FloatType"
    const floatKind = isFloat ? elementType.kind : null

    // Get array length from the array operand
    const arrayReg = isLeftArray ? leftReg : rightReg
    const lenReg = `%${this.valueCounter++}`
    ir.push(`  ${lenReg} = call i64 @array_length(ptr ${arrayReg})`)

    // Allocate result array
    const dimensionsReg = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsReg} = alloca [1 x i64]`)
    const dimensionsPtr = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsPtr} = getelementptr [1 x i64], ptr ${dimensionsReg}, i64 0, i64 0`)
    ir.push(`  store i64 ${lenReg}, ptr ${dimensionsPtr}`)

    const elementSize = floatKind === "f64" ? 8 : floatKind === "f32" ? 4 : 8
    const resultReg = `%${this.valueCounter++}`
    ir.push(`  ${resultReg} = call ptr @array_alloc(i64 ${elementSize}, i64 1, ptr ${dimensionsReg})`)

    // Generate loop
    const loopStartLabel = `vec_loop_start_${this.labelCounter++}`
    const loopBodyLabel = `vec_loop_body_${this.labelCounter++}`
    const loopEndLabel = `vec_loop_end_${this.labelCounter++}`

    // Loop counter
    const counterReg = `%${this.valueCounter++}`
    ir.push(`  ${counterReg} = alloca i64`)
    ir.push(`  store i64 0, ptr ${counterReg}`)

    // Jump to loop start
    ir.push(`  br label %${loopStartLabel}`)

    // Loop start: check condition
    ir.push(`${loopStartLabel}:`)
    const currentCount = `%${this.valueCounter++}`
    ir.push(`  ${currentCount} = load i64, ptr ${counterReg}`)
    const cmpReg = `%${this.valueCounter++}`
    ir.push(`  ${cmpReg} = icmp slt i64 ${currentCount}, ${lenReg}`)
    ir.push(`  br i1 ${cmpReg}, label %${loopBodyLabel}, label %${loopEndLabel}`)

    // Loop body
    ir.push(`${loopBodyLabel}:`)

    // Get elements - one from array, one may be scalar
    let elem1Reg: string, elem2Reg: string

    if (floatKind === "f32") {
      if (isLeftArray) {
        elem1Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem1Reg} = call float @array_get_f32(ptr ${leftReg}, i64 ${currentCount})`)
      } else {
        // Left is scalar - bitcast i64 to float (IEEE 754 representation)
        const tempReg = `%${this.valueCounter++}`
        ir.push(`  ${tempReg} = trunc i64 ${leftReg} to i32`)
        elem1Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem1Reg} = bitcast i32 ${tempReg} to float`)
      }
      if (isRightArray) {
        elem2Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem2Reg} = call float @array_get_f32(ptr ${rightReg}, i64 ${currentCount})`)
      } else {
        // Right is scalar - bitcast i64 to float (IEEE 754 representation)
        const tempReg = `%${this.valueCounter++}`
        ir.push(`  ${tempReg} = trunc i64 ${rightReg} to i32`)
        elem2Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem2Reg} = bitcast i32 ${tempReg} to float`)
      }
    } else if (floatKind === "f64") {
      if (isLeftArray) {
        elem1Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem1Reg} = call double @array_get_f64(ptr ${leftReg}, i64 ${currentCount})`)
      } else {
        // Left is scalar - convert i64 bit pattern to double
        // Store the i64 bit pattern to memory, then load as double
        const tempPtr = `%${this.valueCounter++}`
        ir.push(`  ${tempPtr} = alloca i64`)
        ir.push(`  store i64 ${leftReg}, ptr ${tempPtr}`)
        const doublePtr = `%${this.valueCounter++}`
        ir.push(`  ${doublePtr} = bitcast ptr ${tempPtr} to ptr`)
        elem1Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem1Reg} = load double, ptr ${doublePtr}`)
      }
      if (isRightArray) {
        elem2Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem2Reg} = call double @array_get_f64(ptr ${rightReg}, i64 ${currentCount})`)
      } else {
        // Right is scalar - convert i64 bit pattern to double
        const tempPtr = `%${this.valueCounter++}`
        ir.push(`  ${tempPtr} = alloca i64`)
        ir.push(`  store i64 ${rightReg}, ptr ${tempPtr}`)
        const doublePtr = `%${this.valueCounter++}`
        ir.push(`  ${doublePtr} = bitcast ptr ${tempPtr} to ptr`)
        elem2Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem2Reg} = load double, ptr ${doublePtr}`)
      }
    } else {
      if (isLeftArray) {
        const e1 = `%${this.valueCounter++}`
        ir.push(`  ${e1} = call i64 @array_get(ptr ${leftReg}, i64 ${currentCount})`)
        elem1Reg = e1
      } else {
        elem1Reg = leftReg
      }
      if (isRightArray) {
        const e2 = `%${this.valueCounter++}`
        ir.push(`  ${e2} = call i64 @array_get(ptr ${rightReg}, i64 ${currentCount})`)
        elem2Reg = e2
      } else {
        elem2Reg = rightReg
      }
    }

    // Apply operation
    const resultElemReg = `%${this.valueCounter++}`
    const op = expr.operator

    if (floatKind === "f32") {
      const opMap: Record<string, string> = { "+": "fadd", "-": "fsub", "*": "fmul", "/": "fdiv" }
      const floatOp = opMap[op] || "fadd"
      ir.push(`  ${resultElemReg} = ${floatOp} float ${elem1Reg}, ${elem2Reg}`)
    } else if (floatKind === "f64") {
      const opMap: Record<string, string> = { "+": "fadd", "-": "fsub", "*": "fmul", "/": "fdiv" }
      const floatOp = opMap[op] || "fadd"
      ir.push(`  ${resultElemReg} = ${floatOp} double ${elem1Reg}, ${elem2Reg}`)
    } else {
      const opMap: Record<string, string> = { "+": "add i64", "-": "sub i64", "*": "mul i64", "/": "sdiv i64" }
      const intOp = opMap[op] || "add i64"
      ir.push(`  ${resultElemReg} = ${intOp} ${elem1Reg}, ${elem2Reg}`)
    }

    // Store result
    if (floatKind === "f32") {
      ir.push(`  call void @array_set_f32(ptr ${resultReg}, i64 ${currentCount}, float ${resultElemReg})`)
    } else if (floatKind === "f64") {
      ir.push(`  call void @array_set_f64(ptr ${resultReg}, i64 ${currentCount}, double ${resultElemReg})`)
    } else {
      ir.push(`  call void @array_set(ptr ${resultReg}, i64 ${currentCount}, i64 ${resultElemReg})`)
    }

    // Increment counter
    const nextCount = `%${this.valueCounter++}`
    ir.push(`  ${nextCount} = add i64 ${currentCount}, 1`)
    ir.push(`  store i64 ${nextCount}, ptr ${counterReg}`)

    // Jump back to start
    ir.push(`  br label %${loopStartLabel}`)

    // Loop end
    ir.push(`${loopEndLabel}:`)

    return resultReg
  }

  private isMatrixOperation(leftExpr: any, rightExpr: any): boolean {
    // Check if BOTH operands are 2D arrays (matrices)
    const leftArrayType = this.getExpressionArrayType(leftExpr)
    const rightArrayType = this.getExpressionArrayType(rightExpr)

    if (!leftArrayType || !rightArrayType) return false

    // Check if both are 2D (have 2 dimensions)
    const leftDims = leftExpr?.type === "Identifier" && leftExpr?.name
      ? this.variableTypes.get(leftExpr.name)?.dimensions?.length || leftArrayType.dimensions?.length
      : leftArrayType.dimensions?.length
    const rightDims = rightExpr?.type === "Identifier" && rightExpr?.name
      ? this.variableTypes.get(rightExpr.name)?.dimensions?.length || rightArrayType.dimensions?.length
      : rightArrayType.dimensions?.length

    // Treat as matrix if both have 2 dimensions
    return leftDims === 2 && rightDims === 2
  }

  private generateMatrixMultiplication(ir: string[], leftReg: string, rightReg: string): string {
    const resultReg = `%${this.valueCounter++}`
    ir.push(`  ${resultReg} = call ptr @matmul(ptr ${leftReg}, ptr ${rightReg})`)
    return resultReg
  }

  private generateMatrixAddition(ir: string[], leftReg: string, rightReg: string): string {
    const resultReg = `%${this.valueCounter++}`
    ir.push(`  ${resultReg} = call ptr @matrix_add(ptr ${leftReg}, ptr ${rightReg})`)
    return resultReg
  }

  private generateUnaryExpression(ir: string[], expr: any): string {
    const argument = expr.argument || expr.operand
    const value = this.generateExpression(ir, argument)
    const reg = `%${this.valueCounter++}`

    if (expr.operator === "-") {
      ir.push(`  ${reg} = sub i64 0, ${value}`)
    } else if (expr.operator === "!") {
      ir.push(`  ${reg} = xor i64 ${value}, 1`)
    } else if (expr.operator === "~") {
      ir.push(`  ${reg} = xor i64 ${value}, -1`)
    }

    return reg
  }

  private generateCallExpression(ir: string[], expr: any): string {
    let positionalArgs = expr.args || expr.arguments || []
    const namedArgs: { name: string; value: any }[] = expr.namedArgs || []

    // If there are named args or default params, resolve the full argument list
    if (expr.callee.type === "Identifier") {
      const funcName = expr.callee.name
      const paramInfo = this.functionParamInfo.get(funcName)
      if (paramInfo && (namedArgs.length > 0 || paramInfo.some((p: any) => p.defaultValue))) {
        // Build the full resolved argument list
        const resolvedArgs: any[] = []
        for (let i = 0; i < paramInfo.length; i++) {
          const param = paramInfo[i]
          // Check if this param is covered by a positional arg
          if (i < positionalArgs.length) {
            resolvedArgs.push(positionalArgs[i])
          } else {
            // Check if it's in named args
            const namedArg = namedArgs.find((na: any) => na.name === param.name)
            if (namedArg) {
              resolvedArgs.push(namedArg.value)
            } else if (param.defaultValue) {
              // Use the default value expression
              resolvedArgs.push(param.defaultValue)
            }
            // If no value, skip (will be handled by LLVM with 0/default)
          }
        }
        positionalArgs = resolvedArgs
      }
    }

    const args = positionalArgs.map((arg: ExpressionNode) => this.generateExpression(ir, arg)).filter(Boolean)

    if (expr.callee.type === "Identifier") {
      const funcName = expr.callee.name

      // Handle print functions
      const printFunctions = ["print", "print_i64", "print_u64", "print_f64", "print_string", "print_buffer",
                              "println", "println_i64", "println_u64", "println_f64", "println_string"]
      if (printFunctions.includes(funcName)) {
        return this.generatePrintCall(ir, funcName, args, expr)
      }

      // Handle input functions
      const inputFunctions = ["input_i64", "input_u64", "input_f64", "input_string"]
      if (inputFunctions.includes(funcName)) {
        return this.generateInputCall(ir, funcName)
      }

      // Handle socket syscall wrappers
      const socketFunctions = ["sys_socket", "sys_connect", "sys_send", "sys_recv", 
                               "sys_close", "sys_fcntl", "sys_inet_addr", "sys_errno"]
      if (socketFunctions.includes(funcName)) {
        return this.generateSocketCall(ir, funcName, args)
      }

      // Handle dot product function
      if (funcName === "dot") {
        return this.generateDotCall(ir, expr, args)
      }

      // Handle matmul function
      if (funcName === "matmul") {
        return this.generateMatmulCall(ir, expr, args)
      }

      // Handle GC benchmark functions
      const gcBenchmarkFunctions = ["gc_reset_stats", "gc_benchmark_stats"]
      if (gcBenchmarkFunctions.includes(funcName)) {
        ir.push(`  call void @${funcName}()`)
        return "0"
      }

      const funcInfo = this.functions.get(funcName)

      // POSIX function signatures for proper argument typing
      const posixSignatures: Record<string, string[]> = {
        open: ["ptr", "i64"],  // variadic: may have mode
        read: ["i64", "ptr", "i64"],
        write: ["i64", "ptr", "i64"],
        pread: ["i64", "ptr", "i64", "i64"],
        pwrite: ["i64", "ptr", "i64", "i64"],
        lseek: ["i64", "i64", "i64"],
        close: ["i64"],
        fsync: ["i64"],
        fdatasync: ["i64"],
        stat: ["ptr", "ptr"],
        lstat: ["ptr", "ptr"],
        fstat: ["i64", "ptr"],
        access: ["ptr", "i64"],
        faccessat: ["i64", "ptr", "i64", "i64"],
        utimes: ["ptr", "ptr"],
        futimes: ["i64", "ptr"],
        utimensat: ["i64", "ptr", "ptr", "i64"],
        chmod: ["ptr", "i64"],
        fchmod: ["i64", "i64"],
        chown: ["ptr", "i64", "i64"],
        fchown: ["i64", "i64", "i64"],
        umask: ["i64"],
        truncate: ["ptr", "i64"],
        ftruncate: ["i64", "i64"],
        link: ["ptr", "ptr"],
        symlink: ["ptr", "ptr"],
        readlink: ["ptr", "ptr", "i64"],
        rename: ["ptr", "ptr"],
        unlink: ["ptr"],
        mkdir: ["ptr", "i64"],
        rmdir: ["ptr"],
        fcntl: ["i64", "i64"],  // variadic
        pathconf: ["ptr", "i64"],
        fpathconf: ["i64", "i64"],
        dup: ["i64"],
        dup2: ["i64", "i64"],
        creat: ["ptr", "i64"],
        mkfifo: ["ptr", "i64"],
        mknod: ["ptr", "i64", "i64"],  // variadic
        chdir: ["ptr"],
        fchdir: ["i64"],
        getcwd: ["ptr", "i64"],
        opendir: ["ptr"],
        readdir: ["ptr"],
        closedir: ["ptr"],
        rewinddir: ["ptr"],
      }

      const runtimeSignatures: Record<string, { params: string[]; ret: string }> = {
        map_new: { params: ["i64"], ret: "ptr" },
        map_get: { params: ["ptr", "ptr", "i64"], ret: "i64" },
        map_set: { params: ["ptr", "ptr", "i64", "i64"], ret: "void" },
        string_length: { params: ["ptr"], ret: "i64" },
        string_concat: { params: ["ptr", "ptr"], ret: "ptr" },
        gc_alloc: { params: ["i64"], ret: "ptr" },
      }

      const sig = posixSignatures[funcName]
      const isVariadic = ["open", "fcntl", "mknod"].includes(funcName)

      // POSIX functions that return ptr instead of i64
      const posixReturnTypes: Record<string, string> = {
        opendir: "ptr",
        readdir: "ptr",
      }

      let typedArgs: string[]
      if (funcInfo && funcInfo.params) {
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = funcInfo.params[i]?.type || "i64"
          return `${paramType} ${arg}`
        })
      } else if (sig) {
        // Use POSIX signature for typing
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = sig[i] || "i64"
          return `${paramType} ${arg}`
        })
      } else if (runtimeSignatures[funcName]) {
        const sig = runtimeSignatures[funcName]
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = sig.params[i] || "i64"
          return `${paramType} ${arg}`
        })
        const returnType = sig.ret
        const reg = returnType === "void" ? null : `%${this.valueCounter++}`
        if (reg) {
          ir.push(`  ${reg} = call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
        } else {
          ir.push(`  call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
        }
        return reg || ""
      } else if (isVariadic) {
        // For variadic functions without sig, type first 2 args, rest as i64
        typedArgs = args.map((arg: string, i: number) => {
          if (i === 0) return `ptr ${arg}`
          return `i64 ${arg}`
        })
      } else {
        typedArgs = args
      }

      const reg = `%${this.valueCounter++}`
      const returnType = funcInfo?.returnType || posixReturnTypes[funcName] || "i64"
      ir.push(`  ${reg} = call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
      return reg
    }

    // Handle capability function calls (MemberExpression like fs.read(...))
    if (expr.callee.type === "MemberExpression") {
      const memberExpr = expr.callee
      if (memberExpr.object.type === "Identifier" && this.capabilities.has(memberExpr.object.name)) {
        return this.generateCapabilityCall(ir, memberExpr.object.name, memberExpr.property, args, expr)
      }
    }

    // Handle indirect function call (calling a function pointer stored in a variable)
    if (expr.callee.type === "Identifier") {
      const funcPtrName = expr.callee.name
      // Load the function pointer from the variable
      const ptrReg = `%${this.valueCounter++}`
      ir.push(`  ${ptrReg} = load ptr, ptr %${funcPtrName}`)
      
      // Build typed args - default to i64 for each arg
      const typedArgs = args.map((arg: string) => `i64 ${arg}`)
      
      // Indirect call through function pointer
      const resultReg = `%${this.valueCounter++}`
      ir.push(`  ${resultReg} = call i64 ${ptrReg}(${typedArgs.join(", ")})`)
      return resultReg
    }

    return ""
  }

  private generateCapabilityCall(ir: string[], capName: string, funcName: string, args: string[], expr: any): string {
    // Create capability name string on stack
    const capStrAlloca = `%${this.valueCounter++}`
    ir.push(`  ${capStrAlloca} = alloca [${capName.length + 1} x i8]`)
    ir.push(`  store [${capName.length + 1} x i8] c"${capName}\\00", ptr ${capStrAlloca}`)

    // Create function name string on stack
    const funcStrAlloca = `%${this.valueCounter++}`
    ir.push(`  ${funcStrAlloca} = alloca [${funcName.length + 1} x i8]`)
    ir.push(`  store [${funcName.length + 1} x i8] c"${funcName}\\00", ptr ${funcStrAlloca}`)

    const nargs = args.length
    if (nargs > 0) {
      // Allocate MogValue array for arguments
      const argsArrayReg = `%${this.valueCounter++}`
      ir.push(`  ${argsArrayReg} = alloca %MogValue, i32 ${nargs}`)

      // Initialize each MogValue argument
      const argExprs = expr.args || expr.arguments || []
      for (let i = 0; i < nargs; i++) {
        const argExpr = argExprs[i]
        const argVal = args[i]

        // Determine tag from the expression type
        const isFloat = this.isFloatOperand(argExpr)
        const isString = argExpr && (argExpr.type === "StringLiteral" || argExpr.type === "TemplateLiteral")

        const gepTag = `%${this.valueCounter++}`
        ir.push(`  ${gepTag} = getelementptr %MogValue, ptr ${argsArrayReg}, i32 ${i}, i32 0`)

        const gepData = `%${this.valueCounter++}`
        ir.push(`  ${gepData} = getelementptr %MogValue, ptr ${argsArrayReg}, i32 ${i}, i32 1`)

        if (isString) {
          // MOG_STRING = 3
          ir.push(`  store i32 3, ptr ${gepTag}`)
          const ptrToInt = `%${this.valueCounter++}`
          ir.push(`  ${ptrToInt} = ptrtoint ptr ${argVal} to i64`)
          ir.push(`  store i64 ${ptrToInt}, ptr ${gepData}`)
        } else if (isFloat) {
          // MOG_FLOAT = 1
          ir.push(`  store i32 1, ptr ${gepTag}`)
          const bitcast = `%${this.valueCounter++}`
          ir.push(`  ${bitcast} = bitcast double ${argVal} to i64`)
          ir.push(`  store i64 ${bitcast}, ptr ${gepData}`)
        } else {
          // MOG_INT = 0 (default for integers)
          ir.push(`  store i32 0, ptr ${gepTag}`)
          ir.push(`  store i64 ${argVal}, ptr ${gepData}`)
        }
      }

      // Call mog_cap_call(vm_ptr, cap_name, func_name, args, nargs)
      // Pass null for vm_ptr - the host sets up a global VM pointer
      const resultReg = `%${this.valueCounter++}`
      ir.push(`  ${resultReg} = call %MogValue @mog_cap_call(ptr null, ptr ${capStrAlloca}, ptr ${funcStrAlloca}, ptr ${argsArrayReg}, i32 ${nargs})`)

      // Extract the data field (i64) from the returned MogValue aggregate
      const extractReg = `%${this.valueCounter++}`
      ir.push(`  ${extractReg} = extractvalue %MogValue ${resultReg}, 1`)

      return extractReg
    } else {
      // No arguments - call with null args
      const resultReg = `%${this.valueCounter++}`
      ir.push(`  ${resultReg} = call %MogValue @mog_cap_call(ptr null, ptr ${capStrAlloca}, ptr ${funcStrAlloca}, ptr null, i32 0)`)

      const extractReg = `%${this.valueCounter++}`
      ir.push(`  ${extractReg} = extractvalue %MogValue ${resultReg}, 1`)

      return extractReg
    }
  }

  private generateCapabilityDeclarations(ir: string[]): void {
    ir.push("")
    ir.push("; Host FFI declarations")
    ir.push("%MogValue = type { i32, i64 }")
    ir.push("declare %MogValue @mog_cap_call(ptr, ptr, ptr, ptr, i32)")
    ir.push("")
    this.capCallDeclared = true
  }

  private generateInputCall(ir: string[], funcName: string): string {
    const reg = `%${this.valueCounter++}`

    switch (funcName) {
      case "input_i64":
      case "input_u64":
        ir.push(`  ${reg} = call i64 @${funcName}()`)
        return reg
      case "input_f64":
        ir.push(`  ${reg} = call double @${funcName}()`)
        return reg
      case "input_string":
        ir.push(`  ${reg} = call ptr @${funcName}()`)
        return reg
      default:
        return ""
    }
  }

  private generateSocketCall(ir: string[], funcName: string, args: string[]): string {
    // Helper to convert i64 to i32
    const toI32 = (reg: string): string => {
      const truncReg = `%${this.valueCounter++}`
      ir.push(`  ${truncReg} = trunc i64 ${reg} to i32`)
      return truncReg
    }
    
    // Allocate resultReg AFTER all truncs to maintain sequential numbering
    const allocateResult = (): string => `%${this.valueCounter++}`
    
    switch (funcName) {
      case "sys_socket": {
        const a0 = toI32(args[0])
        const a1 = toI32(args[1])
        const a2 = toI32(args[2])
        const resultReg = allocateResult()
        ir.push(`  ${resultReg} = call i64 @sys_socket(i32 ${a0}, i32 ${a1}, i32 ${a2})`)
        return resultReg
      }
      case "sys_connect": {
        const a1 = toI32(args[1])
        const a2 = `%${this.valueCounter++}`
        ir.push(`  ${a2} = trunc i64 ${args[2]} to i16`)
        const resultReg = allocateResult()
        ir.push(`  ${resultReg} = call i64 @sys_connect(i64 ${args[0]}, i32 ${a1}, i16 ${a2})`)
        return resultReg
      }
      case "sys_send":
      case "sys_recv":
      case "sys_close":
      case "sys_errno": {
        const resultReg = allocateResult()
        switch (funcName) {
          case "sys_send":
            ir.push(`  ${resultReg} = call i64 @sys_send(i64 ${args[0]}, ptr ${args[1]}, i64 ${args[2]}, i32 0)`)
            break
          case "sys_recv":
            ir.push(`  ${resultReg} = call i64 @sys_recv(i64 ${args[0]}, ptr ${args[1]}, i64 ${args[2]}, i32 0)`)
            break
          case "sys_close":
            ir.push(`  ${resultReg} = call i64 @sys_close(i64 ${args[0]})`)
            break
          case "sys_errno":
            ir.push(`  ${resultReg} = call i64 @sys_errno()`)
            break
        }
        return resultReg
      }
      case "sys_inet_addr": {
        const inetResult = `%${this.valueCounter++}`
        ir.push(`  ${inetResult} = call i32 @sys_inet_addr(ptr ${args[0]})`)
        const zextReg = allocateResult()
        ir.push(`  ${zextReg} = zext i32 ${inetResult} to i64`)
        return zextReg
      }
      default:
        return "0"
    }
  }

  private generateDotCall(ir: string[], expr: any, args: string[]): string {
    // Get the argument nodes to determine element type
    const arg0 = expr.args?.[0] || expr.arguments?.[0]

    // Determine element type from first argument
    let elementType = "f64" // default
    const argType = arg0?.resultType
    if (argType?.elementType?.type === "FloatType" && argType?.elementType?.precision === 32) {
      elementType = "f32"
    }

    const reg = `%${this.valueCounter++}`
    if (elementType === "f32") {
      ir.push(`  ${reg} = call float @dot_f32(ptr ${args[0]}, ptr ${args[1]})`)
    } else {
      ir.push(`  ${reg} = call double @dot_f64(ptr ${args[0]}, ptr ${args[1]})`)
    }
    return reg
  }

  private generateMatmulCall(ir: string[], expr: any, args: string[]): string {
    // matmul takes two arrays and returns a new array (result of matrix multiplication)
    // Both arguments should be arrays
    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call ptr @matmul(ptr ${args[0]}, ptr ${args[1]})`)
    return reg
  }

  private generatePrintCall(ir: string[], funcName: string, args: string[], expr: any): string {
    // Handle println with no arguments (just newline)
    if (funcName === "println" && args.length === 0) {
      ir.push(`  call void @println()`)
      return ""
    }

    // Handle print_buffer specially (takes ptr and i64)
    if (funcName === "print_buffer") {
      if (args.length >= 2) {
        ir.push(`  call void @print_buffer(ptr ${args[0]}, i64 ${args[1]})`)
      }
      return ""
    }

    if (args.length === 0) {
      return ""
    }

    // Determine the actual function to call based on argument type
    const arg = expr.args?.[0] || expr.arguments?.[0]
    let actualFunc = funcName

    // Determine argument type - try resultType first, then check function calls, then variableTypes
    let argType = arg?.resultType?.type
    if (!argType && arg?.type === "Identifier") {
      const varType = this.variableTypes.get(arg.name)
      argType = varType?.type
    }
    if (!argType && arg?.type === "CallExpression" && arg?.callee?.type === "Identifier") {
      // Check if this is a call to a user-defined function and get its return type
      const funcName = arg.callee.name
      const funcType = this.functionTypes.get(funcName)
      if (funcType) {
        argType = funcType.type
      }
    }
    // String literals are arrays (strings)
    if (!argType && arg?.type === "StringLiteral") {
      argType = "ArrayType"
    }
    // Template literals are also strings
    if (!argType && arg?.type === "TemplateLiteral") {
      argType = "ArrayType"
    }
    // Pointer types (ptr) are also strings/pointer data
    if (!argType && arg?.type === "Identifier") {
      const varType = this.variableTypes.get(arg.name)
      if (varType?.type === "PointerType" || varType?.type === "ArrayType") {
        argType = "PointerType"
      }
    }
    // MemberExpression on a struct - look up the field type
    if (!argType && arg?.type === "MemberExpression" && arg?.object?.type === "Identifier") {
      const varType = this.variableTypes.get(arg.object.name)
      const structName = varType?.name || varType?.structName
      const structFields = structName ? this.structDefs.get(structName) : null
      if (structFields) {
        const fieldDef = structFields.find((f: any) => f.name === arg.property)
        if (fieldDef?.fieldType?.type) {
          argType = fieldDef.fieldType.type
        }
      }
    }
    argType = argType || "IntegerType"

    // If generic print/println, determine specific version based on type
    if (funcName === "print" || funcName === "println") {
      if (argType === "FloatType") {
        actualFunc = funcName === "print" ? "print_f64" : "println_f64"
      } else if (argType === "UnsignedType") {
        actualFunc = funcName === "print" ? "print_u64" : "println_u64"
      } else if (argType === "ArrayType" || argType === "PointerType") {
        actualFunc = funcName === "print" ? "print_string" : "println_string"
      } else {
        actualFunc = funcName === "print" ? "print_i64" : "println_i64"
      }
    }

    // Generate call with appropriate type
    if (argType === "FloatType") {
      ir.push(`  call void @${actualFunc}(double ${args[0]})`)
    } else if (argType === "ArrayType" || argType === "PointerType") {
      ir.push(`  call void @${actualFunc}(ptr ${args[0]})`)
    } else {
      ir.push(`  call void @${actualFunc}(i64 ${args[0]})`)
    }
    return ""
  }

  private generateAssignmentExpression(ir: string[], expr: any): string {
    const { name, target, value } = expr
    const valueReg = this.generateExpression(ir, value)
    
    if (target && target.type === "IndexExpression") {
      const obj = this.generateExpression(ir, target.object)
      const index = this.generateExpression(ir, target.index)

      // Check if this is a table assignment (table[key] = value)
      if (this.isMapType(target.object)) {
        // Table assignment: table[key] := value
        // The index is the key - could be string or integer
        const keyExpr = target.index
        let keyPtr: string
        let keyLen: string

        if (keyExpr.type === "StringLiteral") {
          // String key: use string literal directly
          const escaped = keyExpr.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
          keyPtr = `@key_str_${this.stringCounter++}`
          const strDef = `${keyPtr} = private unnamed_addr constant [${keyExpr.value.length + 1} x i8] c"${escaped}\\00"`
          this.stringConstants.push(strDef)
          keyLen = String(keyExpr.value.length)
        } else if (keyExpr.type === "Identifier") {
          // Variable key - assume it's a string, use strlen to get length
          const keyVar = this.generateExpression(ir, keyExpr)
          keyPtr = keyVar
          const lenReg = `%${this.valueCounter++}`
          ir.push(`  ${lenReg} = call i64 @string_length(ptr ${keyVar})`)
          keyLen = lenReg
        } else if (keyExpr.type === "IntegerLiteral" || keyExpr.type === "NumberLiteral") {
          // Integer key: store to memory and pass as ptr
          const keyVal = keyExpr.value !== undefined ? keyExpr.value : index
          keyPtr = `%${this.valueCounter++}`
          ir.push(`  ${keyPtr} = alloca i64`)
          ir.push(`  store i64 ${keyVal}, ptr ${keyPtr}`)
          keyLen = "8" // i64 is 8 bytes
        } else {
          // Expression key: evaluate and use as string
          keyPtr = index
          const lenReg = `%${this.valueCounter++}`
          ir.push(`  ${lenReg} = call i64 @string_length(ptr ${index})`)
          keyLen = lenReg
        }

        ir.push(`  call void @map_set(ptr ${obj}, ptr ${keyPtr}, i64 ${keyLen}, i64 ${valueReg})`)
      } else {
        // Check if this is a raw pointer (from gc_alloc) vs an array object
        const objVar = target.object?.type === "Identifier" ? this.variableTypes.get(target.object.name) : null
        const isRawPointer = objVar?.type === "PointerType"
        
        if (isRawPointer) {
          // Raw pointer access: use getelementptr + store directly
          // Handle nested array access (pointer arithmetic on raw ptr)
          const isNestedIndex = target.object?.type === "IndexExpression"
          let ptrReg = obj
          if (isNestedIndex) {
            const r = `%${this.valueCounter++}`
            ir.push(`  ${r} = inttoptr i64 ${obj} to ptr`)
            ptrReg = r
          }
          
          // Calculate element address: ptr + index
          const elemPtr = `%${this.valueCounter++}`
          ir.push(`  ${elemPtr} = getelementptr i8, ptr ${ptrReg}, i64 ${index}`)
          
          // Store the value
          ir.push(`  store i64 ${valueReg}, ptr ${elemPtr}`)
        } else {
          // Array assignment: array[index] := value
          // Handle nested array access
          const isNestedIndex = target.object?.type === "IndexExpression"
          let arrayPtr = obj
          if (isNestedIndex) {
            const r = `%${this.valueCounter++}`
            ir.push(`  ${r} = inttoptr i64 ${obj} to ptr`)
            arrayPtr = r
          }

          // Determine element type to use appropriate setter
          const elementType = this.getArrayElementType(target.object)

          // Emit bounds check elision hint in release mode for AoS/SoA operations
          if (this.shouldElideBoundsCheck()) {
            ir.push(`  ; BOUNDS_CHECK_ELIDED: release mode optimization`)
          }

          if (elementType?.type === "FloatType") {
            const isValueFloat = this.isFloatOperand(value) || valueReg.startsWith("0x")
            if (elementType.kind === "f32") {
              if (isValueFloat) {
                // Value is already a float - use directly
                ir.push(`  call void @array_set_f32(ptr ${arrayPtr}, i64 ${index}, float ${valueReg})`)
              } else {
                // Integer value needs conversion
                const floatReg = `%${this.valueCounter++}`
                ir.push(`  ${floatReg} = sitofp i64 ${valueReg} to float`)
                ir.push(`  call void @array_set_f32(ptr ${arrayPtr}, i64 ${index}, float ${floatReg})`)
              }
            } else if (elementType.kind === "f64") {
              if (isValueFloat) {
                // Value is already a double - use directly
                ir.push(`  call void @array_set_f64(ptr ${arrayPtr}, i64 ${index}, double ${valueReg})`)
              } else {
                // Integer value needs conversion
                const doubleReg = `%${this.valueCounter++}`
                ir.push(`  ${doubleReg} = sitofp i64 ${valueReg} to double`)
                ir.push(`  call void @array_set_f64(ptr ${arrayPtr}, i64 ${index}, double ${doubleReg})`)
              }
            } else {
              ir.push(`  call void @array_set(ptr ${arrayPtr}, i64 ${index}, i64 ${valueReg})`)
            }
          } else {
            ir.push(`  call void @array_set(ptr ${arrayPtr}, i64 ${index}, i64 ${valueReg})`)
          }
        }
      }
    } else if (target && target.type === "MemberExpression") {
      // Check if target object is a struct - use GEP-based assignment
      if (target.object?.type === "Identifier") {
        const varType = this.variableTypes.get(target.object.name)
        const structName = varType?.name || varType?.structName
        const structFields = structName ? this.structDefs.get(structName) : null

        if (structFields) {
          const fieldIndex = structFields.findIndex((f: any) => f.name === target.property)
          if (fieldIndex >= 0) {
            const fieldDef = structFields[fieldIndex]
            const isFloat = fieldDef.fieldType?.type === "FloatType"
            const isPtr = fieldDef.fieldType?.type === "PointerType" || fieldDef.fieldType?.kind === "ptr"
              || (typeof fieldDef.fieldType === "string" && fieldDef.fieldType === "ptr")
            const isArray = fieldDef.fieldType?.type === "ArrayType"
            // Load struct pointer
            // For function parameters, the param is stored in %name_local (see generateFunctionDeclaration)
            const isParam = this.currentFunction && this.currentFunction.params.find((p) => p.name === target.object.name)
            const structAssignSrc = isParam ? `%${target.object.name}_local` : `%${target.object.name}`
            const structPtr = `%${this.valueCounter++}`
            ir.push(`  ${structPtr} = load ptr, ptr ${structAssignSrc}`)
            // GEP to field
            const fieldPtr = `%${this.valueCounter++}`
            ir.push(`  ${fieldPtr} = getelementptr i8, ptr ${structPtr}, i64 ${fieldIndex * 8}`)
            // Store with correct type
            if (isFloat) {
              ir.push(`  store double ${valueReg}, ptr ${fieldPtr}`)
            } else if (isPtr || isArray) {
              ir.push(`  store ptr ${valueReg}, ptr ${fieldPtr}`)
            } else {
              ir.push(`  store i64 ${valueReg}, ptr ${fieldPtr}`)
            }
            return valueReg
          }
        }
      }

      // Fallback: Map member assignment (person.age := 31)
      const obj = this.generateExpression(ir, target.object)
      const keyName = `@key_${target.property}_${this.stringCounter++}`
      const escaped = target.property.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
      const strDef = `${keyName} = private unnamed_addr constant [${target.property.length + 1} x i8] c"${escaped}\\00"`
      this.stringConstants.push(strDef)
      ir.push(`  call void @map_set(ptr ${obj}, ptr ${keyName}, i64 ${target.property.length}, i64 ${valueReg})`)
    } else {
      let varType = this.variableTypes.get(name)
      // If variable doesn't exist yet (walrus-style new variable), allocate it
      if (!varType && name) {
        // Determine type from value - function pointer or general
        const isFuncPtr = valueReg.startsWith("@")
        const allocaType = isFuncPtr ? "ptr" : "i64"
        ir.push(`  %${name} = alloca ${allocaType}`)
        if (isFuncPtr) {
          // Track as a function type for later loads
          this.variableTypes.set(name, { type: "FunctionType" })
        }
        varType = this.variableTypes.get(name)
      }
      const llvmType = this.toLLVMType(varType)
      ir.push(`  store ${llvmType} ${valueReg}, ptr %${name}`)
    }
    
    return valueReg
  }

  private generateArrayLiteral(ir: string[], expr: any): string {
    const size = expr.elements.length || 0
    const dimensionsReg = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsReg} = alloca [1 x i64]`)
    const dimensionsPtr = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsPtr} = getelementptr [1 x i64], ptr ${dimensionsReg}, i64 0, i64 0`)
    ir.push(`  store i64 ${size}, ptr ${dimensionsPtr}`)

    // Determine element type from the array literal's resultType
    const elementType = expr.resultType?.elementType
    let elementSize = 8 // default to 8 bytes for i64
    if (elementType?.type === "FloatType") {
      elementSize = elementType.kind === "f64" ? 8 : 4
    }

    const elementReg = `%${this.valueCounter++}`
    ir.push(`  ${elementReg} = call ptr @array_alloc(i64 ${elementSize}, i64 1, ptr ${dimensionsReg})`)

    for (let i = 0; i < expr.elements.length; i++) {
      const elemExpr = expr.elements[i]
      if (elementType?.type === "FloatType") {
        // Handle float elements directly
        const val = String(elemExpr.value)
        const numVal = parseFloat(val)
        if (elementType.kind === "f32") {
          // Generate float constant as decimal - ensure it has a decimal point
          const floatLit = val.includes('.') ? val : val + '.0'
          ir.push(`  call void @array_set_f32(ptr ${elementReg}, i64 ${i}, float ${floatLit})`)
        } else if (elementType.kind === "f64") {
          // Generate double constant as decimal - ensure it has a decimal point
          const doubleLit = val.includes('.') ? val : val + '.0'
          ir.push(`  call void @array_set_f64(ptr ${elementReg}, i64 ${i}, double ${doubleLit})`)
        } else {
          const value = this.generateExpression(ir, elemExpr)
          ir.push(`  call void @array_set(ptr ${elementReg}, i64 ${i}, i64 ${value})`)
        }
      } else {
        const value = this.generateExpression(ir, elemExpr)
        if (value) {
          // Check if value is a pointer (nested array) and convert to i64
          const valueToStore = value.includes('ptr') || value.startsWith('%') && !value.includes('i64')
            ? (() => { const r = `%${this.valueCounter++}`; ir.push(`  ${r} = ptrtoint ptr ${value} to i64`); return r; })()
            : value
          ir.push(`  call void @array_set(ptr ${elementReg}, i64 ${i}, i64 ${valueToStore})`)
        }
      }
    }

    return elementReg
  }

  private generateArrayFill(ir: string[], expr: any): string {
    // Generate array filled with repeated value: [value; count]
    const countExpr = expr.count
    const valueExpr = expr.value

    // Get element type from resultType
    const elementType = expr.resultType?.elementType
    let elementSize = 8 // default to 8 bytes for i64
    if (elementType?.type === "FloatType") {
      elementSize = elementType.kind === "f64" ? 8 : 4
    }

    // Determine count - try to get compile-time constant
    let countValue: number | null = null
    if (countExpr.type === "NumberLiteral" || countExpr.type === "IntegerLiteral") {
      countValue = parseInt(countExpr.value)
    }

    // Allocate array with the specified count
    const countReg = `%${this.valueCounter++}`
    if (countValue !== null) {
      ir.push(`  ${countReg} = alloca [1 x i64]`)
      const countPtr = `%${this.valueCounter++}`
      ir.push(`  ${countPtr} = getelementptr [1 x i64], ptr ${countReg}, i64 0, i64 0`)
      ir.push(`  store i64 ${countValue}, ptr ${countPtr}`)
    } else {
      // Runtime count
      const runtimeCount = this.generateExpression(ir, countExpr)
      ir.push(`  ${countReg} = alloca [1 x i64]`)
      const countPtr = `%${this.valueCounter++}`
      ir.push(`  ${countPtr} = getelementptr [1 x i64], ptr ${countReg}, i64 0, i64 0`)
      ir.push(`  store i64 ${runtimeCount}, ptr ${countPtr}`)
    }

    const elementReg = `%${this.valueCounter++}`
    ir.push(`  ${elementReg} = call ptr @array_alloc(i64 ${elementSize}, i64 1, ptr ${countReg})`)

    // Fill the array with the value
    const value = this.generateExpression(ir, valueExpr)

    // Loop to fill array
    const loopStartLabel = this.nextLabel()
    const loopBodyLabel = this.nextLabel()
    const loopEndLabel = this.nextLabel()

    const iReg = `%${this.valueCounter++}`
    ir.push(`  ${iReg} = alloca i64`)
    ir.push(`  store i64 0, ptr ${iReg}`)

    ir.push(`${loopStartLabel}:`)
    const currentI = `%${this.valueCounter++}`
    ir.push(`  ${currentI} = load i64, ptr ${iReg}`)
    const cmpResult = `%${this.valueCounter++}`
    if (countValue !== null) {
      ir.push(`  ${cmpResult} = icmp slt i64 ${currentI}, i64 ${countValue}`)
    } else {
      const runtimeCount = this.generateExpression(ir, countExpr)
      ir.push(`  ${cmpResult} = icmp slt i64 ${currentI}, i64 ${runtimeCount}`)
    }
    ir.push(`  br i1 ${cmpResult}, label %${loopBodyLabel}, label %${loopEndLabel}`)

    ir.push(`${loopBodyLabel}:`)

    // Store value at current index
    if (elementType?.type === "FloatType") {
      if (elementType.kind === "f32") {
        ir.push(`  call void @array_set_f32(ptr ${elementReg}, i64 ${currentI}, float ${value})`)
      } else {
        ir.push(`  call void @array_set_f64(ptr ${elementReg}, i64 ${currentI}, double ${value})`)
      }
    } else {
      ir.push(`  call void @array_set(ptr ${elementReg}, i64 ${currentI}, i64 ${value})`)
    }

    // Increment counter
    const nextI = `%${this.valueCounter++}`
    ir.push(`  ${nextI} = add i64 ${currentI}, 1`)
    ir.push(`  store i64 ${nextI}, ptr ${iReg}`)
    ir.push(`  br label %${loopStartLabel}`)

    ir.push(`${loopEndLabel}:`)

    return elementReg
  }

  private generateMapLiteral(ir: string[], expr: any): string {
    const entries = expr.entries || expr.columns || []

    // Check if this is a SoA literal (map where values are arrays)
    if (entries.length > 0) {
      const firstValue = entries[0].value
      if (firstValue?.type === "ArrayLiteral") {
        // Generate as struct of array pointers via gc_alloc
        const numFields = entries.length
        const structSize = numFields * 8
        const structReg = `%${this.valueCounter++}`
        ir.push(`  ${structReg} = call ptr @gc_alloc(i64 ${structSize})`)

        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i]
          const arrayReg = this.generateExpression(ir, entry.value)
          const fieldPtr = `%${this.valueCounter++}`
          ir.push(`  ${fieldPtr} = getelementptr i64, ptr ${structReg}, i32 ${i}`)
          ir.push(`  store i64 ${arrayReg}, ptr ${fieldPtr}`)
        }
        return structReg
      }
    }

    // Regular map literal
    const tableReg = `%${this.valueCounter++}`
    const capacity = entries.length > 0 ? entries.length * 2 : 4
    ir.push(`  ${tableReg} = call ptr @table_new(i64 ${capacity})`)

    for (const entry of entries) {
      const key = entry.key || entry.name
      const value = entry.value || (entry.values && entry.values[0])
      if (!value) continue
      const valueReg = this.generateExpression(ir, value)
      const keyName = `@map_key_${this.stringCounter++}`
      const keyBytes = key.length + 1
      this.stringConstants.push(`${keyName} = private constant [${keyBytes} x i8] c"${key}\\00"`)
      ir.push(`  call void @table_set(ptr ${tableReg}, ptr ${keyName}, i64 ${key.length}, i64 ${valueReg})`)
    }

    return tableReg
  }

  private generateStructLiteral(ir: string[], expr: any): string {
    // Look up struct definition to get field order and types
    const structName = expr.structName || ""
    const structFields = this.structDefs.get(structName)

    if (!structFields || structFields.length === 0) {
      // Fallback: allocate based on literal fields, all i64
      const numFields = expr.fields?.length || 0
      const structReg = `%${this.valueCounter++}`
      ir.push(`  ${structReg} = call ptr @gc_alloc(i64 ${numFields * 8})`)
      for (let i = 0; i < numFields; i++) {
        const field = expr.fields[i]
        const valueReg = this.generateExpression(ir, field.value)
        if (valueReg) {
          const fieldPtr = `%${this.valueCounter++}`
          ir.push(`  ${fieldPtr} = getelementptr i8, ptr ${structReg}, i64 ${i * 8}`)
          ir.push(`  store i64 ${valueReg}, ptr ${fieldPtr}`)
        }
      }
      return structReg
    }

    // Allocate struct: each field is 8 bytes
    const structReg = `%${this.valueCounter++}`
    ir.push(`  ${structReg} = call ptr @gc_alloc(i64 ${structFields.length * 8})`)

    // Store each field at its offset
    for (const field of expr.fields) {
      const fieldIndex = structFields.findIndex((f: any) => f.name === field.name)
      if (fieldIndex < 0) continue

      const fieldDef = structFields[fieldIndex]
      const valueReg = this.generateExpression(ir, field.value)
      if (!valueReg) continue

      const fieldPtr = `%${this.valueCounter++}`
      ir.push(`  ${fieldPtr} = getelementptr i8, ptr ${structReg}, i64 ${fieldIndex * 8}`)

      // Determine store type based on field type
      const isFloat = fieldDef.fieldType?.type === "FloatType"
      const isPtr = fieldDef.fieldType?.type === "PointerType" || fieldDef.fieldType?.kind === "ptr"
        || (typeof fieldDef.fieldType === "string" && fieldDef.fieldType === "ptr")
      const isArray = fieldDef.fieldType?.type === "ArrayType"
      if (isFloat) {
        ir.push(`  store double ${valueReg}, ptr ${fieldPtr}`)
      } else if (isPtr || isArray) {
        ir.push(`  store ptr ${valueReg}, ptr ${fieldPtr}`)
      } else {
        ir.push(`  store i64 ${valueReg}, ptr ${fieldPtr}`)
      }
    }

    return structReg
  }

  private generateSoALiteral(ir: string[], expr: any): string {
    // SoA is represented as a map of field names to arrays
    const soaReg = `%${this.valueCounter++}`
    const capacity = expr.columns.length > 0 ? expr.columns.length * 2 : 4
    ir.push(`  ${soaReg} = call ptr @map_new(i64 ${capacity})`)

    for (const col of expr.columns) {
      const fieldName = col.name
      const values = col.values
      
      // Create array for this column
      const arrReg = `%${this.valueCounter++}`
      ir.push(`  ${arrReg} = call ptr @array_new(i64 ${values.length})`)
      
      // Add elements to array
      for (let i = 0; i < values.length; i++) {
        const elemReg = this.generateExpression(ir, values[i])
        if (elemReg) {
          ir.push(`  call void @array_push(ptr ${arrReg}, i64 ${elemReg})`)
        }
      }
      
      // Store array in SoA map
      const keyStr = this.generateStringLiteral(ir, fieldName)
      ir.push(`  call void @map_set(ptr ${soaReg}, ptr ${keyStr}, i64 ${fieldName.length}, i64 ptrtoint ptr ${arrReg} to i64)`)
    }

    return soaReg
  }

  private generateMemberExpression(ir: string[], expr: any): string {
    // Check if the object is a struct type - use GEP-based field access
    if (expr.object?.type === "Identifier") {
      const varType = this.variableTypes.get(expr.object.name)
      const structName = varType?.name || varType?.structName
      const structFields = structName ? this.structDefs.get(structName) : null

      if (structFields) {
        const fieldIndex = structFields.findIndex((f: any) => f.name === expr.property)
        if (fieldIndex >= 0) {
          const fieldDef = structFields[fieldIndex]
          const isFloat = fieldDef.fieldType?.type === "FloatType"
          const isPtr = fieldDef.fieldType?.type === "PointerType" || fieldDef.fieldType?.kind === "ptr"
            || (typeof fieldDef.fieldType === "string" && fieldDef.fieldType === "ptr")
          const isArray = fieldDef.fieldType?.type === "ArrayType"
          // Load the struct pointer
          // For function parameters, the param is stored in %name_local (see generateFunctionDeclaration)
          // For local variables, the alloca is %name
          const isParam = this.currentFunction && this.currentFunction.params.find((p) => p.name === expr.object.name)
          const structLoadSrc = isParam ? `%${expr.object.name}_local` : `%${expr.object.name}`
          const structPtr = `%${this.valueCounter++}`
          ir.push(`  ${structPtr} = load ptr, ptr ${structLoadSrc}`)
          // GEP to field offset
          const fieldPtr = `%${this.valueCounter++}`
          ir.push(`  ${fieldPtr} = getelementptr i8, ptr ${structPtr}, i64 ${fieldIndex * 8}`)
          // Load field value with correct type
          const reg = `%${this.valueCounter++}`
          if (isFloat) {
            ir.push(`  ${reg} = load double, ptr ${fieldPtr}`)
          } else if (isPtr || isArray) {
            ir.push(`  ${reg} = load ptr, ptr ${fieldPtr}`)
          } else {
            ir.push(`  ${reg} = load i64, ptr ${fieldPtr}`)
          }
          return reg
        }
      }
    }

    // Fallback: map-based member access
    const obj = this.generateExpression(ir, expr.object)
    const keyName = `@key_${expr.property}_${this.stringCounter++}`
    const escaped = expr.property.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
    const strDef = `${keyName} = private unnamed_addr constant [${expr.property.length + 1} x i8] c"${escaped}\\00"`
    this.stringConstants.push(strDef)
    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call i64 @map_get(ptr ${obj}, ptr ${keyName}, i64 ${expr.property.length})`)
    return reg
  }

  private generateIndexExpression(ir: string[], expr: any): string {
    const obj = this.generateExpression(ir, expr.object)
    const index = this.generateExpression(ir, expr.index)
    // Handle nested array access
    // If expr.object is an IndexExpression, array is an i64 (from array_get), convert to ptr
    // Otherwise, array is already a ptr (from alloca or variable load)
    const isNestedIndex = expr.object?.type === "IndexExpression"
    let arrayPtr = obj
    if (isNestedIndex) {
      const r = `%${this.valueCounter++}`
      ir.push(`  ${r} = inttoptr i64 ${obj} to ptr`)
      arrayPtr = r
    }

    // Check if this is a table access (table[key])
    if (this.isMapType(expr.object)) {
      // Table access: table[key] - key can be string or integer
      const keyExpr = expr.index
      let keyPtr: string
      let keyLen: string

      if (keyExpr.type === "StringLiteral") {
        // String key: use string literal directly
        const escaped = keyExpr.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
        keyPtr = `@key_str_${this.stringCounter++}`
        const strDef = `${keyPtr} = private unnamed_addr constant [${keyExpr.value.length + 1} x i8] c"${escaped}\\00"`
        this.stringConstants.push(strDef)
        keyLen = String(keyExpr.value.length)
      } else if (keyExpr.type === "IntegerLiteral" || keyExpr.type === "NumberLiteral") {
        // Integer key: store to memory and pass as ptr
        const keyVal = keyExpr.value !== undefined ? keyExpr.value : index
        keyPtr = `%${this.valueCounter++}`
        ir.push(`  ${keyPtr} = alloca i64`)
        ir.push(`  store i64 ${keyVal}, ptr ${keyPtr}`)
        keyLen = "8" // i64 is 8 bytes
      } else {
        // Variable or expression key - assume string
        keyPtr = index
        const lenReg = `%${this.valueCounter++}`
        ir.push(`  ${lenReg} = call i64 @string_length(ptr ${index})`)
        keyLen = lenReg
      }

      const reg = `%${this.valueCounter++}`
      ir.push(`  ${reg} = call i64 @map_get(ptr ${arrayPtr}, ptr ${keyPtr}, i64 ${keyLen})`)
      return reg
    }

    // Check if this is a raw pointer (from gc_alloc)
    const objVar = expr.object?.type === "Identifier" ? this.variableTypes.get(expr.object.name) : null
    if (objVar?.type === "PointerType") {
      // Raw pointer access: use getelementptr + load directly
      const isNestedIndex = expr.object?.type === "IndexExpression"
      let ptrReg = arrayPtr
      if (isNestedIndex) {
        const r = `%${this.valueCounter++}`
        ir.push(`  ${r} = inttoptr i64 ${obj} to ptr`)
        ptrReg = r
      }
      
      // Calculate element address: ptr + index
      const elemPtr = `%${this.valueCounter++}`
      ir.push(`  ${elemPtr} = getelementptr i8, ptr ${ptrReg}, i64 ${index}`)
      
      // Load the value
      const valReg = `%${this.valueCounter++}`
      ir.push(`  ${valReg} = load i64, ptr ${elemPtr}`)
      return valReg
    }

    // Determine element type to use appropriate getter
    const elementType = this.getArrayElementType(expr.object)
    const reg = `%${this.valueCounter++}`

    // Check if this is a string type [u8]
    if (this.isStringType(expr.object)) {
      // String indexing - returns a new single-char string
      const resultReg = `%${this.valueCounter++}`
      // Emit bounds check elision hint in release mode
      if (this.shouldElideBoundsCheck()) {
        ir.push(`  ; BOUNDS_CHECK_ELIDED: release mode optimization`)
      }
      ir.push(`  ${resultReg} = call ptr @string_char_at(ptr ${arrayPtr}, i64 ${index})`)
      return resultReg
    }

    // Emit bounds check elision hint in release mode for AoS/SoA operations
    if (this.shouldElideBoundsCheck()) {
      ir.push(`  ; BOUNDS_CHECK_ELIDED: release mode optimization`)
    }

    if (elementType?.type === "FloatType") {
      if (elementType.kind === "f32") {
        const floatReg = `%${this.valueCounter++}`
        ir.push(`  ${floatReg} = call float @array_get_f32(ptr ${arrayPtr}, i64 ${index})`)
        // Convert float to i64 for language value representation
        const convReg = `%${this.valueCounter++}`
        ir.push(`  ${convReg} = fptoui float ${floatReg} to i64`)
        return convReg
      } else if (elementType.kind === "f64") {
        const doubleReg = `%${this.valueCounter++}`
        ir.push(`  ${doubleReg} = call double @array_get_f64(ptr ${arrayPtr}, i64 ${index})`)
        // Convert double to i64 for language value representation
        const convReg = `%${this.valueCounter++}`
        ir.push(`  ${convReg} = fptoui double ${doubleReg} to i64`)
        return convReg
      } else {
        ir.push(`  ${reg} = call i64 @array_get(ptr ${arrayPtr}, i64 ${index})`)
      }
    } else {
      ir.push(`  ${reg} = call i64 @array_get(ptr ${arrayPtr}, i64 ${index})`)
    }
    return reg
  }

  private getArrayElementType(expr: any): any {
    if (!expr) return null

    // If it's an identifier, look up the variable type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "ArrayType") {
        return varType.elementType
      }
    }

    // If it's an index expression, recursively get element type
    if (expr.type === "IndexExpression") {
      return this.getArrayElementType(expr.object)
    }

    // Check if it's a MemberExpression on a SoA variable (returns array field)
    if (expr.type === "MemberExpression" && expr.object?.type === "Identifier") {
      const varType = this.variableTypes.get(expr.object.name)
      if (varType?.type === "SOAType") {
        const fieldName = expr.property?.name || expr.property
        const field = varType.fields?.get(fieldName)
        if (field?.type === "ArrayType") {
          return field.elementType
        }
      }
    }

    // Check if the expression itself has a resultType (from analyzer)
    if (expr.resultType?.type === "ArrayType") {
      return expr.resultType.elementType
    }

    return null
  }

  private isStringType(expr: any): boolean {
    if (!expr) return false

    // Check if it's a string literal
    if (expr.type === "StringLiteral") {
      return true
    }

    // If it's an identifier, look up the variable type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "ArrayType") {
        const arrType = varType as ArrayType
        return arrType.elementType?.type === "UnsignedType" &&
               (arrType.elementType as any)?.kind === "u8" &&
               arrType.dimensions.length === 0
      }
    }

    return false
  }

  private isMapType(expr: any): boolean {
    if (!expr) return false

    // If it's an identifier, look up the variable type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "MapType") {
        return true
      }
    }

    // Check if the expression itself has a resultType
    if (expr.resultType?.type === "MapType") {
      return true
    }

    return false
  }

  private generateSliceExpression(ir: string[], expr: any): string {
    const array = this.generateExpression(ir, expr.object)
    const start = this.generateExpression(ir, expr.start)
    const end = this.generateExpression(ir, expr.end)

    const isNestedIndex = expr.object?.type === "IndexExpression"
    let arrayPtr = array
    if (isNestedIndex) {
      const r = `%${this.valueCounter++}`
      ir.push(`  ${r} = inttoptr i64 ${array} to ptr`)
      arrayPtr = r
    }

    // Check if this is a string type [u8]
    if (this.isStringType(expr.object)) {
      const resultReg = `%${this.valueCounter++}`
      // String slicing with step not supported yet, use basic slice
      ir.push(`  ${resultReg} = call ptr @string_slice(ptr ${arrayPtr}, i64 ${start}, i64 ${end})`)
      return resultReg
    }

    const reg = `%${this.valueCounter++}`

    // Handle step parameter if provided
    if (expr.step) {
      const step = this.generateExpression(ir, expr.step)
      ir.push(`  ${reg} = call ptr @array_slice_step(ptr ${arrayPtr}, i64 ${start}, i64 ${end}, i64 ${step})`)
    } else {
      ir.push(`  ${reg} = call ptr @array_slice(ptr ${arrayPtr}, i64 ${start}, i64 ${end})`)
    }
    return reg
  }

  private generateLLMCall(ir: string[], expr: any): string {
    const resultReg = `%${this.valueCounter++}`

    const prompt = this.generateStringLiteral(ir, expr.arguments.prompt)
    const options = this.generateStringLiteral(ir, JSON.stringify(expr.arguments.options || {}))
    const returnType = this.generateStringLiteral(ir, expr.returnType || "string")

    ir.push(`  ${resultReg} = call ptr @llm_call(ptr ${prompt}, ptr ${options}, ptr ${returnType})`)
    return resultReg
  }

  private generateMapExpression(ir: string[], expr: any): string {
    const collection = this.generateExpression(ir, expr.collection)
    const func = expr.function

    return collection
  }

  private generateCastExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const sourceType = expr.sourceType ? this.toLLVMType(expr.sourceType) : this.toLLVMType(expr.value?.resultType)
    const targetType = this.toLLVMType(expr.targetType)
    const isSourceSigned = expr.sourceType?.type === "IntegerType"
    const isTargetSigned = expr.targetType?.type === "IntegerType"
    const reg = `%${this.valueCounter++}`

    const sourceIsInt = sourceType.startsWith("i") || sourceType === "ptr"
    const targetIsInt = targetType.startsWith("i") || targetType === "ptr"
    const sourceIsFloat = sourceType.startsWith("f")
    const targetIsFloat = targetType.startsWith("f")

    if (sourceType === "ptr" && targetIsInt) {
      ir.push(`  ${reg} = ptrtoint ptr ${value} to ${targetType}`)
      return reg
    }

    if (targetType === "ptr" && sourceIsInt) {
      ir.push(`  ${reg} = inttoptr ${sourceType} ${value} to ptr`)
      return reg
    }

    if (sourceIsInt && targetIsInt) {
      const sourceBits = this.getIntBits(sourceType)
      const targetBits = this.getIntBits(targetType)

      if (targetBits > sourceBits) {
        const op = isSourceSigned ? "sext" : "zext"
        ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
      } else if (targetBits < sourceBits) {
        ir.push(`  ${reg} = trunc ${sourceType} ${value} to ${targetType}`)
      } else {
        return value
      }
    } else if (sourceIsInt && targetIsFloat) {
      const op = isSourceSigned ? "sitofp" : "uitofp"
      ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
    } else if (sourceIsFloat && targetIsInt) {
      const op = isTargetSigned ? "fptosi" : "fptoui"
      ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
    } else if (sourceIsFloat && targetIsFloat) {
      const sourceBits = this.getFloatBits(sourceType)
      const targetBits = this.getFloatBits(targetType)

      if (targetBits > sourceBits) {
        ir.push(`  ${reg} = fpext ${sourceType} ${value} to ${targetType}`)
      } else if (targetBits < sourceBits) {
        ir.push(`  ${reg} = fptrunc ${sourceType} ${value} to ${targetType}`)
      } else {
        return value
      }
    }

    return reg
  }

  private generateBlock(ir: string[], statement: any): void {
    for (const stmt of statement.statements) {
      this.generateStatement(ir, stmt)
      if (this.blockTerminated) break
    }
  }

  private generateConditional(ir: string[], statement: any): void {
    const condValue = this.generateExpression(ir, statement.test || statement.condition)
    // Convert i64 condition to i1
    const condBool = `%${this.valueCounter++}`
    ir.push(`  ${condBool} = icmp ne i64 ${condValue}, 0`)
    const trueLabel = this.nextLabel()
    const falseLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    ir.push(`  br i1 ${condBool}, label %${trueLabel}, label %${falseLabel}`)
    ir.push("")

    // Save blockTerminated state - branches with terminators shouldn't affect parent block
    const prevTerminated = this.blockTerminated
    this.blockTerminated = false

    ir.push(`${trueLabel}:`)
    const trueBranch = statement.trueBranch || statement.consequent
    const trueHadTerminator = this.generateBlockWithTerminator(ir, trueBranch)
    if (!trueHadTerminator) {
      ir.push(`  br label %${endLabel}`)
      ir.push("")
    }

    ir.push(`${falseLabel}:`)
    const falseBranch = statement.falseBranch || statement.alternate
    let falseHadTerminator = false
    if (falseBranch) {
      falseHadTerminator = this.generateBlockWithTerminator(ir, falseBranch)
      if (!falseHadTerminator) {
        ir.push(`  br label %${endLabel}`)
        ir.push("")
      }
    } else {
      ir.push(`  br label %${endLabel}`)
      ir.push("")
    }

    // End label is needed if either branch doesn't have a terminator
    // (because those branches will branch to the end label)
    const needsEndLabel = !trueHadTerminator || !falseHadTerminator
    if (needsEndLabel) {
      ir.push(`${endLabel}:`)
    }

    // Restore blockTerminated state unless both branches terminate
    if (!(trueHadTerminator && falseHadTerminator)) {
      this.blockTerminated = prevTerminated
    }
  }

  private generateBlockWithTerminator(ir: string[], statement: any): boolean {
    if (statement.type === "Block") {
      let hadTerminator = false
      for (const stmt of statement.statements) {
        this.generateStatement(ir, stmt)
        if (this.blockTerminated) {
          hadTerminator = true
          break
        }
      }
      return hadTerminator
    } else {
      if (statement.type === "Return" || statement.type === "Break" || statement.type === "Continue") {
        this.generateStatement(ir, statement)
        return true
      }
      this.generateStatement(ir, statement)
      return false
    }
  }

  private generateWhileLoop(ir: string[], statement: any): void {
    const startLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: startLabel })

    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${startLabel}:`)
    const condValue = this.generateExpression(ir, statement.test || statement.condition)
    // Convert i64 condition to i1
    const condBool = `%${this.valueCounter++}`
    ir.push(`  ${condBool} = icmp ne i64 ${condValue}, 0`)
    ir.push(`  br i1 ${condBool}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.generateStatement(ir, statement.body)
    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Pop loop context
    this.loopStack.pop()
  }

  private generateForLoop(ir: string[], statement: any): void {
    const headerLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: incLabel })

    const { variable, start, end, body } = statement

    const reg = `%${variable}`
    ir.push(`  ${reg} = alloca i64`)
    const startValue = this.generateExpression(ir, start)
    ir.push(`  store i64 ${startValue}, ptr ${reg}`)

    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${headerLabel}:`)
    const varValue = this.generateExpression(ir, { type: "Identifier", name: variable })
    const endValue = this.generateExpression(ir, end)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp sle i64 ${varValue}, ${endValue}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.generateStatement(ir, body)
    if (!this.blockTerminated) {
      ir.push(`  br label %${incLabel}`)
      ir.push("")
    }

    ir.push(`${incLabel}:`)
    const currentValue = this.generateExpression(ir, { type: "Identifier", name: variable })
    const incValue = `%${this.valueCounter++}`
    ir.push(`  ${incValue} = add i64 ${currentValue}, 1`)
    ir.push(`  store i64 ${incValue}, ptr %${variable}`)
    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Emit vectorization metadata for hot loop optimization
    // This hints to LLVM that this loop should be vectorized for SIMD operations
    if (this.opts.vectorization) {
      this.emitVectorizationMetadata(ir, headerLabel, endLabel)
    }

    // Pop loop context
    this.loopStack.pop()
  }

  private generateForEachLoop(ir: string[], statement: any): void {
    const startLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: incLabel })
    const prevTerminated = this.blockTerminated
    this.blockTerminated = false

    const { variable, array, body } = statement

    // Generate array and get its length
    const arrayPtr = this.generateExpression(ir, array)
    const indexReg = `%${variable}_idx`
    const valueReg = `%${variable}`

    // Allocate index variable and loop variable
    ir.push(`  ${indexReg} = alloca i64`)
    ir.push(`  store i64 0, ptr ${indexReg}`)
    ir.push(`  ${valueReg} = alloca i64`)
    this.variableTypes.set(variable, { type: "IntegerType", kind: "i64" })

    // Get array length
    const lengthReg = `%${this.valueCounter++}`
    ir.push(`  ${lengthReg} = call i64 @array_length(ptr ${arrayPtr})`)

    ir.push(`  br label %${startLabel}`)
    ir.push("")

    // Header: check if index < length
    ir.push(`${startLabel}:`)
    const currentIndex = `%${this.valueCounter++}`
    ir.push(`  ${currentIndex} = load i64, ptr ${indexReg}`)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp slt i64 ${currentIndex}, ${lengthReg}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    // Body: get element and execute
    ir.push(`${bodyLabel}:`)
    const elemValue = `%${this.valueCounter++}`
    ir.push(`  ${elemValue} = call i64 @array_get(ptr ${arrayPtr}, i64 ${currentIndex})`)
    ir.push(`  store i64 ${elemValue}, ptr ${valueReg}`)
    this.generateStatement(ir, body)
    ir.push(`  br label %${incLabel}`)
    ir.push("")

    // Increment
    ir.push(`${incLabel}:`)
    const nextIndex = `%${this.valueCounter++}`
    ir.push(`  ${nextIndex} = add i64 ${currentIndex}, 1`)
    ir.push(`  store i64 ${nextIndex}, ptr ${indexReg}`)
    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Emit vectorization metadata for array iteration optimization
    // This enables SIMD vectorization for SoA column operations
    if (this.opts.vectorization) {
      this.emitVectorizationMetadata(ir, startLabel, endLabel)
    }

    // Pop loop context
    this.loopStack.pop()
    this.blockTerminated = prevTerminated
  }

  private generateForInRange(ir: string[], statement: any): void {
    const headerLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: incLabel })

    const { variable, start, end, body } = statement

    const reg = `%${variable}`
    ir.push(`  ${reg} = alloca i64`)
    this.variableTypes.set(variable, { type: "IntegerType", kind: "i64" })
    const startValue = this.generateExpression(ir, start)
    ir.push(`  store i64 ${startValue}, ptr ${reg}`)

    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${headerLabel}:`)
    const varValue = `%${this.valueCounter++}`
    ir.push(`  ${varValue} = load i64, ptr ${reg}`)
    const endValue = this.generateExpression(ir, end)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp slt i64 ${varValue}, ${endValue}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.blockTerminated = false
    this.generateStatement(ir, body)
    if (!this.blockTerminated) {
      ir.push(`  br label %${incLabel}`)
      ir.push("")
    }

    ir.push(`${incLabel}:`)
    const currentValue = `%${this.valueCounter++}`
    ir.push(`  ${currentValue} = load i64, ptr ${reg}`)
    const incValue = `%${this.valueCounter++}`
    ir.push(`  ${incValue} = add i64 ${currentValue}, 1`)
    ir.push(`  store i64 ${incValue}, ptr %${variable}`)
    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)
    this.blockTerminated = false

    // Pop loop context
    this.loopStack.pop()
  }

  private generateForInIndex(ir: string[], statement: any): void {
    const startLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: incLabel })
    const prevTerminated = this.blockTerminated
    this.blockTerminated = false

    const { indexVariable, valueVariable, iterable, body } = statement

    // Generate array and get its length
    const arrayPtr = this.generateExpression(ir, iterable)
    const indexReg = `%${indexVariable}`
    const valueReg = `%${valueVariable}`

    // Allocate index variable and value variable
    ir.push(`  ${indexReg} = alloca i64`)
    ir.push(`  store i64 0, ptr ${indexReg}`)
    ir.push(`  ${valueReg} = alloca i64`)
    this.variableTypes.set(indexVariable, { type: "IntegerType", kind: "i64" })
    this.variableTypes.set(valueVariable, { type: "IntegerType", kind: "i64" })

    // Get array length
    const lengthReg = `%${this.valueCounter++}`
    ir.push(`  ${lengthReg} = call i64 @array_length(ptr ${arrayPtr})`)

    ir.push(`  br label %${startLabel}`)
    ir.push("")

    // Header: check if index < length
    ir.push(`${startLabel}:`)
    const currentIndex = `%${this.valueCounter++}`
    ir.push(`  ${currentIndex} = load i64, ptr ${indexReg}`)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp slt i64 ${currentIndex}, ${lengthReg}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    // Body: get element and execute
    ir.push(`${bodyLabel}:`)
    const elemValue = `%${this.valueCounter++}`
    ir.push(`  ${elemValue} = call i64 @array_get(ptr ${arrayPtr}, i64 ${currentIndex})`)
    ir.push(`  store i64 ${elemValue}, ptr ${valueReg}`)
    this.generateStatement(ir, body)
    if (!this.blockTerminated) {
      ir.push(`  br label %${incLabel}`)
      ir.push("")
    }

    // Increment
    ir.push(`${incLabel}:`)
    const nextIndex = `%${this.valueCounter++}`
    ir.push(`  ${nextIndex} = add i64 ${currentIndex}, 1`)
    ir.push(`  store i64 ${nextIndex}, ptr ${indexReg}`)
    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Pop loop context
    this.loopStack.pop()
    this.blockTerminated = prevTerminated
  }

  private generateIfExpression(ir: string[], expr: any): string {
    const condValue = this.generateExpression(ir, expr.condition)
    // Convert i64 condition to i1
    const condBool = `%${this.valueCounter++}`
    ir.push(`  ${condBool} = icmp ne i64 ${condValue}, 0`)

    const trueLabel = this.nextLabel()
    const falseLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Allocate a place to store the result
    const resultReg = `%ifexpr_result_${this.valueCounter++}`
    ir.push(`  ${resultReg} = alloca i64`)

    ir.push(`  br i1 ${condBool}, label %${trueLabel}, label %${falseLabel}`)
    ir.push("")

    // True branch
    ir.push(`${trueLabel}:`)
    const trueValue = this.generateBlockExpression(ir, expr.trueBranch)
    ir.push(`  store i64 ${trueValue}, ptr ${resultReg}`)
    ir.push(`  br label %${endLabel}`)
    ir.push("")

    // False branch
    ir.push(`${falseLabel}:`)
    if (expr.falseBranch) {
      let falseValue: string
      if (expr.falseBranch.type === "IfExpression") {
        falseValue = this.generateIfExpression(ir, expr.falseBranch)
      } else {
        falseValue = this.generateBlockExpression(ir, expr.falseBranch)
      }
      ir.push(`  store i64 ${falseValue}, ptr ${resultReg}`)
    } else {
      ir.push(`  store i64 0, ptr ${resultReg}`)
    }
    ir.push(`  br label %${endLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)
    const result = `%${this.valueCounter++}`
    ir.push(`  ${result} = load i64, ptr ${resultReg}`)
    return result
  }

  private generateBlockExpression(ir: string[], block: any): string {
    // Generate all statements in a block, returning the value of the last expression statement
    if (block.type === "Block") {
      let lastValue = "0"
      for (const stmt of block.statements) {
        if (stmt.type === "ExpressionStatement") {
          lastValue = this.generateExpression(ir, stmt.expression)
        } else {
          this.generateStatement(ir, stmt)
        }
      }
      return lastValue
    }
    // Single expression
    return this.generateExpression(ir, block)
  }

  private generateLambda(ir: string[], expr: any): string {
    // Lift the lambda to a top-level function with a unique name
    const lambdaName = `__lambda_${this.lambdaCounter++}`
    const params = expr.params || []
    const returnType = expr.returnType
    const body = expr.body

    // Save current state
    const savedFunction = this.currentFunction
    const savedBlockTerminated = this.blockTerminated
    const savedValueCounter = this.valueCounter

    // Generate the lambda function IR into lambdaIR buffer
    const lambdaIrBuf: string[] = []

    this.resetValueCounter(10)

    const llvmParams = params.map((p: any) => {
      const llvmType = this.toLLVMType(p.paramType)
      return { name: p.name, type: llvmType }
    })

    const llvmReturnType = this.toLLVMType(returnType)

    const func: LLVMFunction = {
      name: lambdaName,
      returnType: llvmReturnType,
      params: llvmParams,
      body: [],
    }

    this.functions.set(lambdaName, func)
    this.functionTypes.set(lambdaName, returnType)
    this.currentFunction = func

    const paramStr = llvmParams.map((p: LLVMValue) => `${p.type} %${p.name}`).join(", ")

    lambdaIrBuf.push(`define ${llvmReturnType} @${lambdaName}(${paramStr}) nounwind {`)
    lambdaIrBuf.push("entry:")
    lambdaIrBuf.push("  call void @gc_push_frame()")

    for (const param of llvmParams) {
      const localReg = `%${param.name}_local`
      lambdaIrBuf.push(`  ${localReg} = alloca ${param.type}`)
      lambdaIrBuf.push(`  store ${param.type} %${param.name}, ptr ${localReg}`)
      const paramType = params.find((p: any) => p.name === param.name)?.paramType
      if (paramType) {
        this.variableTypes.set(param.name, paramType)
      }
    }
    lambdaIrBuf.push("")

    this.blockTerminated = false
    for (const stmt of body.statements) {
      this.generateStatement(lambdaIrBuf, stmt)
      if (this.blockTerminated) break
    }

    let hasReturn = false
    for (const stmt of body.statements) {
      if (stmt.type === "Return") {
        hasReturn = true
        break
      }
    }

    if (!hasReturn) {
      lambdaIrBuf.push("  call void @gc_pop_frame()")
      if (llvmReturnType !== "void") {
        lambdaIrBuf.push(`  ret ${llvmReturnType} 0`)
      } else {
        lambdaIrBuf.push("  ret void")
      }
    }

    lambdaIrBuf.push("}")
    lambdaIrBuf.push("")

    // Add to lambdaIR for later emission
    this.lambdaIR.push(...lambdaIrBuf)

    // Restore state
    this.currentFunction = savedFunction
    this.blockTerminated = savedBlockTerminated
    this.valueCounter = savedValueCounter

    // Return a function pointer to the lambda
    return `@${lambdaName}`
  }

  private generateMatchExpression(ir: string[], expr: any): string {
    const subjectValue = this.generateExpression(ir, expr.subject)

    // Allocate result
    const resultReg = `%match_result_${this.valueCounter++}`
    ir.push(`  ${resultReg} = alloca i64`)

    const endLabel = this.nextLabel()
    const arms = expr.arms as any[]

    for (let i = 0; i < arms.length; i++) {
      const arm = arms[i]
      const isLast = i === arms.length - 1

      if (arm.pattern.type === "WildcardPattern") {
        // Wildcard always matches - generate arm body and jump to end
        const armValue = this.generateExpression(ir, arm.body)
        ir.push(`  store i64 ${armValue}, ptr ${resultReg}`)
        ir.push(`  br label %${endLabel}`)
        ir.push("")
        break
      }

      const matchBodyLabel = this.nextLabel()
      const nextArmLabel = isLast ? endLabel : this.nextLabel()

      if (arm.pattern.type === "LiteralPattern") {
        // Generate the pattern value
        const patternValue = this.generateExpression(ir, arm.pattern.value)
        const cmpResult = `%${this.valueCounter++}`
        ir.push(`  ${cmpResult} = icmp eq i64 ${subjectValue}, ${patternValue}`)
        ir.push(`  br i1 ${cmpResult}, label %${matchBodyLabel}, label %${nextArmLabel}`)
        ir.push("")
      } else if (arm.pattern.type === "VariantPattern") {
        // Handle ok(val), err(msg), some(val) patterns on Result/Optional
        const variantName = arm.pattern.name
        const subjectPtr = `%match_ptr_${this.valueCounter++}`
        ir.push(`  ${subjectPtr} = inttoptr i64 ${subjectValue} to ptr`)

        if (variantName === "ok" || variantName === "some") {
          // Check tag == 0 for ok, tag == 1 for some (is_some)
          const checkFn = variantName === "ok" ? "@mog_result_is_ok" : "@mog_optional_is_some"
          const isMatch = `%${this.valueCounter++}`
          ir.push(`  ${isMatch} = call i64 ${checkFn}(ptr ${subjectPtr})`)
          const cmpResult = `%${this.valueCounter++}`
          ir.push(`  ${cmpResult} = icmp ne i64 ${isMatch}, 0`)
          ir.push(`  br i1 ${cmpResult}, label %${matchBodyLabel}, label %${nextArmLabel}`)
          ir.push("")

          // Arm body - bind the unwrapped value if there's a binding
          ir.push(`${matchBodyLabel}:`)
          if (arm.pattern.binding) {
            const unwrapFn = variantName === "ok" ? "@mog_result_unwrap" : "@mog_optional_unwrap"
            const unwrapped = `%${this.valueCounter++}`
            ir.push(`  ${unwrapped} = call i64 ${unwrapFn}(ptr ${subjectPtr})`)
            const bindingReg = `%${arm.pattern.binding}`
            ir.push(`  ${bindingReg} = alloca i64`)
            ir.push(`  store i64 ${unwrapped}, ptr ${bindingReg}`)
            this.variableTypes.set(arm.pattern.binding, new IntegerType("i64"))
          }
        } else if (variantName === "err") {
          // Check tag == 1 for err (is_ok == 0)
          const isOk = `%${this.valueCounter++}`
          ir.push(`  ${isOk} = call i64 @mog_result_is_ok(ptr ${subjectPtr})`)
          const cmpResult = `%${this.valueCounter++}`
          ir.push(`  ${cmpResult} = icmp eq i64 ${isOk}, 0`)
          ir.push(`  br i1 ${cmpResult}, label %${matchBodyLabel}, label %${nextArmLabel}`)
          ir.push("")

          // Arm body - bind the error message
          ir.push(`${matchBodyLabel}:`)
          if (arm.pattern.binding) {
            const errMsg = `%${this.valueCounter++}`
            ir.push(`  ${errMsg} = call ptr @mog_result_unwrap_err(ptr ${subjectPtr})`)
            const errInt = `%${this.valueCounter++}`
            ir.push(`  ${errInt} = ptrtoint ptr ${errMsg} to i64`)
            const bindingReg = `%${arm.pattern.binding}`
            ir.push(`  ${bindingReg} = alloca i64`)
            ir.push(`  store i64 ${errInt}, ptr ${bindingReg}`)
          }
        } else if (variantName === "none") {
          // Check is_some == 0
          const isSome = `%${this.valueCounter++}`
          ir.push(`  ${isSome} = call i64 @mog_optional_is_some(ptr ${subjectPtr})`)
          const cmpResult = `%${this.valueCounter++}`
          ir.push(`  ${cmpResult} = icmp eq i64 ${isSome}, 0`)
          ir.push(`  br i1 ${cmpResult}, label %${matchBodyLabel}, label %${nextArmLabel}`)
          ir.push("")
          ir.push(`${matchBodyLabel}:`)
        } else {
          // Unknown variant, skip
          ir.push(`  br label %${matchBodyLabel}`)
          ir.push(`${matchBodyLabel}:`)
        }

        const armValue = this.generateExpression(ir, arm.body)
        ir.push(`  store i64 ${armValue}, ptr ${resultReg}`)
        ir.push(`  br label %${endLabel}`)
        ir.push("")

        if (!isLast) {
          ir.push(`${nextArmLabel}:`)
        }
        continue
      }

      // Arm body
      ir.push(`${matchBodyLabel}:`)
      const armValue = this.generateExpression(ir, arm.body)
      ir.push(`  store i64 ${armValue}, ptr ${resultReg}`)
      ir.push(`  br label %${endLabel}`)
      ir.push("")

      // If not the last arm and not wildcard, emit the next arm label
      if (!isLast) {
        ir.push(`${nextArmLabel}:`)
      }
    }

    ir.push(`${endLabel}:`)
    const result = `%${this.valueCounter++}`
    ir.push(`  ${result} = load i64, ptr ${resultReg}`)
    return result
  }

  private generateBreak(ir: string[]): void {
    if (this.loopStack.length === 0) {
      // Error: break outside of loop - this should be caught by analyzer
      return
    }
    const loopContext = this.loopStack[this.loopStack.length - 1]
    ir.push(`  br label %${loopContext.breakLabel}`)
    this.blockTerminated = true
  }

  private generateContinue(ir: string[]): void {
    if (this.loopStack.length === 0) {
      // Error: continue outside of loop - this should be caught by analyzer
      return
    }
    const loopContext = this.loopStack[this.loopStack.length - 1]
    ir.push(`  br label %${loopContext.continueLabel}`)
    this.blockTerminated = true
  }

  private generateFunctionDeclaration(ir: string[], statement: any): void {
    const { name, params, returnType, body } = statement

    this.resetValueCounter(10)
    this.currentFunctionBasicBlocks = 0

    const llvmParams = params.map((p: any) => {
      const llvmType = this.toLLVMType(p.paramType)
      return { name: p.name, type: llvmType }
    })

    const llvmReturnType = this.toLLVMType(returnType)

    const func: LLVMFunction = {
      name,
      returnType: llvmReturnType,
      params: llvmParams,
      body: [],
    }

    this.functions.set(name, func)
    this.functionTypes.set(name, returnType)
    this.currentFunction = func

    const paramStr = llvmParams.map((p: LLVMValue) => `${p.type} %${p.name}`).join(", ")

    // Determine function attributes based on optimization settings
    // Small functions (few params, simple body) get alwaysinline for hot path optimization
    const funcAttributes = this.determineFunctionAttributes(statement)

    // Build function definition with proper LLVM syntax:
    // define <returntype> @<name>(<params>) [fn-attributes] {
    // Note: function attributes like nounwind, alwaysinline go after params, not before return type
    const attrSuffix = funcAttributes.trim()

    ir.push(`define ${llvmReturnType} @${name}(${paramStr})${attrSuffix} {`)
    ir.push("entry:")
    ir.push("  call void @gc_push_frame()")

    for (const param of llvmParams) {
      const paramReg = `%${param.name}`
      const localReg = `%${param.name}_local`
      ir.push(`  ${localReg} = alloca ${param.type}`)
      ir.push(`  store ${param.type} ${paramReg}, ptr ${localReg}`)
      // Track parameter type for later loads
      const paramType = params.find((p: any) => p.name === param.name)?.paramType
      if (paramType) {
        this.variableTypes.set(param.name, paramType)
      }
    }
    ir.push("")

    this.blockTerminated = false
    for (const stmt of body.statements) {
      this.generateStatement(ir, stmt)
      if (this.blockTerminated) break
    }

    let hasReturn = false
    for (const stmt of body.statements) {
      if (stmt.type === "Return") {
        hasReturn = true
        break
      }
    }

    if (!hasReturn) {
      ir.push("  call void @gc_pop_frame()")
      if (returnType !== "void") {
        ir.push(`  ret ${llvmReturnType} 0`)
      } else {
        ir.push("  ret void")
      }
    }

    ir.push("}")
    ir.push("")

    this.currentFunction = null
  }

  /**
   * Determine LLVM function attributes for optimization
   * Small functions get alwaysinline for hot path optimization
   */
  private determineFunctionAttributes(statement: any): string {
    const attrs: string[] = []
    const body = statement.body

    // Count basic blocks by checking for control flow statements
    let basicBlockCount = 1 // entry block
    if (body?.statements) {
      for (const stmt of body.statements) {
        if (stmt.type === "Conditional" || stmt.type === "WhileLoop" ||
            stmt.type === "ForLoop" || stmt.type === "ForEachLoop") {
          basicBlockCount++
        }
      }
    }

    // Small functions: mark as alwaysinline for hot path optimization
    if (basicBlockCount <= this.opts.inlineThreshold) {
      attrs.push("alwaysinline")
    }

    // Inline functions with small struct operations for hot path optimization
    // This enables efficient struct field access and copy operations
    if (this.hasSmallStructOperations(statement)) {
      if (!attrs.includes("alwaysinline")) {
        attrs.push("alwaysinline")
      }
    }

    // Add nounwind for functions that don't unwind (no exceptions in Mog)
    attrs.push("nounwind")

    // Return attributes as suffix (with leading space if any attributes present)
    return attrs.length > 0 ? ` ${attrs.join(" ")}` : ""
  }

  /**
   * Emit LLVM metadata for loop vectorization
   * This hints to the LLVM optimizer to vectorize array operations
   */
  private emitVectorizationMetadata(ir: string[], loopStart: string, loopEnd: string): void {
    if (!this.opts.vectorization) return

    // Add a metadata node to mark this loop as vectorizable
    // In full LLVM IR, this would be: !0 = !{!"llvm.loop.vectorize.enable", i1 1}
    // For now, we add a comment hint that the optimizer can use
    ir.push(`  ; VECTORIZE_HINT: loop ${loopStart} -> ${loopEnd}`)
  }

  /**
   * Check if bounds checks can be elided (release mode only)
   * In release mode, skip bounds checks for performance
   */
  private shouldElideBoundsCheck(): boolean {
    return this.opts.releaseMode
  }

  /**
   * Determine if a function operates on small structs that should be inlined
   * This enables hot path optimization for struct field access and copy operations
   */
  private hasSmallStructOperations(statement: any): boolean {
    // Check if function body contains struct operations
    // Small struct operations benefit from inlining
    const body = statement.body
    if (!body?.statements) return false

    for (const stmt of body.statements) {
      // Check for struct-related operations
      if (this.containsStructOperations(stmt)) {
        return true
      }
    }
    return false
  }

  /**
   * Recursively check if a statement contains struct operations
   */
  private containsStructOperations(stmt: any): boolean {
    if (!stmt) return false

    // Check for struct field access or assignment
    if (stmt.type === "MemberExpression" ||
        (stmt.type === "AssignmentStatement" &&
         stmt.target?.type === "MemberExpression")) {
      // This could be a struct field operation - check if it uses inline hint
      return true
    }

    // Recursively check nested statements
    if (stmt.body?.statements) {
      for (const s of stmt.body.statements) {
        if (this.containsStructOperations(s)) return true
      }
    }

    return false
  }

  /**
   * Emit inline hint for small struct operations
   * Marks struct copy/field access operations for LLVM inlining
   */
  private emitStructInlineHint(ir: string[], structName: string, operation: string): void {
    // Emit a comment hint that LLVM can use for inlining decisions
    ir.push(`  ; STRUCT_INLINE_HINT: ${structName} ${operation}`)
  }

  private generateReturn(ir: string[], statement: any): void {
    if (statement.value) {
      const reg = this.generateExpression(ir, statement.value)
      const returnType = this.currentFunction?.returnType || "i64"
      ir.push(`  ret ${returnType} ${reg}`)
    } else {
      ir.push("  ret void")
    }
  }

  private setupMainFunction(ir: string[]): void {
    ir.push("")
    ir.push("; Main entry point")
    ir.push("define i32 @main() {")
    ir.push("entry:")
    ir.push("  call void @gc_init()")
    ir.push("  call void @gc_push_frame()")
    ir.push("  call void @program()")
    ir.push("  call void @gc_pop_frame()")
    ir.push("  ret i32 0")
    ir.push("}")
  }

  private generateRuntimeFunctions(ir: string[]): void {
    ir.push("")
    ir.push("; Runtime function definitions (linked from runtime library)")
  }

  private generatePOSIXDeclarations(ir: string[]): void {
    ir.push("")
    ir.push("; POSIX function declarations")

    ir.push("declare i64 @open(ptr, i64, ...)")
    ir.push("declare i64 @read(i64, ptr, i64)")
    ir.push("declare i64 @write(i64, ptr, i64)")
    ir.push("declare i64 @close(i64)")
    ir.push("declare i64 @access(ptr, i64)")
    ir.push("declare i64 @faccessat(i64, ptr, i64, i64)")
    ir.push("declare i64 @chmod(ptr, i64)")
    ir.push("declare i64 @fchmod(i64, i64)")
    ir.push("declare i64 @chown(ptr, i64, i64)")
    ir.push("declare i64 @fchown(i64, i64, i64)")
    ir.push("declare i64 @lseek(i64, i64, i64)")
    ir.push("declare i64 @fsync(i64)")
    ir.push("declare i64 @fdatasync(i64)")
    ir.push("declare i64 @ftruncate(i64, i64)")
    ir.push("declare i64 @stat(ptr, ptr)")
    ir.push("declare i64 @lstat(ptr, ptr)")
    ir.push("declare i64 @fstat(i64, ptr)")
    ir.push("declare i64 @link(ptr, ptr)")
    ir.push("declare i64 @symlink(ptr, ptr)")
    ir.push("declare i64 @readlink(ptr, ptr, i64)")
    ir.push("declare i64 @unlink(ptr)")
    ir.push("declare i64 @rename(ptr, ptr)")
    ir.push("declare ptr @opendir(ptr)")
    ir.push("declare ptr @readdir(ptr)")
    ir.push("declare void @rewinddir(ptr)")
    ir.push("declare void @closedir(ptr)")
    ir.push("declare i64 @mkdir(ptr, i64)")
    ir.push("declare i64 @rmdir(ptr)")
    ir.push("declare i64 @chdir(ptr)")
    ir.push("declare i64 @fchdir(i64)")
    ir.push("declare i64 @getcwd(ptr, i64)")
    ir.push("declare i64 @dup(i64)")
    ir.push("declare i64 @dup2(i64, i64)")
    ir.push("declare i64 @fcntl(i64, i64, ...)")
    ir.push("declare i64 @pathconf(ptr, i64)")
    ir.push("declare i64 @fpathconf(i64, i64)")
    ir.push("declare i64 @creat(ptr, i64)")
    ir.push("declare i64 @mkfifo(ptr, i64)")
    ir.push("declare i64 @mknod(ptr, i64, i64)")
    ir.push("declare i64 @utimes(ptr, ptr)")
    ir.push("declare i64 @futimes(i64, ptr)")
    ir.push("declare i64 @utimensat(i64, ptr, ptr, i64)")
    ir.push("declare i64 @pread(i64, ptr, i64, i64)")
    ir.push("declare i64 @pwrite(i64, ptr, i64, i64)")
    ir.push("declare i64 @truncate(ptr, i64)")
    ir.push("")
  }

  private generatePrintDeclarations(ir: string[]): void {
    ir.push("")
    ir.push("; Print function declarations")
    ir.push("declare void @print_i64(i64)")
    ir.push("declare void @print_u64(i64)")
    ir.push("declare void @print_f64(double)")
    ir.push("declare void @print_string(ptr)")
    ir.push("declare void @print_buffer(ptr, i64)")
    ir.push("declare void @println()")
    ir.push("declare void @println_i64(i64)")
    ir.push("declare void @println_u64(i64)")
    ir.push("declare void @println_f64(double)")
    ir.push("declare void @println_string(ptr)")
    ir.push("")
    ir.push("; Input function declarations")
    ir.push("declare i64 @input_i64()")
    ir.push("declare i64 @input_u64()")
    ir.push("declare double @input_f64()")
    ir.push("declare ptr @input_string()")
    ir.push("")
  }

  private generateSocketDeclarations(ir: string[]): void {
    ir.push("")
    ir.push("; Socket syscall declarations")
    ir.push("declare i64 @sys_socket(i32, i32, i32)")
    ir.push("declare i64 @sys_connect(i64, i32, i16)")
    ir.push("declare i64 @sys_send(i64, ptr, i64, i32)")
    ir.push("declare i64 @sys_recv(i64, ptr, i64, i32)")
    ir.push("declare i64 @sys_close(i64)")
    ir.push("declare i64 @sys_fcntl(i64, i32, i64)")
    ir.push("declare i32 @sys_inet_addr(ptr)")
    ir.push("declare i64 @sys_select(i64, ptr, ptr, ptr, ptr)")
    ir.push("declare i64 @sys_errno()")
    ir.push("")
    ir.push("; Socket constants (external)")
    ir.push("@AS_AF_INET = external global i32")
    ir.push("@AS_SOCK_STREAM = external global i32")
    ir.push("@AS_SOCK_DGRAM = external global i32")
    ir.push("@AS_O_NONBLOCK = external global i32")
    ir.push("")
  }

  private nextLabel(): string {
    return `label${this.labelCounter++}`
  }

  private toLLVMType(type: any): LLVMType {
    if (!type) return "i64"

    switch (type.type) {
      case "IntegerType":
        return type.kind as LLVMType
      case "UnsignedType":
        return type.kind as LLVMType
      case "FloatType":
        // LLVM float type mapping: f8/f16->half, f32->float, f64->double, f128->fp128
        // f256 is not natively supported by LLVM - we treat it as fp128 (or could use software emulation)
        switch (type.kind) {
          case "f8":
          case "f16":
            return "half"
          case "f32":
            return "float"
          case "f64":
            return "double"
          case "f128":
          case "f256":
            return "fp128"
          default:
            return "float"
        }
      case "ArrayType":
        return "ptr"
      case "MapType":
        return "ptr"
      case "StructType":
        // Structs are heap-allocated, represented as pointers
        return "ptr"
      case "AOSType":
        // AoS is an array of structs, represented as pointer
        return "ptr"
      case "SOAType":
        // SoA is heap-allocated, represented as pointer
        return "ptr"
      case "CustomType":
        // Custom types (structs) are heap-allocated, represented as pointers
        return "ptr"
      case "PointerType":
        return "ptr"
      case "FunctionType":
        // Function types are function pointers
        return "ptr"
      case "VoidType":
        return "void"
 default:
        return "i64"
    }
  }

private getIntBits(type: LLVMType): number {
    const match = type.match(/i(\d+)/)
    return match ? parseInt(match[1]) : 64
  }

  private getFloatBits(type: LLVMType): number {
    switch (type) {
      case "half": return 16
      case "float": return 32
      case "double": return 64
      case "fp128": return 128
      default: return 32
    }
  }

  private isFloatType(llvmType: LLVMType): boolean {
    return llvmType === "half" || llvmType === "float" || llvmType === "double" || llvmType === "fp128"
  }

  private isFloatOperand(expr: any): boolean {
    if (!expr) return false

    // Check literal type annotation
    if (expr.literalType?.type === "FloatType") return true

    // Check if it's a float literal value
    if (typeof expr.value === "number" && !Number.isInteger(expr.value)) return true
    if (typeof expr.value === "string") {
      const val = expr.value.toLowerCase()
      if (val.includes(".") || val.includes("e")) return true
    }

    // Check if it's an identifier with float type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      return varType?.type === "FloatType"
    }

    // Check if it's a MemberExpression on a struct with float field
    if (expr.type === "MemberExpression" && expr.object?.type === "Identifier") {
      const varType = this.variableTypes.get(expr.object.name)
      if (varType?.type === "StructType" || varType?.type === "SOAType" || varType?.type === "CustomType") {
        const fieldName = expr.property?.name || expr.property
        const structInfo = this.structDefs.get(expr.object.name) || this.structDefs.get(varType.name)
        if (structInfo) {
          const field = structInfo.find((f: any) => f.name === fieldName)
          if (field?.fieldType?.type === "FloatType") return true
        }
      }
    }

    // For binary expressions, check left operand recursively
    if (expr.type === "BinaryExpression") {
      return this.isFloatOperand(expr.left) || this.isFloatOperand(expr.right)
    }

    return false
  }

  private getFloatTypeSize(expr: any): "half" | "float" | "double" | "fp128" {
    if (!expr) return "float"

    const floatKindToLLVM = (kind: string): "half" | "float" | "double" | "fp128" => {
      switch (kind) {
        case "f8":
        case "f16":
          return "half"
        case "f32":
          return "float"
        case "f64":
          return "double"
        case "f128":
        case "f256":
          return "fp128"
        default:
          return "float"
      }
    }

    // Check literal type annotation
    if (expr.literalType?.type === "FloatType") {
      return floatKindToLLVM(expr.literalType.kind)
    }

    // Check if it's an identifier with float type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "FloatType") {
        return floatKindToLLVM(varType.kind)
      }
    }

    // For binary expressions, check operands recursively and use widest type
    if (expr.type === "BinaryExpression") {
      const leftSize = this.getFloatTypeSize(expr.left)
      const rightSize = this.getFloatTypeSize(expr.right)
      // Priority: fp128 > double > float > half
      if (leftSize === "fp128" || rightSize === "fp128") return "fp128"
      if (leftSize === "double" || rightSize === "double") return "double"
      if (leftSize === "float" || rightSize === "float") return "float"
      return "half"
    }

    // For function calls, check the function's return type
    if (expr.type === "CallExpression") {
      const funcName = expr.function?.name || expr.callee?.name
      if (funcName) {
        const func = this.functions.get(funcName)
        if (func) {
          switch (func.returnType) {
            case "half": return "half"
            case "float": return "float"
            case "double": return "double"
            case "fp128": return "fp128"
          }
        }
      }
    }

    // For MemberExpression on structs, check the field type
    if (expr.type === "MemberExpression" && expr.object?.type === "Identifier") {
      const varType = this.variableTypes.get(expr.object.name)
      if (varType?.type === "StructType" || varType?.type === "SOAType" || varType?.type === "CustomType") {
        const fieldName = expr.property?.name || expr.property
        const structInfo = this.structDefs.get(expr.object.name) || this.structDefs.get(varType.name)
        if (structInfo) {
          const field = structInfo.find((f: any) => f.name === fieldName)
          if (field?.fieldType?.type === "FloatType") {
            return floatKindToLLVM(field.fieldType.kind)
          }
        }
      }
    }

    return "float" // default to float
  }

  private floatToHex(value: number, kind: string): string {
    // Convert float value to IEEE 754 hex representation based on type
    switch (kind) {
      case "f8":
      case "f16": {
        // Half precision (16-bit)
        const buffer = new ArrayBuffer(2)
        // Use Float16Array if available, otherwise convert via Float32
        if (typeof Float16Array !== 'undefined') {
          new Float16Array(buffer)[0] = value
        } else {
          // Convert float32 to half precision manually
          const f32Buffer = new ArrayBuffer(4)
          new DataView(f32Buffer).setFloat32(0, value, false)
          const f32Bits = new DataView(f32Buffer).getUint32(0, false)
          // Extract sign, exponent, mantissa
          const sign = (f32Bits >> 31) & 0x1
          const exponent = (f32Bits >> 23) & 0xFF
          const mantissa = f32Bits & 0x7FFFFF
          // Convert to half precision
          let hSign = sign
          let hExponent: number
          let hMantissa: number
          if (exponent === 0) {
            hExponent = 0
            hMantissa = 0
          } else if (exponent === 0xFF) {
            hExponent = 0x1F
            hMantissa = mantissa ? 0x200 : 0
          } else {
            const newExp = exponent - 127 + 15
            if (newExp >= 31) {
              hExponent = 0x1F
              hMantissa = 0
            } else if (newExp <= 0) {
              hExponent = 0
              hMantissa = (mantissa | 0x800000) >> (1 - newExp)
            } else {
              hExponent = newExp
              hMantissa = mantissa >> 13
            }
          }
          const hBits = (hSign << 15) | (hExponent << 10) | hMantissa
          return `0x${hBits.toString(16).padStart(4, '0')}`
        }
        const bits = new DataView(buffer).getUint16(0, false)
        return `0x${bits.toString(16).padStart(4, '0')}`
      }
      case "f32": {
        // Single precision (32-bit)
        const buffer = new ArrayBuffer(4)
        new DataView(buffer).setFloat32(0, value, false)
        const bits = new DataView(buffer).getUint32(0, false)
        return `0x${bits.toString(16).padStart(8, '0')}`
      }
      case "f64":
      default: {
        // Double precision (64-bit)
        const buffer = new ArrayBuffer(8)
        new DataView(buffer).setFloat64(0, value, false)
        const bits = new DataView(buffer).getBigUint64(0, false)
        return `0x${bits.toString(16).padStart(16, '0')}`
      }
      case "f128":
      case "f256": {
        // Quad precision (128-bit) - use fp128 format
        // For now, store as double and zero-pad the high bits
        const buffer = new ArrayBuffer(8)
        new DataView(buffer).setFloat64(0, value, false)
        const lowBits = new DataView(buffer).getBigUint64(0, false)
        return `0x0000000000000000${lowBits.toString(16).padStart(16, '0')}`
      }
    }
  }

  private floatToIntBits(value: number, kind: string): string {
    // Convert float value to LLVM hex float format (e.g., 0x40091eb851eb851f for 3.14)
    switch (kind) {
      case "f32": {
        const buffer = new ArrayBuffer(4)
        new DataView(buffer).setFloat32(0, value, false)
        const bits = new DataView(buffer).getUint32(0, false)
        return `0x${bits.toString(16).padStart(8, '0')}`
      }
      case "f64":
      default: {
        const buffer = new ArrayBuffer(8)
        new DataView(buffer).setFloat64(0, value, false)
        const bits = new DataView(buffer).getBigUint64(0, false)
        return `0x${bits.toString(16).padStart(16, '0')}`
      }
    }
  }

  private isPointerArithmetic(expr: any, leftReg: string, rightReg: string): boolean {
    // Check if this is pointer arithmetic: ptr + offset or ptr - offset
    // This is a heuristic - if left looks like a pointer register (contains "ptr" in the name)
    // and the operator is + or -, treat it as pointer arithmetic
    return (expr.operator === "+" || expr.operator === "-") &&
           (leftReg.startsWith("%ptr") || this.isPointerExpression(expr.left))
  }

  private isPointerExpression(expr: any): boolean {
    if (!expr) return false
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      return varType?.type === "PointerType" || varType?.type === "Pointer"
    }
    return false
  }

  private generatePointerArithmetic(ir: string[], expr: any, leftReg: string, rightReg: string): string {
    const resultReg = `%${this.valueCounter++}`
    // LLVM uses getelementptr for pointer arithmetic
    // gep i8, ptr %left, i64 %right gives ptr = left + right bytes
    if (expr.operator === "+") {
      ir.push(`  ${resultReg} = getelementptr i8, ptr ${leftReg}, i64 ${rightReg}`)
    } else { // operator === "-"
      // Negate the offset for subtraction
      const negReg = `%${this.valueCounter++}`
      ir.push(`  ${negReg} = sub i64 0, ${rightReg}`)
      ir.push(`  ${resultReg} = getelementptr i8, ptr ${leftReg}, i64 ${negReg}`)
    }
    return resultReg
  }

  // ============================================================================
  // Result/Optional Error Handling Code Generation
  // ============================================================================

  private generateOkExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const resultPtr = `%${this.valueCounter++}`
    ir.push(`  ${resultPtr} = call ptr @mog_result_ok(i64 ${value})`)
    const resultInt = `%${this.valueCounter++}`
    ir.push(`  ${resultInt} = ptrtoint ptr ${resultPtr} to i64`)
    return resultInt
  }

  private generateErrExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    // The value should be a string pointer
    const valuePtr = `%${this.valueCounter++}`
    ir.push(`  ${valuePtr} = inttoptr i64 ${value} to ptr`)
    const resultPtr = `%${this.valueCounter++}`
    ir.push(`  ${resultPtr} = call ptr @mog_result_err(ptr ${valuePtr})`)
    const resultInt = `%${this.valueCounter++}`
    ir.push(`  ${resultInt} = ptrtoint ptr ${resultPtr} to i64`)
    return resultInt
  }

  private generateSomeExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const optPtr = `%${this.valueCounter++}`
    ir.push(`  ${optPtr} = call ptr @mog_optional_some(i64 ${value})`)
    const optInt = `%${this.valueCounter++}`
    ir.push(`  ${optInt} = ptrtoint ptr ${optPtr} to i64`)
    return optInt
  }

  private generateNoneExpression(ir: string[]): string {
    const optPtr = `%${this.valueCounter++}`
    ir.push(`  ${optPtr} = call ptr @mog_optional_none()`)
    const optInt = `%${this.valueCounter++}`
    ir.push(`  ${optInt} = ptrtoint ptr ${optPtr} to i64`)
    return optInt
  }

  private generatePropagateExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const valuePtr = `%${this.valueCounter++}`
    ir.push(`  ${valuePtr} = inttoptr i64 ${value} to ptr`)

    // Determine if this is Result or Optional based on type annotation
    const resultType = (expr.value as any).resultType
    const isOptional = resultType instanceof OptionalType

    const isOkLabel = this.nextLabel()
    const propagateLabel = this.nextLabel()

    if (isOptional) {
      const isSome = `%${this.valueCounter++}`
      ir.push(`  ${isSome} = call i64 @mog_optional_is_some(ptr ${valuePtr})`)
      const cmp = `%${this.valueCounter++}`
      ir.push(`  ${cmp} = icmp ne i64 ${isSome}, 0`)
      ir.push(`  br i1 ${cmp}, label %${isOkLabel}, label %${propagateLabel}`)

      ir.push(`${propagateLabel}:`)
      // Return the none value from the current function
      ir.push(`  call void @gc_pop_frame()`)
      ir.push(`  ret i64 ${value}`)

      ir.push(`${isOkLabel}:`)
      const unwrapped = `%${this.valueCounter++}`
      ir.push(`  ${unwrapped} = call i64 @mog_optional_unwrap(ptr ${valuePtr})`)
      return unwrapped
    } else {
      // Assume Result type
      const isOk = `%${this.valueCounter++}`
      ir.push(`  ${isOk} = call i64 @mog_result_is_ok(ptr ${valuePtr})`)
      const cmp = `%${this.valueCounter++}`
      ir.push(`  ${cmp} = icmp ne i64 ${isOk}, 0`)
      ir.push(`  br i1 ${cmp}, label %${isOkLabel}, label %${propagateLabel}`)

      ir.push(`${propagateLabel}:`)
      // Return the error Result from the current function
      ir.push(`  call void @gc_pop_frame()`)
      ir.push(`  ret i64 ${value}`)

      ir.push(`${isOkLabel}:`)
      const unwrapped = `%${this.valueCounter++}`
      ir.push(`  ${unwrapped} = call i64 @mog_result_unwrap(ptr ${valuePtr})`)
      return unwrapped
    }
  }

  private generateIsSomeExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const valuePtr = `%${this.valueCounter++}`
    ir.push(`  ${valuePtr} = inttoptr i64 ${value} to ptr`)
    const isSome = `%${this.valueCounter++}`
    ir.push(`  ${isSome} = call i64 @mog_optional_is_some(ptr ${valuePtr})`)

    // If there's a binding, unwrap the value and store it
    if (expr.binding) {
      const bindingReg = `%${expr.binding}`
      ir.push(`  ${bindingReg} = alloca i64`)
      const unwrapped = `%${this.valueCounter++}`
      ir.push(`  ${unwrapped} = call i64 @mog_optional_unwrap(ptr ${valuePtr})`)
      ir.push(`  store i64 ${unwrapped}, ptr ${bindingReg}`)
      this.variableTypes.set(expr.binding, new IntegerType("i64"))
    }
    return isSome
  }

  private generateIsNoneExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const valuePtr = `%${this.valueCounter++}`
    ir.push(`  ${valuePtr} = inttoptr i64 ${value} to ptr`)
    const isSome = `%${this.valueCounter++}`
    ir.push(`  ${isSome} = call i64 @mog_optional_is_some(ptr ${valuePtr})`)
    const isNone = `%${this.valueCounter++}`
    ir.push(`  ${isNone} = xor i64 ${isSome}, 1`)
    return isNone
  }

  private generateIsOkExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const valuePtr = `%${this.valueCounter++}`
    ir.push(`  ${valuePtr} = inttoptr i64 ${value} to ptr`)
    const isOk = `%${this.valueCounter++}`
    ir.push(`  ${isOk} = call i64 @mog_result_is_ok(ptr ${valuePtr})`)

    if (expr.binding) {
      const bindingReg = `%${expr.binding}`
      ir.push(`  ${bindingReg} = alloca i64`)
      const unwrapped = `%${this.valueCounter++}`
      ir.push(`  ${unwrapped} = call i64 @mog_result_unwrap(ptr ${valuePtr})`)
      ir.push(`  store i64 ${unwrapped}, ptr ${bindingReg}`)
      this.variableTypes.set(expr.binding, new IntegerType("i64"))
    }
    return isOk
  }

  private generateIsErrExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const valuePtr = `%${this.valueCounter++}`
    ir.push(`  ${valuePtr} = inttoptr i64 ${value} to ptr`)
    const isOk = `%${this.valueCounter++}`
    ir.push(`  ${isOk} = call i64 @mog_result_is_ok(ptr ${valuePtr})`)
    const isErr = `%${this.valueCounter++}`
    ir.push(`  ${isErr} = xor i64 ${isOk}, 1`)

    if (expr.binding) {
      const bindingReg = `%${expr.binding}`
      ir.push(`  ${bindingReg} = alloca i64`)
      const errMsg = `%${this.valueCounter++}`
      ir.push(`  ${errMsg} = call ptr @mog_result_unwrap_err(ptr ${valuePtr})`)
      const errInt = `%${this.valueCounter++}`
      ir.push(`  ${errInt} = ptrtoint ptr ${errMsg} to i64`)
      ir.push(`  store i64 ${errInt}, ptr ${bindingReg}`)
    }
    return isErr
  }

  private generateTryCatch(ir: string[], statement: any): void {
    // TryCatch implementation:
    // The try body runs. If a ? propagation occurs, it stores the error
    // and jumps to the catch block.
    // We use a global-like error flag to track if we're in an error state.

    // For simplicity, we implement try/catch as:
    // 1. Allocate an error result variable
    // 2. Run try body statements
    // 3. Jump to end
    // 4. Catch block: the error variable gets bound
    // Note: With the ? operator, the error propagation generates a ret instruction,
    // so we need a different approach for try/catch.

    // Actually, the way to implement try/catch with ? is:
    // Inside a try block, instead of returning from the function on error,
    // we jump to the catch block.

    // Simple implementation: generate try body as a block, catch as a block.
    // The ? operator inside try should be handled at a higher level.
    // For now, let's emit the try body normally and the catch body as a fallback.

    // Generate a flag for error tracking
    const errorFlag = `%try_err_flag_${this.valueCounter++}`
    const errorValue = `%try_err_val_${this.valueCounter++}`
    ir.push(`  ${errorFlag} = alloca i64`)
    ir.push(`  store i64 0, ptr ${errorFlag}`)
    ir.push(`  ${errorValue} = alloca i64`)
    ir.push(`  store i64 0, ptr ${errorValue}`)

    const tryEndLabel = this.nextLabel()
    const catchLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Generate try body
    for (const stmt of statement.tryBody.statements) {
      this.generateStatement(ir, stmt)
      if (this.blockTerminated) {
        this.blockTerminated = false
        break
      }
    }
    ir.push(`  br label %${tryEndLabel}`)

    // Try completed successfully - skip catch
    ir.push(`${tryEndLabel}:`)
    ir.push(`  br label %${endLabel}`)

    // Catch block
    ir.push(`${catchLabel}:`)
    // Bind error variable
    const errVarReg = `%${statement.errorVar}`
    ir.push(`  ${errVarReg} = alloca i64`)
    const errLoad = `%${this.valueCounter++}`
    ir.push(`  ${errLoad} = load i64, ptr ${errorValue}`)
    ir.push(`  store i64 ${errLoad}, ptr ${errVarReg}`)
    this.variableTypes.set(statement.errorVar, new IntegerType("i64"))

    for (const stmt of statement.catchBody.statements) {
      this.generateStatement(ir, stmt)
      if (this.blockTerminated) break
    }
    if (!this.blockTerminated) {
      ir.push(`  br label %${endLabel}`)
    }
    this.blockTerminated = false

    ir.push(`${endLabel}:`)
  }
}

export function generateLLVMIR(ast: ProgramNode, options?: Partial<OptimizationOptions>, capabilities?: string[]): string {
  const generator = new LLVMIRGenerator(options)
  if (capabilities && capabilities.length > 0) {
    generator.setCapabilities(capabilities)
  }
  return generator.generate(ast)
}

export { LLVMIRGenerator, type OptimizationOptions }
