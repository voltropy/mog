import type { ProgramNode, StatementNode, ExpressionNode } from "./analyzer.js"
import type { ArrayType } from "./types.js"
import { isArrayType,   isMapType, isFloatType } from "./types.js"

type LLVMType = "i8" | "i16" | "i32" | "i64" | "i128" | "i256" | "half" | "float" | "double" | "fp128" | "void" | "ptr"

type LLVMValue = {
  name: string
  type: LLVMType
  isConstant?: boolean
}

type LLVMFunction = {
  name: string
  returnType: LLVMType
  params: LLVMValue[]
  body: string[]
}

type LLVMGlobal = {
  name: string
  type: LLVMType
  initValue?: string
}

type OptimizationOptions = {
  /** Enable release mode optimizations (bounds check elision) */
  releaseMode: boolean
  /** Enable vectorization hints for array operations */
  vectorization: boolean
  /** Inline threshold: functions with fewer basic blocks will be marked alwaysinline */
  inlineThreshold: number
}

const defaultOptimizationOptions: OptimizationOptions = {
  releaseMode: process.env.ALGOLSCRIPT_RELEASE === "1",
  vectorization: true,
  inlineThreshold: 3,
}

class LLVMIRGenerator {
  private functions: Map<string, LLVMFunction> = new Map()
  private globals: LLVMGlobal[] = []
  private currentFunction: LLVMFunction | null = null
  private blockCounter = 0
  private valueCounter = 0
  private variableTypes: Map<string, any> = new Map()
  private functionTypes: Map<string, any> = new Map()
  private loopStack: { breakLabel: string; continueLabel: string }[] = []
  private blockTerminated = false
  private opts: OptimizationOptions
  private currentFunctionBasicBlocks = 0

  constructor(options: Partial<OptimizationOptions> = {}) {
    this.opts = { ...defaultOptimizationOptions, ...options }
  }

  private resetValueCounter(start: number = 0): void {
    this.valueCounter = start
  }
  private labelCounter = 0
  private stringConstants: string[] = []
  private stringCounter = 0
  private resetStringCounter(): void {
    this.stringCounter = 0
  }

  generate(ast: ProgramNode): string {
    const ir: string[] = []

    ir.push("; AlgolScript LLVM IR")
    ir.push("; Generated by AlgolScript compiler")
    ir.push("")

    const platform = process.platform === "darwin" ? "aarch64-apple-darwin" :
                     process.platform === "win32" ? "x86_64-pc-windows-msvc" :
                     "x86_64-unknown-linux-gnu"
    ir.push(`target triple = "${platform}"`)
    ir.push("")

    this.setupDeclarations(ir)
    this.generatePrintDeclarations(ir)

    this.resetValueCounter(0)
    this.resetStringCounter()
    this.stringConstants = []  // Clear string constants

    // First: collect all string constants from AST
    this.collectStringConstants(ast)
    // Reset counter for code generation pass
    this.stringCounter = 0

    // Collect function declarations first to identify strings in functions
    const functionDeclarations = this.collectFunctionDeclarations(ast)

    // Check if user has defined a main() function
    const mainFunc = functionDeclarations.find((f: any) => f.name === "main")
    const hasMain = !!mainFunc

    // Insert string constants before function declarations
    ir.push("; String constants")
    for (const str of this.stringConstants) {
      ir.push(str)
    }
    ir.push("")

    ir.push("; Function declarations")
    // First pass: register all function types before generating code
    for (const funcDecl of functionDeclarations) {
      this.functionTypes.set(funcDecl.name, funcDecl.returnType)
    }
    for (const funcDecl of functionDeclarations) {
      // Rename user's main() to @program_user to avoid conflict
      if (funcDecl.name === "main") {
        funcDecl.name = "program_user"
      }
      this.generateFunctionDeclaration(ir, funcDecl)
    }
    ir.push("")

    if (hasMain) {
      // User defined main() - generate wrapper at @main
      ir.push("; Main entry point (calls user's main)")
      
      const hasParams = mainFunc && mainFunc.params.length >= 2
      
      if (hasParams) {
        ir.push("define i32 @main(i32 %argc, ptr %argv) {")
        ir.push("entry:")
        ir.push("  call void @gc_init()")
        ir.push("  call void @gc_push_frame()")
        
        // Build array of length argc with argv pointers
        ir.push("  %args_array = call ptr @array_alloc(i64 8, i64 1, i64 %argc)")
        
        // Loop through argv and store pointers in array
        ir.push("  %args_array_data = getelementptr ptr, ptr %args_array, i64 0")
        
        // Process first 10 arguments (to keep code size reasonable)
        for (let i = 0; i < 10; i++) {
          ir.push(`  ; Process argv[${i}]`)
          ir.push(`  %argv_gep_${i} = getelementptr ptr, ptr %argv, i64 ${i}`)
          ir.push(`  %argv_ptr_${i} = load ptr, ptr %argv_gep_${i}`)
          ir.push(`  %in_bounds_${i} = icmp ult i64 ${i}, %argc`)
          ir.push(`  br i1 %in_bounds_${i}, label %store_argv_${i}, label %argv_done_${i}`)
          ir.push(`store_argv_${i}:`)
          ir.push(`  %array_gep_${i} = getelementptr i64, ptr %args_array_data, i64 ${i}`)
          ir.push(`  %argv_int_${i} = ptrtoint ptr %argv_ptr_${i} to i64`)
          ir.push(`  store i64 %argv_int_${i}, ptr %array_gep_${i}`)
          ir.push(`  br label %argv_done_${i}`)
          ir.push(`argv_done_${i}:`)
        }
        ir.push(`  ; Skip remaining argv elements (10..)`)
        
        // Create CLI args table (argc + args array)
        ir.push("  %cli_table = call ptr @map_new(i64 2)")
        ir.push("  %argc_key = alloca [5 x i8]")
        ir.push("  store [5 x i8] c\"argc\\00\", ptr %argc_key")
        ir.push("  call void @map_set(ptr %cli_table, ptr %argc_key, i64 4, i64 %argc)")
        
        ir.push("  %args_key = alloca [5 x i8]")
        ir.push("  store [5 x i8] c\"args\\00\", ptr %args_key")
        ir.push("  %args_int = ptrtoint ptr %args_array to i64")
        ir.push("  call void @map_set(ptr %cli_table, ptr %args_key, i64 4, i64 %args_int)")
        
        ir.push("  %cli_table_int = ptrtoint ptr %cli_table to i64")
        
        // Call user's main with CLI args table
        ir.push("  %result = call i64 @program_user(i64 %argc, i64 %cli_table_int)")
      } else {
        ir.push("define i32 @main(i32 %argc, ptr %argv) {")
        ir.push("entry:")
        ir.push("  call void @gc_init()")
        ir.push("  call void @gc_push_frame()")
        ir.push("  %result = call i64 @program_user()")
      }
      
      ir.push("  %truncated = trunc i64 %result to i32")
      ir.push("  call void @gc_pop_frame()")
      ir.push("  ret i32 %truncated")
      ir.push("}")
    } else {
      // No main() - use program() entry point
      this.resetValueCounter(10)
      
      ir.push("define void @program() {")
      ir.push("entry:")

      this.blockTerminated = false
      for (const statement of ast.statements) {
        this.generateStatement(ir, statement)
        if (this.blockTerminated) break
      }

      if (!this.blockTerminated) {
        ir.push("  ret void")
      }
      ir.push("}")

      this.setupMainFunction(ir)
    }

    this.generateRuntimeFunctions(ir)
    this.generatePOSIXDeclarations(ir)

    return ir.join("\n")
  }

  private collectFunctionDeclarations(ast: ProgramNode): any[] {
    const functions: any[] = []
    const declarations = this.findFunctionDeclarationsRecursive(ast.statements)
    functions.push(...declarations)
    return functions
  }

  private findFunctionDeclarationsRecursive(statements: any[]): any[] {
    const functions: any[] = []
    for (const stmt of statements) {
      if (stmt.type === "FunctionDeclaration") {
        functions.push(stmt)
        // Recursively find nested function declarations in the function body
        if (stmt.body?.statements) {
          functions.push(...this.findFunctionDeclarationsRecursive(stmt.body.statements))
        }
      } else if (stmt.type === "Block") {
        functions.push(...this.findFunctionDeclarationsRecursive(stmt.statements))
      }
    }
    return functions
  }

  private setupDeclarations(ir: string[]): void {
    ir.push("; Declare external LLM function")
    ir.push("declare ptr @llm_call(ptr %prompt, ptr %options, ptr %return_type)")
    ir.push("")

    ir.push("; Declare GC functions")
    ir.push("declare void @gc_init()")
    ir.push("declare ptr @gc_alloc(i64 %size)")
    ir.push("declare void @gc_collect()")
    ir.push("declare void @gc_push_frame()")
    ir.push("declare void @gc_pop_frame()")
    ir.push("declare void @gc_benchmark_stats()")
    ir.push("declare void @gc_reset_stats()")
    ir.push("")

    ir.push("; Declare array functions")
    ir.push("declare ptr @array_alloc(i64 %element_size, i64 %dimension_count, ptr %dimensions)")
    ir.push("declare i64 @array_get(ptr %array, i64 %index)")
    ir.push("declare void @array_set(ptr %array, i64 %index, i64 %value)")
    ir.push("declare float @array_get_f32(ptr %array, i64 %index)")
    ir.push("declare void @array_set_f32(ptr %array, i64 %index, float %value)")
    ir.push("declare double @array_get_f64(ptr %array, i64 %index)")
    ir.push("declare void @array_set_f64(ptr %array, i64 %index, double %value)")
    ir.push("declare i64 @array_length(ptr %array)")
    ir.push("declare ptr @array_slice(ptr %array, i64 %start, i64 %end)")
    ir.push("declare ptr @array_slice_step(ptr %array, i64 %start, i64 %end, i64 %step)")
    ir.push("declare float @dot_f32(ptr %a, ptr %b)")
    ir.push("declare double @dot_f64(ptr %a, ptr %b)")
    ir.push("declare ptr @matmul(ptr %a, ptr %b)")
    ir.push("declare ptr @matrix_add(ptr %a, ptr %b)")
    ir.push("")

    ir.push("; Declare map functions")
    ir.push("declare ptr @map_new(i64 %initial_capacity)")
    ir.push("declare i64 @map_get(ptr %map, ptr %key, i64 %key_len)")
    ir.push("declare void @map_set(ptr %map, ptr %key, i64 %key_len, i64 %value)")
    ir.push("")

    ir.push("; Declare string functions")
    ir.push("declare i64 @string_length(ptr %str)")
    ir.push("declare ptr @string_concat(ptr %a, ptr %b)")
    ir.push("declare ptr @string_char_at(ptr %str, i64 %index)")
    ir.push("declare ptr @string_slice(ptr %str, i64 %start, i64 %end)")
    ir.push("declare ptr @i64_to_string(i64 %value)")
    ir.push("declare ptr @u64_to_string(i64 %value)")
    ir.push("declare ptr @f64_to_string(double %value)")
    ir.push("")

    ir.push("; Declare CLI argument helper functions")
    ir.push("declare i64 @get_argc_value(ptr %cli_table)")
    ir.push("declare i64 @get_argv_value(ptr %cli_table, i64 %index)")
    ir.push("")
  }

  private generateStatement(ir: string[], statement: StatementNode): void {
    // Skip if current block is already terminated
    if (this.blockTerminated) {
      return
    }

    switch (statement.type) {
      case "VariableDeclaration": {
        const llvmType = this.toLLVMType(statement.varType)
        const reg = `%${statement.name}`
        const isPointerLike = statement.varType?.type === "ArrayType" || statement.varType?.type === "PointerType"
        const allocaType = isPointerLike ? "ptr" : llvmType
        ir.push(`  ${reg} = alloca ${allocaType}`)
        this.variableTypes.set(statement.name, statement.varType)
        if (statement.value) {
          const value = this.generateExpression(ir, statement.value)
          const isPointerLike = statement.varType?.type === "ArrayType" || statement.varType?.type === "PointerType"
          const storeType = isPointerLike ? "ptr" : llvmType
          ir.push(`  store ${storeType} ${value}, ptr ${reg}`)
        }
        break
      }
      case "Assignment": {
        const value = this.generateExpression(ir, statement.value)
        const varType = this.variableTypes.get(statement.name)
        const llvmType = this.toLLVMType(varType)
        ir.push(`  store ${llvmType} ${value}, ptr %${statement.name}`)
        break
      }
      case "ExpressionStatement":
        this.generateExpression(ir, statement.expression)
        break
      case "Block":
        this.blockTerminated = false
        for (const stmt of statement.statements) {
          this.generateStatement(ir, stmt)
          if (this.blockTerminated) break
        }
        break
      case "Return": {
        let value = null
        if (statement.value) {
          value = this.generateExpression(ir, statement.value)
        }
        ir.push("  call void @gc_pop_frame()")
        if (value) {
          const returnType = this.currentFunction?.returnType || "i64"
          ir.push(`  ret ${returnType} ${value}`)
        } else {
          ir.push(`  ret void`)
        }
        this.blockTerminated = true
        break
      }
      case "Conditional":
        this.generateConditional(ir, statement)
        break
      case "FunctionDeclaration":
        break
      case "WhileLoop":
        this.generateWhileLoop(ir, statement)
        break
      case "ForLoop":
        this.generateForLoop(ir, statement)
        break
      case "ForEachLoop":
        this.generateForEachLoop(ir, statement)
        break
      case "Break":
        this.generateBreak(ir)
        break
      case "Continue":
        this.generateContinue(ir)
        break
      default:
        break
    }
  }

  private generateExpression(ir: string[], expr: any): string {
    switch (expr.type) {
      case "AssignmentExpression":
        return this.generateAssignmentExpression(ir, expr)
      case "NumberLiteral": {
        // Handle float literals - convert to integer bit pattern for storage
        const val = String(expr.value)
        // Check if it's a float literal (has decimal point or exponent)
        const isFloat = val.includes(".") || val.toLowerCase().includes("e")
        if (isFloat) {
          const numVal = parseFloat(val)
          // Determine target float type from literalType annotation
          const floatKind = expr.literalType?.kind || "f64"
          // Convert to integer bit pattern (not hex float format)
          return this.floatToIntBits(numVal, floatKind)
        }
        // Integer literal - parse octal if needed
        let intVal: number
        if (val.startsWith("0") && val.length > 1) {
          intVal = parseInt(val, 8)
        } else {
          intVal = parseInt(val, 10)
        }
        return `${intVal}`
      }
      case "POSIXConstant":
        return `${expr.value}`
      case "StringLiteral": {
        const name = this.generateStringLiteral(ir, expr.value)
        const ptrReg = `%${this.valueCounter++}`
        ir.push(`  ${ptrReg} = getelementptr [${expr.value.length + 1} x i8], ptr ${name}, i64 0, i64 0`)
        return ptrReg
      }
      case "TemplateLiteral":
        return this.generateTemplateLiteral(ir, expr)
      case "Identifier": {
        const name = expr.name
        const ptrReg = `%${name}_local`
        const valReg = `%${this.valueCounter++}`

        const varType = this.variableTypes.get(name)
        const isPointerLike = varType?.type === "ArrayType" || varType?.type === "PointerType"

        // Determine LLVM type for loading
        let llvmLoadType = "i64"
        if (varType?.type === "FloatType") {
          llvmLoadType = this.toLLVMType(varType)
        }

        if (this.currentFunction && this.currentFunction.params.find((p) => p.name === name)) {
          if (isPointerLike) {
            const loaded = `%${this.valueCounter++}`
            ir.push(`  ${loaded} = load ptr, ptr ${ptrReg}`)
            return loaded
          }
          ir.push(`  ${valReg} = load ${llvmLoadType}, ptr ${ptrReg}`)
          return valReg
        }

        if (isPointerLike) {
          const loaded = `%${this.valueCounter++}`
          ir.push(`  ${loaded} = load ptr, ptr %${name}`)
          return loaded
        }

        ir.push(`  ${valReg} = load ${llvmLoadType}, ptr %${name}`)
        return valReg
      }
      case "BinaryExpression":
        return this.generateBinaryExpression(ir, expr)
      case "UnaryExpression":
        return this.generateUnaryExpression(ir, expr)
      case "CallExpression":
        return this.generateCallExpression(ir, expr)
      case "ArrayLiteral":
        return this.generateArrayLiteral(ir, expr)
      case "ArrayFill":
        return this.generateArrayFill(ir, expr)
      case "MapLiteral":
        return this.generateMapLiteral(ir, expr)
      case "MemberExpression":
        return this.generateMemberExpression(ir, expr)
      case "IndexExpression":
        return this.generateIndexExpression(ir, expr)
      case "SliceExpression":
        return this.generateSliceExpression(ir, expr)
      case "LLMCall":
        return this.generateLLMCall(ir, expr)
      case "MapExpression":
        return this.generateMapExpression(ir, expr)
      case "CastExpression":
        return this.generateCastExpression(ir, expr)
      default:
        return ""
    }
  }

  private generateStringLiteral(_ir: string[], value: string): string {
    // Strings are already collected and emitted, just return the name
    const name = `@str${this.stringCounter++}`
    return name
  }

  private collectStringFromNode(node: any): void {
    if (!node) return

    if (node.type === "StringLiteral") {
      const name = `@str${this.stringCounter++}`
      const escaped = node.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
      const strDef = `${name} = private unnamed_addr constant [${node.value.length + 1} x i8] c"${escaped}\\00"`
      this.stringConstants.push(strDef)
      return
    }

    // Collect strings from template literals
    if (node.type === "TemplateLiteral") {
      for (const part of node.parts) {
        if (typeof part === "string") {
          const name = `@str${this.stringCounter++}`
          const escaped = part.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
          const strDef = `${name} = private unnamed_addr constant [${part.length + 1} x i8] c"${escaped}\\00"`
          this.stringConstants.push(strDef)
        } else {
          this.collectStringFromNode(part)
        }
      }
      return
    }

    // Collect MemberExpression property names as string constants
    if (node.type === "MemberExpression") {
      const name = `@key_${node.property}_${this.stringCounter++}`
      const escaped = node.property.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
      const strDef = `${name} = private unnamed_addr constant [${node.property.length + 1} x i8] c"${escaped}\\00"`
      this.stringConstants.push(strDef)
    }

    // Recursively collect from child nodes
    for (const key in node) {
      if (key === 'position' || key.startsWith('_')) continue
      const value = node[key]
      if (Array.isArray(value)) {
        value.forEach(child => this.collectStringFromNode(child))
      } else if (typeof value === 'object' && value !== null) {
        this.collectStringFromNode(value)
      }
    }
  }

  private collectStringConstants(ast: any): void {
    this.collectStringFromNode(ast)
  }

  private inferExpressionType(expr: any): string {
    // Infer the type of an expression for template literal conversion
    switch (expr.type) {
      case "StringLiteral":
        return "string"
      case "NumberLiteral": {
        const val = String(expr.value)
        if (val.includes(".") || val.toLowerCase().includes("e")) {
          return "f64"
        }
        return "i64"
      }
      case "Identifier": {
        const varType = this.variableTypes.get(expr.name)
        if (varType?.type === "FloatType") return varType.kind || "f64"
        if (varType?.type === "IntegerType") return varType.kind || "i64"
        if (varType?.type === "UnsignedType") return varType.kind || "u64"
        if (varType?.type === "ArrayType") return "string" // [u8] strings
        return "i64" // default
      }
      case "BinaryExpression": {
        // For binary expressions, determine based on operands
        if (this.isFloatOperand(expr.left) || this.isFloatOperand(expr.right)) {
          return "f64"
        }
        return "i64"
      }
      case "CallExpression": {
        const funcName = expr.function?.name || expr.callee?.name
        if (funcName) {
          const func = this.functions.get(funcName)
          if (func) {
            if (func.returnType.startsWith("f")) return "f64"
            if (func.returnType === "ptr") return "string"
          }
        }
        return "i64"
      }
      default:
        return "i64"
    }
  }

  private generateTemplateLiteral(ir: string[], expr: any): string {
    const parts = expr.parts as (string | any)[]
    if (parts.length === 0) {
      // Empty string
      const name = this.generateStringLiteral(ir, "")
      const ptrReg = `%${this.valueCounter++}`
      ir.push(`  ${ptrReg} = getelementptr [1 x i8], ptr ${name}, i64 0, i64 0`)
      return ptrReg
    }

    // Collect all string parts into registers
    const partRegs: string[] = []
    for (const part of parts) {
      if (typeof part === "string") {
        // String literal part
        const name = this.generateStringLiteral(ir, part)
        const ptrReg = `%${this.valueCounter++}`
        ir.push(`  ${ptrReg} = getelementptr [${part.length + 1} x i8], ptr ${name}, i64 0, i64 0`)
        partRegs.push(ptrReg)
      } else {
        // Expression part - generate it and convert to string
        const exprReg = this.generateExpression(ir, part)
        const exprType = this.inferExpressionType(part)

        // Convert non-string expressions to strings
        if (exprType === "string") {
          partRegs.push(exprReg)
        } else if (exprType === "f64" || exprType === "f32" || exprType === "f16" || exprType === "f128") {
          // Float to string
          const convertReg = `%${this.valueCounter++}`
          ir.push(`  ${convertReg} = call ptr @f64_to_string(double ${exprReg})`)
          partRegs.push(convertReg)
        } else if (exprType.startsWith("u")) {
          // Unsigned to string
          const convertReg = `%${this.valueCounter++}`
          ir.push(`  ${convertReg} = call ptr @u64_to_string(i64 ${exprReg})`)
          partRegs.push(convertReg)
        } else {
          // Signed integer to string
          const convertReg = `%${this.valueCounter++}`
          ir.push(`  ${convertReg} = call ptr @i64_to_string(i64 ${exprReg})`)
          partRegs.push(convertReg)
        }
      }
    }

    // Concatenate all parts using string_concat
    let result = partRegs[0]
    for (let i = 1; i < partRegs.length; i++) {
      const concatResult = `%${this.valueCounter++}`
      ir.push(`  ${concatResult} = call ptr @string_concat(ptr ${result}, ptr ${partRegs[i]})`)
      result = concatResult
    }

    return result
  }

  private generateBinaryExpression(ir: string[], expr: any): string {
    const left = this.generateExpression(ir, expr.left)
    const right = this.generateExpression(ir, expr.right)
    const reg = `%${this.valueCounter++}`

    // Handle logical operators specially - they work on i1 but we store as i64
    if (expr.operator === "&&" || expr.operator === "||") {
      // Convert operands to i1 (compare with 0), do logical op, then extend to i64
      const leftBool = `%${this.valueCounter++}`
      const rightBool = `%${this.valueCounter++}`
      ir.push(`  ${leftBool} = icmp ne i64 ${left}, 0`)
      ir.push(`  ${rightBool} = icmp ne i64 ${right}, 0`)
      const boolReg = `%${this.valueCounter++}`
      const logicOp = expr.operator === "&&" ? "and" : "or"
      ir.push(`  ${boolReg} = ${logicOp} i1 ${leftBool}, ${rightBool}`)
      const extReg = `%${this.valueCounter++}`
      ir.push(`  ${extReg} = zext i1 ${boolReg} to i64`)
      return extReg
    }

    // Check for matrix operations - both operands are 2D arrays
    if (this.isMatrixOperation(expr.left, expr.right)) {
      if (expr.operator === "*") {
        return this.generateMatrixMultiplication(ir, left, right)
      } else if (expr.operator === "+") {
        return this.generateMatrixAddition(ir, left, right)
      }
    }

    // Check for vector operations - at least one operand is an array
    if (this.isVectorOperation(expr.left, expr.right)) {
      return this.generateVectorOperation(ir, expr, left, right)
    }

    const opMap: Record<string, string[]> = {
      "+": ["add i64", "fadd"],
      "-": ["sub i64", "fsub"],
      "*": ["mul i64", "fmul"],
      "/": ["sdiv i64", "fdiv"],
      "%": ["srem i64", "frem"],
      "|": ["or i64", "or"],
      "&": ["and i64", "and"],
      "^": ["xor i64", "xor"],
      "<<": ["shl i64", "shl"],
      ">>": ["ashr i64", "ashr"],
    }

    // Comparison operators return i1, need to extend to i64
    const cmpMap: Record<string, string[]> = {
      "<": ["icmp slt i64", "fcmp olt"],
      ">": ["icmp sgt i64", "fcmp ogt"],
      "<=": ["icmp sle i64", "fcmp ole"],
      ">=": ["icmp sge i64", "fcmp oge"],
      "=": ["icmp eq i64", "fcmp oeq"],
      "==": ["icmp eq i64", "fcmp oeq"],
      "!=": ["icmp ne i64", "fcmp one"],
    }

    // Determine if operation is float-based by checking operand types
    const isFloat = this.isFloatOperand(expr.left) || this.isFloatOperand(expr.right)

    if (cmpMap[expr.operator]) {
      const [intOp, floatOp] = cmpMap[expr.operator]
      const floatType = isFloat ? this.getFloatTypeSize(expr) : "float"
      const cmpOp = isFloat ? `${floatOp} ${floatType} ${left}, ${right}` : `${intOp} ${left}, ${right}`
      const boolReg = `%${this.valueCounter++}`
      ir.push(`  ${boolReg} = ${cmpOp}`)
      const extReg = `%${this.valueCounter++}`
      ir.push(`  ${extReg} = zext i1 ${boolReg} to i64`)
      return extReg
    }

    const [intOp, floatOp] = opMap[expr.operator]
    if (isFloat) {
      const floatType = this.getFloatTypeSize(expr)
      ir.push(`  ${reg} = ${floatOp} ${floatType} ${left}, ${right}`)
    } else {
      ir.push(`  ${reg} = ${intOp} ${left}, ${right}`)
    }

    return reg
  }

  private isVectorOperation(leftExpr: any, rightExpr: any): boolean {
    // Check if at least one operand is an array type
    const leftArrayType = this.getExpressionArrayType(leftExpr)
    const rightArrayType = this.getExpressionArrayType(rightExpr)
    return leftArrayType !== null || rightArrayType !== null
  }

  private getExpressionArrayType(expr: any): any {
    if (!expr) return null

    // Check if the expression is an identifier with array type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "ArrayType") {
        return varType
      }
    }

    // Check if the expression itself has a resultType
    if (expr.resultType?.type === "ArrayType") {
      return expr.resultType
    }

    return null
  }

  private generateVectorOperation(ir: string[], expr: any, leftReg: string, rightReg: string): string {
    // Get element types for both operands
    const leftArrayType = this.getExpressionArrayType(expr.left)
    const rightArrayType = this.getExpressionArrayType(expr.right)

    // Determine which operand is the array and which is the scalar
    const isLeftArray = leftArrayType !== null
    const isRightArray = rightArrayType !== null

    if (!isLeftArray && !isRightArray) {
      throw new Error("Invalid vector operation: at least one operand must be an array")
    }

    // Use the array's element type
    const elementType = (leftArrayType || rightArrayType).elementType
    const isFloat = elementType?.type === "FloatType"
    const floatKind = isFloat ? elementType.kind : null

    // Get array length from the array operand
    const arrayReg = isLeftArray ? leftReg : rightReg
    const lenReg = `%${this.valueCounter++}`
    ir.push(`  ${lenReg} = call i64 @array_length(ptr ${arrayReg})`)

    // Allocate result array
    const dimensionsReg = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsReg} = alloca [1 x i64]`)
    const dimensionsPtr = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsPtr} = getelementptr [1 x i64], ptr ${dimensionsReg}, i64 0, i64 0`)
    ir.push(`  store i64 ${lenReg}, ptr ${dimensionsPtr}`)

    const elementSize = floatKind === "f64" ? 8 : floatKind === "f32" ? 4 : 8
    const resultReg = `%${this.valueCounter++}`
    ir.push(`  ${resultReg} = call ptr @array_alloc(i64 ${elementSize}, i64 1, ptr ${dimensionsReg})`)

    // Generate loop
    const loopStartLabel = `vec_loop_start_${this.labelCounter++}`
    const loopBodyLabel = `vec_loop_body_${this.labelCounter++}`
    const loopEndLabel = `vec_loop_end_${this.labelCounter++}`

    // Loop counter
    const counterReg = `%${this.valueCounter++}`
    ir.push(`  ${counterReg} = alloca i64`)
    ir.push(`  store i64 0, ptr ${counterReg}`)

    // Jump to loop start
    ir.push(`  br label %${loopStartLabel}`)

    // Loop start: check condition
    ir.push(`${loopStartLabel}:`)
    const currentCount = `%${this.valueCounter++}`
    ir.push(`  ${currentCount} = load i64, ptr ${counterReg}`)
    const cmpReg = `%${this.valueCounter++}`
    ir.push(`  ${cmpReg} = icmp slt i64 ${currentCount}, ${lenReg}`)
    ir.push(`  br i1 ${cmpReg}, label %${loopBodyLabel}, label %${loopEndLabel}`)

    // Loop body
    ir.push(`${loopBodyLabel}:`)

    // Get elements - one from array, one may be scalar
    let elem1Reg: string, elem2Reg: string

    if (floatKind === "f32") {
      if (isLeftArray) {
        elem1Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem1Reg} = call float @array_get_f32(ptr ${leftReg}, i64 ${currentCount})`)
      } else {
        // Left is scalar - bitcast i64 to float (IEEE 754 representation)
        const tempReg = `%${this.valueCounter++}`
        ir.push(`  ${tempReg} = trunc i64 ${leftReg} to i32`)
        elem1Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem1Reg} = bitcast i32 ${tempReg} to float`)
      }
      if (isRightArray) {
        elem2Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem2Reg} = call float @array_get_f32(ptr ${rightReg}, i64 ${currentCount})`)
      } else {
        // Right is scalar - bitcast i64 to float (IEEE 754 representation)
        const tempReg = `%${this.valueCounter++}`
        ir.push(`  ${tempReg} = trunc i64 ${rightReg} to i32`)
        elem2Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem2Reg} = bitcast i32 ${tempReg} to float`)
      }
    } else if (floatKind === "f64") {
      if (isLeftArray) {
        elem1Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem1Reg} = call double @array_get_f64(ptr ${leftReg}, i64 ${currentCount})`)
      } else {
        // Left is scalar - convert i64 bit pattern to double
        // Store the i64 bit pattern to memory, then load as double
        const tempPtr = `%${this.valueCounter++}`
        ir.push(`  ${tempPtr} = alloca i64`)
        ir.push(`  store i64 ${leftReg}, ptr ${tempPtr}`)
        const doublePtr = `%${this.valueCounter++}`
        ir.push(`  ${doublePtr} = bitcast ptr ${tempPtr} to ptr`)
        elem1Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem1Reg} = load double, ptr ${doublePtr}`)
      }
      if (isRightArray) {
        elem2Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem2Reg} = call double @array_get_f64(ptr ${rightReg}, i64 ${currentCount})`)
      } else {
        // Right is scalar - convert i64 bit pattern to double
        const tempPtr = `%${this.valueCounter++}`
        ir.push(`  ${tempPtr} = alloca i64`)
        ir.push(`  store i64 ${rightReg}, ptr ${tempPtr}`)
        const doublePtr = `%${this.valueCounter++}`
        ir.push(`  ${doublePtr} = bitcast ptr ${tempPtr} to ptr`)
        elem2Reg = `%${this.valueCounter++}`
        ir.push(`  ${elem2Reg} = load double, ptr ${doublePtr}`)
      }
    } else {
      if (isLeftArray) {
        const e1 = `%${this.valueCounter++}`
        ir.push(`  ${e1} = call i64 @array_get(ptr ${leftReg}, i64 ${currentCount})`)
        elem1Reg = e1
      } else {
        elem1Reg = leftReg
      }
      if (isRightArray) {
        const e2 = `%${this.valueCounter++}`
        ir.push(`  ${e2} = call i64 @array_get(ptr ${rightReg}, i64 ${currentCount})`)
        elem2Reg = e2
      } else {
        elem2Reg = rightReg
      }
    }

    // Apply operation
    const resultElemReg = `%${this.valueCounter++}`
    const op = expr.operator

    if (floatKind === "f32") {
      const opMap: Record<string, string> = { "+": "fadd", "-": "fsub", "*": "fmul", "/": "fdiv" }
      const floatOp = opMap[op] || "fadd"
      ir.push(`  ${resultElemReg} = ${floatOp} float ${elem1Reg}, ${elem2Reg}`)
    } else if (floatKind === "f64") {
      const opMap: Record<string, string> = { "+": "fadd", "-": "fsub", "*": "fmul", "/": "fdiv" }
      const floatOp = opMap[op] || "fadd"
      ir.push(`  ${resultElemReg} = ${floatOp} double ${elem1Reg}, ${elem2Reg}`)
    } else {
      const opMap: Record<string, string> = { "+": "add i64", "-": "sub i64", "*": "mul i64", "/": "sdiv i64" }
      const intOp = opMap[op] || "add i64"
      ir.push(`  ${resultElemReg} = ${intOp} ${elem1Reg}, ${elem2Reg}`)
    }

    // Store result
    if (floatKind === "f32") {
      ir.push(`  call void @array_set_f32(ptr ${resultReg}, i64 ${currentCount}, float ${resultElemReg})`)
    } else if (floatKind === "f64") {
      ir.push(`  call void @array_set_f64(ptr ${resultReg}, i64 ${currentCount}, double ${resultElemReg})`)
    } else {
      ir.push(`  call void @array_set(ptr ${resultReg}, i64 ${currentCount}, i64 ${resultElemReg})`)
    }

    // Increment counter
    const nextCount = `%${this.valueCounter++}`
    ir.push(`  ${nextCount} = add i64 ${currentCount}, 1`)
    ir.push(`  store i64 ${nextCount}, ptr ${counterReg}`)

    // Jump back to start
    ir.push(`  br label %${loopStartLabel}`)

    // Loop end
    ir.push(`${loopEndLabel}:`)

    return resultReg
  }

  private isMatrixOperation(leftExpr: any, rightExpr: any): boolean {
    // Check if BOTH operands are 2D arrays (matrices)
    const leftArrayType = this.getExpressionArrayType(leftExpr)
    const rightArrayType = this.getExpressionArrayType(rightExpr)

    if (!leftArrayType || !rightArrayType) return false

    // Check if both are 2D (have 2 dimensions)
    const leftDims = leftExpr?.type === "Identifier" && leftExpr?.name
      ? this.variableTypes.get(leftExpr.name)?.dimensions?.length || leftArrayType.dimensions?.length
      : leftArrayType.dimensions?.length
    const rightDims = rightExpr?.type === "Identifier" && rightExpr?.name
      ? this.variableTypes.get(rightExpr.name)?.dimensions?.length || rightArrayType.dimensions?.length
      : rightArrayType.dimensions?.length

    // Treat as matrix if both have 2 dimensions
    return leftDims === 2 && rightDims === 2
  }

  private generateMatrixMultiplication(ir: string[], leftReg: string, rightReg: string): string {
    const resultReg = `%${this.valueCounter++}`
    ir.push(`  ${resultReg} = call ptr @matmul(ptr ${leftReg}, ptr ${rightReg})`)
    return resultReg
  }

  private generateMatrixAddition(ir: string[], leftReg: string, rightReg: string): string {
    const resultReg = `%${this.valueCounter++}`
    ir.push(`  ${resultReg} = call ptr @matrix_add(ptr ${leftReg}, ptr ${rightReg})`)
    return resultReg
  }

  private generateUnaryExpression(ir: string[], expr: any): string {
    const argument = expr.argument || expr.operand
    const value = this.generateExpression(ir, argument)
    const reg = `%${this.valueCounter++}`

    if (expr.operator === "-") {
      ir.push(`  ${reg} = sub i64 0, ${value}`)
    } else if (expr.operator === "!") {
      ir.push(`  ${reg} = xor i64 ${value}, 1`)
    } else if (expr.operator === "~") {
      ir.push(`  ${reg} = xor i64 ${value}, -1`)
    }

    return reg
  }

  private generateCallExpression(ir: string[], expr: any): string {
    const args = (expr.args || expr.arguments || []).map((arg: ExpressionNode) => this.generateExpression(ir, arg)).filter(Boolean)

    if (expr.callee.type === "Identifier") {
      const funcName = expr.callee.name

      // Handle print functions
      const printFunctions = ["print", "print_i64", "print_u64", "print_f64", "print_string",
                              "println", "println_i64", "println_u64", "println_f64", "println_string"]
      if (printFunctions.includes(funcName)) {
        return this.generatePrintCall(ir, funcName, args, expr)
      }

      // Handle input functions
      const inputFunctions = ["input_i64", "input_u64", "input_f64", "input_string"]
      if (inputFunctions.includes(funcName)) {
        return this.generateInputCall(ir, funcName)
      }

      // Handle dot product function
      if (funcName === "dot") {
        return this.generateDotCall(ir, expr, args)
      }

      // Handle matmul function
      if (funcName === "matmul") {
        return this.generateMatmulCall(ir, expr, args)
      }

      // Handle GC benchmark functions
      const gcBenchmarkFunctions = ["gc_reset_stats", "gc_benchmark_stats"]
      if (gcBenchmarkFunctions.includes(funcName)) {
        ir.push(`  call void @${funcName}()`)
        return "0"
      }

      const funcInfo = this.functions.get(funcName)

      // POSIX function signatures for proper argument typing
      const posixSignatures: Record<string, string[]> = {
        open: ["ptr", "i64"],  // variadic: may have mode
        read: ["i64", "ptr", "i64"],
        write: ["i64", "ptr", "i64"],
        pread: ["i64", "ptr", "i64", "i64"],
        pwrite: ["i64", "ptr", "i64", "i64"],
        lseek: ["i64", "i64", "i64"],
        close: ["i64"],
        fsync: ["i64"],
        fdatasync: ["i64"],
        stat: ["ptr", "ptr"],
        lstat: ["ptr", "ptr"],
        fstat: ["i64", "ptr"],
        access: ["ptr", "i64"],
        faccessat: ["i64", "ptr", "i64", "i64"],
        utimes: ["ptr", "ptr"],
        futimes: ["i64", "ptr"],
        utimensat: ["i64", "ptr", "ptr", "i64"],
        chmod: ["ptr", "i64"],
        fchmod: ["i64", "i64"],
        chown: ["ptr", "i64", "i64"],
        fchown: ["i64", "i64", "i64"],
        umask: ["i64"],
        truncate: ["ptr", "i64"],
        ftruncate: ["i64", "i64"],
        link: ["ptr", "ptr"],
        symlink: ["ptr", "ptr"],
        readlink: ["ptr", "ptr", "i64"],
        rename: ["ptr", "ptr"],
        unlink: ["ptr"],
        mkdir: ["ptr", "i64"],
        rmdir: ["ptr"],
        fcntl: ["i64", "i64"],  // variadic
        pathconf: ["ptr", "i64"],
        fpathconf: ["i64", "i64"],
        dup: ["i64"],
        dup2: ["i64", "i64"],
        creat: ["ptr", "i64"],
        mkfifo: ["ptr", "i64"],
        mknod: ["ptr", "i64", "i64"],  // variadic
        chdir: ["ptr"],
        fchdir: ["i64"],
        getcwd: ["ptr", "i64"],
        opendir: ["ptr"],
        readdir: ["ptr"],
        closedir: ["ptr"],
        rewinddir: ["ptr"],
      }

      const runtimeSignatures: Record<string, { params: string[]; ret: string }> = {
        map_new: { params: ["i64"], ret: "ptr" },
        map_get: { params: ["ptr", "ptr", "i64"], ret: "i64" },
        map_set: { params: ["ptr", "ptr", "i64", "i64"], ret: "void" },
        string_length: { params: ["ptr"], ret: "i64" },
        string_concat: { params: ["ptr", "ptr"], ret: "ptr" },
      }

      const sig = posixSignatures[funcName]
      const isVariadic = ["open", "fcntl", "mknod"].includes(funcName)

      // POSIX functions that return ptr instead of i64
      const posixReturnTypes: Record<string, string> = {
        opendir: "ptr",
        readdir: "ptr",
      }

      let typedArgs: string[]
      if (funcInfo && funcInfo.params) {
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = funcInfo.params[i]?.type || "i64"
          return `${paramType} ${arg}`
        })
      } else if (sig) {
        // Use POSIX signature for typing
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = sig[i] || "i64"
          return `${paramType} ${arg}`
        })
      } else if (runtimeSignatures[funcName]) {
        const sig = runtimeSignatures[funcName]
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = sig.params[i] || "i64"
          return `${paramType} ${arg}`
        })
        const returnType = sig.ret
        const reg = returnType === "void" ? null : `%${this.valueCounter++}`
        if (reg) {
          ir.push(`  ${reg} = call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
        } else {
          ir.push(`  call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
        }
        return reg || ""
      } else if (isVariadic) {
        // For variadic functions without sig, type first 2 args, rest as i64
        typedArgs = args.map((arg: string, i: number) => {
          if (i === 0) return `ptr ${arg}`
          return `i64 ${arg}`
        })
      } else {
        typedArgs = args
      }

      const reg = `%${this.valueCounter++}`
      const returnType = funcInfo?.returnType || posixReturnTypes[funcName] || "i64"
      ir.push(`  ${reg} = call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
      return reg
    }

    return ""
  }

  private generateInputCall(ir: string[], funcName: string): string {
    const reg = `%${this.valueCounter++}`

    switch (funcName) {
      case "input_i64":
      case "input_u64":
        ir.push(`  ${reg} = call i64 @${funcName}()`)
        return reg
      case "input_f64":
        ir.push(`  ${reg} = call double @${funcName}()`)
        return reg
      case "input_string":
        ir.push(`  ${reg} = call ptr @${funcName}()`)
        return reg
      default:
        return ""
    }
  }

  private generateDotCall(ir: string[], expr: any, args: string[]): string {
    // Get the argument nodes to determine element type
    const arg0 = expr.args?.[0] || expr.arguments?.[0]

    // Determine element type from first argument
    let elementType = "f64" // default
    const argType = arg0?.resultType
    if (argType?.elementType?.type === "FloatType" && argType?.elementType?.precision === 32) {
      elementType = "f32"
    }

    const reg = `%${this.valueCounter++}`
    if (elementType === "f32") {
      ir.push(`  ${reg} = call float @dot_f32(ptr ${args[0]}, ptr ${args[1]})`)
    } else {
      ir.push(`  ${reg} = call double @dot_f64(ptr ${args[0]}, ptr ${args[1]})`)
    }
    return reg
  }

  private generateMatmulCall(ir: string[], expr: any, args: string[]): string {
    // matmul takes two arrays and returns a new array (result of matrix multiplication)
    // Both arguments should be arrays
    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call ptr @matmul(ptr ${args[0]}, ptr ${args[1]})`)
    return reg
  }

  private generatePrintCall(ir: string[], funcName: string, args: string[], expr: any): string {
    // Handle println with no arguments (just newline)
    if (funcName === "println" && args.length === 0) {
      ir.push(`  call void @println()`)
      return ""
    }

    if (args.length === 0) {
      return ""
    }

    // Determine the actual function to call based on argument type
    const arg = expr.args?.[0] || expr.arguments?.[0]
    let actualFunc = funcName

    // Determine argument type - try resultType first, then check function calls, then variableTypes
    let argType = arg?.resultType?.type
    if (!argType && arg?.type === "Identifier") {
      const varType = this.variableTypes.get(arg.name)
      argType = varType?.type
    }
    if (!argType && arg?.type === "CallExpression" && arg?.callee?.type === "Identifier") {
      // Check if this is a call to a user-defined function and get its return type
      const funcName = arg.callee.name
      const funcType = this.functionTypes.get(funcName)
      if (funcType) {
        argType = funcType.type
      }
    }
    argType = argType || "IntegerType"

    // If generic print/println, determine specific version based on type
    if (funcName === "print" || funcName === "println") {
      if (argType === "FloatType") {
        actualFunc = funcName === "print" ? "print_f64" : "println_f64"
      } else if (argType === "UnsignedType") {
        actualFunc = funcName === "print" ? "print_u64" : "println_u64"
      } else if (argType === "ArrayType") {
        actualFunc = funcName === "print" ? "print_string" : "println_string"
      } else {
        actualFunc = funcName === "print" ? "print_i64" : "println_i64"
      }
    }

    // Generate call with appropriate type
    if (argType === "FloatType") {
      ir.push(`  call void @${actualFunc}(double ${args[0]})`)
    } else if (argType === "ArrayType") {
      ir.push(`  call void @${actualFunc}(ptr ${args[0]})`)
    } else {
      ir.push(`  call void @${actualFunc}(i64 ${args[0]})`)
    }
    return ""
  }

  private generateAssignmentExpression(ir: string[], expr: any): string {
    const { name, target, value } = expr
    const valueReg = this.generateExpression(ir, value)
    
    if (target && target.type === "IndexExpression") {
      const obj = this.generateExpression(ir, target.object)
      const index = this.generateExpression(ir, target.index)

      // Check if this is a table assignment (table[key] = value)
      if (this.isMapType(target.object)) {
        // Table assignment: table[key] := value
        // The index is the key - could be string or integer
        const keyExpr = target.index
        let keyPtr: string
        let keyLen: string

        if (keyExpr.type === "StringLiteral") {
          // String key: use string literal directly
          const escaped = keyExpr.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
          keyPtr = `@key_str_${this.stringCounter++}`
          const strDef = `${keyPtr} = private unnamed_addr constant [${keyExpr.value.length + 1} x i8] c"${escaped}\\00"`
          this.stringConstants.push(strDef)
          keyLen = String(keyExpr.value.length)
        } else if (keyExpr.type === "Identifier") {
          // Variable key - assume it's a string, use strlen to get length
          const keyVar = this.generateExpression(ir, keyExpr)
          keyPtr = keyVar
          const lenReg = `%${this.valueCounter++}`
          ir.push(`  ${lenReg} = call i64 @string_length(ptr ${keyVar})`)
          keyLen = lenReg
        } else if (keyExpr.type === "IntegerLiteral" || keyExpr.type === "NumberLiteral") {
          // Integer key: store to memory and pass as ptr
          const keyVal = keyExpr.value !== undefined ? keyExpr.value : index
          keyPtr = `%${this.valueCounter++}`
          ir.push(`  ${keyPtr} = alloca i64`)
          ir.push(`  store i64 ${keyVal}, ptr ${keyPtr}`)
          keyLen = "8" // i64 is 8 bytes
        } else {
          // Expression key: evaluate and use as string
          keyPtr = index
          const lenReg = `%${this.valueCounter++}`
          ir.push(`  ${lenReg} = call i64 @string_length(ptr ${index})`)
          keyLen = lenReg
        }

        ir.push(`  call void @map_set(ptr ${obj}, ptr ${keyPtr}, i64 ${keyLen}, i64 ${valueReg})`)
      } else {
        // Array assignment: array[index] := value
        // Handle nested array access
        const isNestedIndex = target.object?.type === "IndexExpression"
        let arrayPtr = obj
        if (isNestedIndex) {
          const r = `%${this.valueCounter++}`
          ir.push(`  ${r} = inttoptr i64 ${obj} to ptr`)
          arrayPtr = r
        }

        // Determine element type to use appropriate setter
        const elementType = this.getArrayElementType(target.object)

        // Emit bounds check elision hint in release mode for AoS/SoA operations
        if (this.shouldElideBoundsCheck()) {
          ir.push(`  ; BOUNDS_CHECK_ELIDED: release mode optimization`)
        }

        if (elementType?.type === "FloatType") {
          if (elementType.kind === "f32") {
            // Convert i64 value to float
            const floatReg = `%${this.valueCounter++}`
            ir.push(`  ${floatReg} = uitofp i64 ${valueReg} to float`)
            ir.push(`  call void @array_set_f32(ptr ${arrayPtr}, i64 ${index}, float ${floatReg})`)
          } else if (elementType.kind === "f64") {
            // Convert i64 value to double
            const doubleReg = `%${this.valueCounter++}`
            ir.push(`  ${doubleReg} = uitofp i64 ${valueReg} to double`)
            ir.push(`  call void @array_set_f64(ptr ${arrayPtr}, i64 ${index}, double ${doubleReg})`)
          } else {
            ir.push(`  call void @array_set(ptr ${arrayPtr}, i64 ${index}, i64 ${valueReg})`)
          }
        } else {
          ir.push(`  call void @array_set(ptr ${arrayPtr}, i64 ${index}, i64 ${valueReg})`)
        }
      }
    } else if (target && target.type === "MemberExpression") {
      // Table member assignment: person.age := 31
      const obj = this.generateExpression(ir, target.object)
      // Generate the key string constant
      const keyName = `@key_${target.property}_${this.stringCounter++}`
      const escaped = target.property.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
      const strDef = `${keyName} = private unnamed_addr constant [${target.property.length + 1} x i8] c"${escaped}\\00"`
      this.stringConstants.push(strDef)
      // obj is already a ptr for tables
      ir.push(`  call void @map_set(ptr ${obj}, ptr ${keyName}, i64 ${target.property.length}, i64 ${valueReg})`)
    } else {
      const varType = this.variableTypes.get(name)
      const llvmType = this.toLLVMType(varType)
      ir.push(`  store ${llvmType} ${valueReg}, ptr %${name}`)
    }
    
    return valueReg
  }

  private generateArrayLiteral(ir: string[], expr: any): string {
    const size = expr.elements.length || 0
    const dimensionsReg = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsReg} = alloca [1 x i64]`)
    const dimensionsPtr = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsPtr} = getelementptr [1 x i64], ptr ${dimensionsReg}, i64 0, i64 0`)
    ir.push(`  store i64 ${size}, ptr ${dimensionsPtr}`)

    // Determine element type from the array literal's resultType
    const elementType = expr.resultType?.elementType
    let elementSize = 8 // default to 8 bytes for i64
    if (elementType?.type === "FloatType") {
      elementSize = elementType.kind === "f64" ? 8 : 4
    }

    const elementReg = `%${this.valueCounter++}`
    ir.push(`  ${elementReg} = call ptr @array_alloc(i64 ${elementSize}, i64 1, ptr ${dimensionsReg})`)

    for (let i = 0; i < expr.elements.length; i++) {
      const elemExpr = expr.elements[i]
      if (elementType?.type === "FloatType") {
        // Handle float elements directly
        const val = String(elemExpr.value)
        const numVal = parseFloat(val)
        if (elementType.kind === "f32") {
          // Generate float constant as decimal - ensure it has a decimal point
          const floatLit = val.includes('.') ? val : val + '.0'
          ir.push(`  call void @array_set_f32(ptr ${elementReg}, i64 ${i}, float ${floatLit})`)
        } else if (elementType.kind === "f64") {
          // Generate double constant as decimal - ensure it has a decimal point
          const doubleLit = val.includes('.') ? val : val + '.0'
          ir.push(`  call void @array_set_f64(ptr ${elementReg}, i64 ${i}, double ${doubleLit})`)
        } else {
          const value = this.generateExpression(ir, elemExpr)
          ir.push(`  call void @array_set(ptr ${elementReg}, i64 ${i}, i64 ${value})`)
        }
      } else {
        const value = this.generateExpression(ir, elemExpr)
        if (value) {
          // Check if value is a pointer (nested array) and convert to i64
          const valueToStore = value.includes('ptr') || value.startsWith('%') && !value.includes('i64')
            ? (() => { const r = `%${this.valueCounter++}`; ir.push(`  ${r} = ptrtoint ptr ${value} to i64`); return r; })()
            : value
          ir.push(`  call void @array_set(ptr ${elementReg}, i64 ${i}, i64 ${valueToStore})`)
        }
      }
    }

    return elementReg
  }

  private generateArrayFill(ir: string[], expr: any): string {
    // Generate array filled with repeated value: [value; count]
    const countExpr = expr.count
    const valueExpr = expr.value

    // Get element type from resultType
    const elementType = expr.resultType?.elementType
    let elementSize = 8 // default to 8 bytes for i64
    if (elementType?.type === "FloatType") {
      elementSize = elementType.kind === "f64" ? 8 : 4
    }

    // Determine count - try to get compile-time constant
    let countValue: number | null = null
    if (countExpr.type === "NumberLiteral" || countExpr.type === "IntegerLiteral") {
      countValue = parseInt(countExpr.value)
    }

    // Allocate array with the specified count
    const countReg = `%${this.valueCounter++}`
    if (countValue !== null) {
      ir.push(`  ${countReg} = alloca [1 x i64]`)
      const countPtr = `%${this.valueCounter++}`
      ir.push(`  ${countPtr} = getelementptr [1 x i64], ptr ${countReg}, i64 0, i64 0`)
      ir.push(`  store i64 ${countValue}, ptr ${countPtr}`)
    } else {
      // Runtime count
      const runtimeCount = this.generateExpression(ir, countExpr)
      ir.push(`  ${countReg} = alloca [1 x i64]`)
      const countPtr = `%${this.valueCounter++}`
      ir.push(`  ${countPtr} = getelementptr [1 x i64], ptr ${countReg}, i64 0, i64 0`)
      ir.push(`  store i64 ${runtimeCount}, ptr ${countPtr}`)
    }

    const elementReg = `%${this.valueCounter++}`
    ir.push(`  ${elementReg} = call ptr @array_alloc(i64 ${elementSize}, i64 1, ptr ${countReg})`)

    // Fill the array with the value
    const value = this.generateExpression(ir, valueExpr)

    // Loop to fill array
    const loopStartLabel = this.nextLabel()
    const loopBodyLabel = this.nextLabel()
    const loopEndLabel = this.nextLabel()

    const iReg = `%${this.valueCounter++}`
    ir.push(`  ${iReg} = alloca i64`)
    ir.push(`  store i64 0, ptr ${iReg}`)

    ir.push(`${loopStartLabel}:`)
    const currentI = `%${this.valueCounter++}`
    ir.push(`  ${currentI} = load i64, ptr ${iReg}`)
    const cmpResult = `%${this.valueCounter++}`
    if (countValue !== null) {
      ir.push(`  ${cmpResult} = icmp slt i64 ${currentI}, i64 ${countValue}`)
    } else {
      const runtimeCount = this.generateExpression(ir, countExpr)
      ir.push(`  ${cmpResult} = icmp slt i64 ${currentI}, i64 ${runtimeCount}`)
    }
    ir.push(`  br i1 ${cmpResult}, label %${loopBodyLabel}, label %${loopEndLabel}`)

    ir.push(`${loopBodyLabel}:`)

    // Store value at current index
    if (elementType?.type === "FloatType") {
      if (elementType.kind === "f32") {
        ir.push(`  call void @array_set_f32(ptr ${elementReg}, i64 ${currentI}, float ${value})`)
      } else {
        ir.push(`  call void @array_set_f64(ptr ${elementReg}, i64 ${currentI}, double ${value})`)
      }
    } else {
      ir.push(`  call void @array_set(ptr ${elementReg}, i64 ${currentI}, i64 ${value})`)
    }

    // Increment counter
    const nextI = `%${this.valueCounter++}`
    ir.push(`  ${nextI} = add i64 ${currentI}, 1`)
    ir.push(`  store i64 ${nextI}, ptr ${iReg}`)
    ir.push(`  br label %${loopStartLabel}`)

    ir.push(`${loopEndLabel}:`)

    return elementReg
  }

  private generateMapLiteral(ir: string[], expr: any): string {
    const tableReg = `%${this.valueCounter++}`
    const capacity = expr.columns.length > 0 ? expr.columns.length * 2 : 4
    ir.push(`  ${tableReg} = call ptr @map_new(i64 ${capacity})`)

    for (const col of expr.columns) {
      const key = col.name
      const value = col.values[0]
      const keyStr = this.generateStringLiteral(ir, key)
      const valueReg = this.generateExpression(ir, value)
      if (valueReg) {
        ir.push(`  call void @map_set(ptr ${tableReg}, ptr ${keyStr}, i64 ${key.length}, i64 ${valueReg})`)
      }
    }

    return tableReg
  }

  private generateMemberExpression(ir: string[], expr: any): string {
    const obj = this.generateExpression(ir, expr.object)
    // Generate the key string constant
    const keyName = `@key_${expr.property}_${this.stringCounter++}`
    const escaped = expr.property.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
    const strDef = `${keyName} = private unnamed_addr constant [${expr.property.length + 1} x i8] c"${escaped}\\00"`
    this.stringConstants.push(strDef)
    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call i64 @map_get(ptr ${obj}, ptr ${keyName}, i64 ${expr.property.length})`)
    return reg
  }

  private generateIndexExpression(ir: string[], expr: any): string {
    const obj = this.generateExpression(ir, expr.object)
    const index = this.generateExpression(ir, expr.index)
    // Handle nested array access
    // If expr.object is an IndexExpression, array is an i64 (from array_get), convert to ptr
    // Otherwise, array is already a ptr (from alloca or variable load)
    const isNestedIndex = expr.object?.type === "IndexExpression"
    let arrayPtr = obj
    if (isNestedIndex) {
      const r = `%${this.valueCounter++}`
      ir.push(`  ${r} = inttoptr i64 ${obj} to ptr`)
      arrayPtr = r
    }

    // Check if this is a table access (table[key])
    if (this.isMapType(expr.object)) {
      // Table access: table[key] - key can be string or integer
      const keyExpr = expr.index
      let keyPtr: string
      let keyLen: string

      if (keyExpr.type === "StringLiteral") {
        // String key: use string literal directly
        const escaped = keyExpr.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
        keyPtr = `@key_str_${this.stringCounter++}`
        const strDef = `${keyPtr} = private unnamed_addr constant [${keyExpr.value.length + 1} x i8] c"${escaped}\\00"`
        this.stringConstants.push(strDef)
        keyLen = String(keyExpr.value.length)
      } else if (keyExpr.type === "IntegerLiteral" || keyExpr.type === "NumberLiteral") {
        // Integer key: store to memory and pass as ptr
        const keyVal = keyExpr.value !== undefined ? keyExpr.value : index
        keyPtr = `%${this.valueCounter++}`
        ir.push(`  ${keyPtr} = alloca i64`)
        ir.push(`  store i64 ${keyVal}, ptr ${keyPtr}`)
        keyLen = "8" // i64 is 8 bytes
      } else {
        // Variable or expression key - assume string
        keyPtr = index
        const lenReg = `%${this.valueCounter++}`
        ir.push(`  ${lenReg} = call i64 @string_length(ptr ${index})`)
        keyLen = lenReg
      }

      const reg = `%${this.valueCounter++}`
      ir.push(`  ${reg} = call i64 @map_get(ptr ${arrayPtr}, ptr ${keyPtr}, i64 ${keyLen})`)
      return reg
    }

    // Determine element type to use appropriate getter
    const elementType = this.getArrayElementType(expr.object)
    const reg = `%${this.valueCounter++}`

    // Check if this is a string type [u8]
    if (this.isStringType(expr.object)) {
      // String indexing - returns a new single-char string
      const resultReg = `%${this.valueCounter++}`
      // Emit bounds check elision hint in release mode
      if (this.shouldElideBoundsCheck()) {
        ir.push(`  ; BOUNDS_CHECK_ELIDED: release mode optimization`)
      }
      ir.push(`  ${resultReg} = call ptr @string_char_at(ptr ${arrayPtr}, i64 ${index})`)
      return resultReg
    }

    // Emit bounds check elision hint in release mode for AoS/SoA operations
    if (this.shouldElideBoundsCheck()) {
      ir.push(`  ; BOUNDS_CHECK_ELIDED: release mode optimization`)
    }

    if (elementType?.type === "FloatType") {
      if (elementType.kind === "f32") {
        const floatReg = `%${this.valueCounter++}`
        ir.push(`  ${floatReg} = call float @array_get_f32(ptr ${arrayPtr}, i64 ${index})`)
        // Convert float to i64 for language value representation
        const convReg = `%${this.valueCounter++}`
        ir.push(`  ${convReg} = fptoui float ${floatReg} to i64`)
        return convReg
      } else if (elementType.kind === "f64") {
        const doubleReg = `%${this.valueCounter++}`
        ir.push(`  ${doubleReg} = call double @array_get_f64(ptr ${arrayPtr}, i64 ${index})`)
        // Convert double to i64 for language value representation
        const convReg = `%${this.valueCounter++}`
        ir.push(`  ${convReg} = fptoui double ${doubleReg} to i64`)
        return convReg
      } else {
        ir.push(`  ${reg} = call i64 @array_get(ptr ${arrayPtr}, i64 ${index})`)
      }
    } else {
      ir.push(`  ${reg} = call i64 @array_get(ptr ${arrayPtr}, i64 ${index})`)
    }
    return reg
  }

  private getArrayElementType(expr: any): any {
    if (!expr) return null

    // If it's an identifier, look up the variable type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "ArrayType") {
        return varType.elementType
      }
    }

    // If it's an index expression, recursively get element type
    if (expr.type === "IndexExpression") {
      return this.getArrayElementType(expr.object)
    }

    // Check if the expression itself has a resultType (from analyzer)
    if (expr.resultType?.type === "ArrayType") {
      return expr.resultType.elementType
    }

    return null
  }

  private isStringType(expr: any): boolean {
    if (!expr) return false

    // Check if it's a string literal
    if (expr.type === "StringLiteral") {
      return true
    }

    // If it's an identifier, look up the variable type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "ArrayType") {
        const arrType = varType as ArrayType
        return arrType.elementType?.type === "UnsignedType" &&
               (arrType.elementType as any)?.kind === "u8" &&
               arrType.dimensions.length === 0
      }
    }

    return false
  }

  private isMapType(expr: any): boolean {
    if (!expr) return false

    // If it's an identifier, look up the variable type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "MapType") {
        return true
      }
    }

    // Check if the expression itself has a resultType
    if (expr.resultType?.type === "MapType") {
      return true
    }

    return false
  }

  private generateSliceExpression(ir: string[], expr: any): string {
    const array = this.generateExpression(ir, expr.object)
    const start = this.generateExpression(ir, expr.start)
    const end = this.generateExpression(ir, expr.end)

    const isNestedIndex = expr.object?.type === "IndexExpression"
    let arrayPtr = array
    if (isNestedIndex) {
      const r = `%${this.valueCounter++}`
      ir.push(`  ${r} = inttoptr i64 ${array} to ptr`)
      arrayPtr = r
    }

    // Check if this is a string type [u8]
    if (this.isStringType(expr.object)) {
      const resultReg = `%${this.valueCounter++}`
      // String slicing with step not supported yet, use basic slice
      ir.push(`  ${resultReg} = call ptr @string_slice(ptr ${arrayPtr}, i64 ${start}, i64 ${end})`)
      return resultReg
    }

    const reg = `%${this.valueCounter++}`

    // Handle step parameter if provided
    if (expr.step) {
      const step = this.generateExpression(ir, expr.step)
      ir.push(`  ${reg} = call ptr @array_slice_step(ptr ${arrayPtr}, i64 ${start}, i64 ${end}, i64 ${step})`)
    } else {
      ir.push(`  ${reg} = call ptr @array_slice(ptr ${arrayPtr}, i64 ${start}, i64 ${end})`)
    }
    return reg
  }

  private generateLLMCall(ir: string[], expr: any): string {
    const resultReg = `%${this.valueCounter++}`

    const prompt = this.generateStringLiteral(ir, expr.arguments.prompt)
    const options = this.generateStringLiteral(ir, JSON.stringify(expr.arguments.options || {}))
    const returnType = this.generateStringLiteral(ir, expr.returnType || "string")

    ir.push(`  ${resultReg} = call ptr @llm_call(ptr ${prompt}, ptr ${options}, ptr ${returnType})`)
    return resultReg
  }

  private generateMapExpression(ir: string[], expr: any): string {
    const collection = this.generateExpression(ir, expr.collection)
    const func = expr.function

    return collection
  }

  private generateCastExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const sourceType = expr.sourceType ? this.toLLVMType(expr.sourceType) : this.toLLVMType(expr.value?.resultType)
    const targetType = this.toLLVMType(expr.targetType)
    const isSourceSigned = expr.sourceType?.type === "IntegerType"
    const isTargetSigned = expr.targetType?.type === "IntegerType"
    const reg = `%${this.valueCounter++}`

    const sourceIsInt = sourceType.startsWith("i") || sourceType === "ptr"
    const targetIsInt = targetType.startsWith("i") || targetType === "ptr"
    const sourceIsFloat = sourceType.startsWith("f")
    const targetIsFloat = targetType.startsWith("f")

    if (sourceType === "ptr" && targetIsInt) {
      ir.push(`  ${reg} = ptrtoint ptr ${value} to ${targetType}`)
      return reg
    }

    if (targetType === "ptr" && sourceIsInt) {
      ir.push(`  ${reg} = inttoptr ${sourceType} ${value} to ptr`)
      return reg
    }

    if (sourceIsInt && targetIsInt) {
      const sourceBits = this.getIntBits(sourceType)
      const targetBits = this.getIntBits(targetType)

      if (targetBits > sourceBits) {
        const op = isSourceSigned ? "sext" : "zext"
        ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
      } else if (targetBits < sourceBits) {
        ir.push(`  ${reg} = trunc ${sourceType} ${value} to ${targetType}`)
      } else {
        return value
      }
    } else if (sourceIsInt && targetIsFloat) {
      const op = isSourceSigned ? "sitofp" : "uitofp"
      ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
    } else if (sourceIsFloat && targetIsInt) {
      const op = isTargetSigned ? "fptosi" : "fptoui"
      ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
    } else if (sourceIsFloat && targetIsFloat) {
      const sourceBits = this.getFloatBits(sourceType)
      const targetBits = this.getFloatBits(targetType)

      if (targetBits > sourceBits) {
        ir.push(`  ${reg} = fpext ${sourceType} ${value} to ${targetType}`)
      } else if (targetBits < sourceBits) {
        ir.push(`  ${reg} = fptrunc ${sourceType} ${value} to ${targetType}`)
      } else {
        return value
      }
    }

    return reg
  }

  private generateBlock(ir: string[], statement: any): void {
    for (const stmt of statement.statements) {
      this.generateStatement(ir, stmt)
      if (this.blockTerminated) break
    }
  }

  private generateConditional(ir: string[], statement: any): void {
    const condValue = this.generateExpression(ir, statement.test || statement.condition)
    // Convert i64 condition to i1
    const condBool = `%${this.valueCounter++}`
    ir.push(`  ${condBool} = icmp ne i64 ${condValue}, 0`)
    const trueLabel = this.nextLabel()
    const falseLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    ir.push(`  br i1 ${condBool}, label %${trueLabel}, label %${falseLabel}`)
    ir.push("")

    // Save blockTerminated state - branches with terminators shouldn't affect parent block
    const prevTerminated = this.blockTerminated
    this.blockTerminated = false

    ir.push(`${trueLabel}:`)
    const trueBranch = statement.trueBranch || statement.consequent
    const trueHadTerminator = this.generateBlockWithTerminator(ir, trueBranch)
    if (!trueHadTerminator) {
      ir.push(`  br label %${endLabel}`)
      ir.push("")
    }

    ir.push(`${falseLabel}:`)
    const falseBranch = statement.falseBranch || statement.alternate
    let falseHadTerminator = false
    if (falseBranch) {
      falseHadTerminator = this.generateBlockWithTerminator(ir, falseBranch)
      if (!falseHadTerminator) {
        ir.push(`  br label %${endLabel}`)
        ir.push("")
      }
    } else {
      ir.push(`  br label %${endLabel}`)
      ir.push("")
    }

    // End label is needed if either branch doesn't have a terminator
    // (because those branches will branch to the end label)
    const needsEndLabel = !trueHadTerminator || !falseHadTerminator
    if (needsEndLabel) {
      ir.push(`${endLabel}:`)
    }

    // Restore blockTerminated state unless both branches terminate
    if (!(trueHadTerminator && falseHadTerminator)) {
      this.blockTerminated = prevTerminated
    }
  }

  private generateBlockWithTerminator(ir: string[], statement: any): boolean {
    if (statement.type === "Block") {
      let hadTerminator = false
      for (const stmt of statement.statements) {
        this.generateStatement(ir, stmt)
        if (this.blockTerminated) {
          hadTerminator = true
          break
        }
      }
      return hadTerminator
    } else {
      if (statement.type === "Return" || statement.type === "Break" || statement.type === "Continue") {
        this.generateStatement(ir, statement)
        return true
      }
      this.generateStatement(ir, statement)
      return false
    }
  }

  private generateWhileLoop(ir: string[], statement: any): void {
    const startLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: startLabel })

    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${startLabel}:`)
    const condValue = this.generateExpression(ir, statement.test || statement.condition)
    // Convert i64 condition to i1
    const condBool = `%${this.valueCounter++}`
    ir.push(`  ${condBool} = icmp ne i64 ${condValue}, 0`)
    ir.push(`  br i1 ${condBool}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.generateStatement(ir, statement.body)
    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Pop loop context
    this.loopStack.pop()
  }

  private generateForLoop(ir: string[], statement: any): void {
    const headerLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: incLabel })

    const { variable, start, end, body } = statement

    const reg = `%${variable}`
    ir.push(`  ${reg} = alloca i64`)
    const startValue = this.generateExpression(ir, start)
    ir.push(`  store i64 ${startValue}, ptr ${reg}`)

    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${headerLabel}:`)
    const varValue = this.generateExpression(ir, { type: "Identifier", name: variable })
    const endValue = this.generateExpression(ir, end)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp sle i64 ${varValue}, ${endValue}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.generateStatement(ir, body)
    if (!this.blockTerminated) {
      ir.push(`  br label %${incLabel}`)
      ir.push("")
    }

    ir.push(`${incLabel}:`)
    const currentValue = this.generateExpression(ir, { type: "Identifier", name: variable })
    const incValue = `%${this.valueCounter++}`
    ir.push(`  ${incValue} = add i64 ${currentValue}, 1`)
    ir.push(`  store i64 ${incValue}, ptr %${variable}`)
    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Emit vectorization metadata for hot loop optimization
    // This hints to LLVM that this loop should be vectorized for SIMD operations
    if (this.opts.vectorization) {
      this.emitVectorizationMetadata(ir, headerLabel, endLabel)
    }

    // Pop loop context
    this.loopStack.pop()
  }

  private generateForEachLoop(ir: string[], statement: any): void {
    const startLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: incLabel })
    const prevTerminated = this.blockTerminated
    this.blockTerminated = false

    const { variable, array, body } = statement

    // Generate array and get its length
    const arrayPtr = this.generateExpression(ir, array)
    const indexReg = `%${variable}_idx`
    const valueReg = `%${variable}`

    // Allocate index variable and loop variable
    ir.push(`  ${indexReg} = alloca i64`)
    ir.push(`  store i64 0, ptr ${indexReg}`)
    ir.push(`  ${valueReg} = alloca i64`)
    this.variableTypes.set(variable, { type: "IntegerType", kind: "i64" })

    // Get array length
    const lengthReg = `%${this.valueCounter++}`
    ir.push(`  ${lengthReg} = call i64 @array_length(ptr ${arrayPtr})`)

    ir.push(`  br label %${startLabel}`)
    ir.push("")

    // Header: check if index < length
    ir.push(`${startLabel}:`)
    const currentIndex = `%${this.valueCounter++}`
    ir.push(`  ${currentIndex} = load i64, ptr ${indexReg}`)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp slt i64 ${currentIndex}, ${lengthReg}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    // Body: get element and execute
    ir.push(`${bodyLabel}:`)
    const elemValue = `%${this.valueCounter++}`
    ir.push(`  ${elemValue} = call i64 @array_get(ptr ${arrayPtr}, i64 ${currentIndex})`)
    ir.push(`  store i64 ${elemValue}, ptr ${valueReg}`)
    this.generateStatement(ir, body)
    ir.push(`  br label %${incLabel}`)
    ir.push("")

    // Increment
    ir.push(`${incLabel}:`)
    const nextIndex = `%${this.valueCounter++}`
    ir.push(`  ${nextIndex} = add i64 ${currentIndex}, 1`)
    ir.push(`  store i64 ${nextIndex}, ptr ${indexReg}`)
    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Emit vectorization metadata for array iteration optimization
    // This enables SIMD vectorization for SoA column operations
    if (this.opts.vectorization) {
      this.emitVectorizationMetadata(ir, startLabel, endLabel)
    }

    // Pop loop context
    this.loopStack.pop()
    this.blockTerminated = prevTerminated
  }

  private generateBreak(ir: string[]): void {
    if (this.loopStack.length === 0) {
      // Error: break outside of loop - this should be caught by analyzer
      return
    }
    const loopContext = this.loopStack[this.loopStack.length - 1]
    ir.push(`  br label %${loopContext.breakLabel}`)
    this.blockTerminated = true
  }

  private generateContinue(ir: string[]): void {
    if (this.loopStack.length === 0) {
      // Error: continue outside of loop - this should be caught by analyzer
      return
    }
    const loopContext = this.loopStack[this.loopStack.length - 1]
    ir.push(`  br label %${loopContext.continueLabel}`)
    this.blockTerminated = true
  }

  private generateFunctionDeclaration(ir: string[], statement: any): void {
    const { name, params, returnType, body } = statement

    this.resetValueCounter(10)
    this.currentFunctionBasicBlocks = 0

    const llvmParams = params.map((p: any) => {
      const llvmType = this.toLLVMType(p.paramType)
      return { name: p.name, type: llvmType }
    })

    const llvmReturnType = this.toLLVMType(returnType)

    const func: LLVMFunction = {
      name,
      returnType: llvmReturnType,
      params: llvmParams,
      body: [],
    }

    this.functions.set(name, func)
    this.functionTypes.set(name, returnType)
    this.currentFunction = func

    const paramStr = llvmParams.map((p: LLVMValue) => `${p.type} %${p.name}`).join(", ")

    // Determine function attributes based on optimization settings
    // Small functions (few params, simple body) get alwaysinline for hot path optimization
    const funcAttributes = this.determineFunctionAttributes(statement)

    // Build function definition with proper LLVM syntax:
    // define <returntype> @<name>(<params>) [fn-attributes] {
    // Note: function attributes like nounwind, alwaysinline go after params, not before return type
    const attrSuffix = funcAttributes.trim()

    ir.push(`define ${llvmReturnType} @${name}(${paramStr})${attrSuffix} {`)
    ir.push("entry:")
    ir.push("  call void @gc_push_frame()")

    for (const param of llvmParams) {
      const paramReg = `%${param.name}`
      const localReg = `%${param.name}_local`
      ir.push(`  ${localReg} = alloca ${param.type}`)
      ir.push(`  store ${param.type} ${paramReg}, ptr ${localReg}`)
      // Track parameter type for later loads
      const paramType = params.find((p: any) => p.name === param.name)?.paramType
      if (paramType) {
        this.variableTypes.set(param.name, paramType)
      }
    }
    ir.push("")

    this.blockTerminated = false
    for (const stmt of body.statements) {
      this.generateStatement(ir, stmt)
      if (this.blockTerminated) break
    }

    let hasReturn = false
    for (const stmt of body.statements) {
      if (stmt.type === "Return") {
        hasReturn = true
        break
      }
    }

    if (!hasReturn) {
      ir.push("  call void @gc_pop_frame()")
      if (returnType !== "void") {
        ir.push(`  ret ${llvmReturnType} 0`)
      } else {
        ir.push("  ret void")
      }
    }

    ir.push("}")
    ir.push("")

    this.currentFunction = null
  }

  /**
   * Determine LLVM function attributes for optimization
   * Small functions get alwaysinline for hot path optimization
   */
  private determineFunctionAttributes(statement: any): string {
    const attrs: string[] = []
    const body = statement.body

    // Count basic blocks by checking for control flow statements
    let basicBlockCount = 1 // entry block
    if (body?.statements) {
      for (const stmt of body.statements) {
        if (stmt.type === "Conditional" || stmt.type === "WhileLoop" ||
            stmt.type === "ForLoop" || stmt.type === "ForEachLoop") {
          basicBlockCount++
        }
      }
    }

    // Small functions: mark as alwaysinline for hot path optimization
    if (basicBlockCount <= this.opts.inlineThreshold) {
      attrs.push("alwaysinline")
    }

    // Inline functions with small struct operations for hot path optimization
    // This enables efficient struct field access and copy operations
    if (this.hasSmallStructOperations(statement)) {
      if (!attrs.includes("alwaysinline")) {
        attrs.push("alwaysinline")
      }
    }

    // Add nounwind for functions that don't unwind (no exceptions in AlgolScript)
    attrs.push("nounwind")

    // Return attributes as suffix (with leading space if any attributes present)
    return attrs.length > 0 ? ` ${attrs.join(" ")}` : ""
  }

  /**
   * Emit LLVM metadata for loop vectorization
   * This hints to the LLVM optimizer to vectorize array operations
   */
  private emitVectorizationMetadata(ir: string[], loopStart: string, loopEnd: string): void {
    if (!this.opts.vectorization) return

    // Add a metadata node to mark this loop as vectorizable
    // In full LLVM IR, this would be: !0 = !{!"llvm.loop.vectorize.enable", i1 1}
    // For now, we add a comment hint that the optimizer can use
    ir.push(`  ; VECTORIZE_HINT: loop ${loopStart} -> ${loopEnd}`)
  }

  /**
   * Check if bounds checks can be elided (release mode only)
   * In release mode, skip bounds checks for performance
   */
  private shouldElideBoundsCheck(): boolean {
    return this.opts.releaseMode
  }

  /**
   * Determine if a function operates on small structs that should be inlined
   * This enables hot path optimization for struct field access and copy operations
   */
  private hasSmallStructOperations(statement: any): boolean {
    // Check if function body contains struct operations
    // Small struct operations benefit from inlining
    const body = statement.body
    if (!body?.statements) return false

    for (const stmt of body.statements) {
      // Check for struct-related operations
      if (this.containsStructOperations(stmt)) {
        return true
      }
    }
    return false
  }

  /**
   * Recursively check if a statement contains struct operations
   */
  private containsStructOperations(stmt: any): boolean {
    if (!stmt) return false

    // Check for struct field access or assignment
    if (stmt.type === "MemberExpression" ||
        (stmt.type === "AssignmentStatement" &&
         stmt.target?.type === "MemberExpression")) {
      // This could be a struct field operation - check if it uses inline hint
      return true
    }

    // Recursively check nested statements
    if (stmt.body?.statements) {
      for (const s of stmt.body.statements) {
        if (this.containsStructOperations(s)) return true
      }
    }

    return false
  }

  /**
   * Emit inline hint for small struct operations
   * Marks struct copy/field access operations for LLVM inlining
   */
  private emitStructInlineHint(ir: string[], structName: string, operation: string): void {
    // Emit a comment hint that LLVM can use for inlining decisions
    ir.push(`  ; STRUCT_INLINE_HINT: ${structName} ${operation}`)
  }

  private generateReturn(ir: string[], statement: any): void {
    if (statement.value) {
      const reg = this.generateExpression(ir, statement.value)
      const returnType = this.currentFunction?.returnType || "i64"
      ir.push(`  ret ${returnType} ${reg}`)
    } else {
      ir.push("  ret void")
    }
  }

  private setupMainFunction(ir: string[]): void {
    ir.push("")
    ir.push("; Main entry point")
    ir.push("define i32 @main() {")
    ir.push("entry:")
    ir.push("  call void @gc_init()")
    ir.push("  call void @gc_push_frame()")
    ir.push("  call void @program()")
    ir.push("  call void @gc_pop_frame()")
    ir.push("  ret i32 0")
    ir.push("}")
  }

  private generateRuntimeFunctions(ir: string[]): void {
    ir.push("")
    ir.push("; Runtime function definitions (linked from runtime library)")
  }

  private generatePOSIXDeclarations(ir: string[]): void {
    ir.push("")
    ir.push("; POSIX function declarations")

    ir.push("declare i64 @open(ptr, i64, ...)")
    ir.push("declare i64 @read(i64, ptr, i64)")
    ir.push("declare i64 @write(i64, ptr, i64)")
    ir.push("declare i64 @close(i64)")
    ir.push("declare i64 @access(ptr, i64)")
    ir.push("declare i64 @faccessat(i64, ptr, i64, i64)")
    ir.push("declare i64 @chmod(ptr, i64)")
    ir.push("declare i64 @fchmod(i64, i64)")
    ir.push("declare i64 @chown(ptr, i64, i64)")
    ir.push("declare i64 @fchown(i64, i64, i64)")
    ir.push("declare i64 @lseek(i64, i64, i64)")
    ir.push("declare i64 @fsync(i64)")
    ir.push("declare i64 @fdatasync(i64)")
    ir.push("declare i64 @ftruncate(i64, i64)")
    ir.push("declare i64 @stat(ptr, ptr)")
    ir.push("declare i64 @lstat(ptr, ptr)")
    ir.push("declare i64 @fstat(i64, ptr)")
    ir.push("declare i64 @link(ptr, ptr)")
    ir.push("declare i64 @symlink(ptr, ptr)")
    ir.push("declare i64 @readlink(ptr, ptr, i64)")
    ir.push("declare i64 @unlink(ptr)")
    ir.push("declare i64 @rename(ptr, ptr)")
    ir.push("declare ptr @opendir(ptr)")
    ir.push("declare ptr @readdir(ptr)")
    ir.push("declare void @rewinddir(ptr)")
    ir.push("declare void @closedir(ptr)")
    ir.push("declare i64 @mkdir(ptr, i64)")
    ir.push("declare i64 @rmdir(ptr)")
    ir.push("declare i64 @chdir(ptr)")
    ir.push("declare i64 @fchdir(i64)")
    ir.push("declare i64 @getcwd(ptr, i64)")
    ir.push("declare i64 @dup(i64)")
    ir.push("declare i64 @dup2(i64, i64)")
    ir.push("declare i64 @fcntl(i64, i64, ...)")
    ir.push("declare i64 @pathconf(ptr, i64)")
    ir.push("declare i64 @fpathconf(i64, i64)")
    ir.push("declare i64 @creat(ptr, i64)")
    ir.push("declare i64 @mkfifo(ptr, i64)")
    ir.push("declare i64 @mknod(ptr, i64, i64)")
    ir.push("declare i64 @utimes(ptr, ptr)")
    ir.push("declare i64 @futimes(i64, ptr)")
    ir.push("declare i64 @utimensat(i64, ptr, ptr, i64)")
    ir.push("declare i64 @pread(i64, ptr, i64, i64)")
    ir.push("declare i64 @pwrite(i64, ptr, i64, i64)")
    ir.push("declare i64 @truncate(ptr, i64)")
    ir.push("")
  }

  private generatePrintDeclarations(ir: string[]): void {
    ir.push("")
    ir.push("; Print function declarations")
    ir.push("declare void @print_i64(i64)")
    ir.push("declare void @print_u64(i64)")
    ir.push("declare void @print_f64(double)")
    ir.push("declare void @print_string(ptr)")
    ir.push("declare void @println()")
    ir.push("declare void @println_i64(i64)")
    ir.push("declare void @println_u64(i64)")
    ir.push("declare void @println_f64(double)")
    ir.push("declare void @println_string(ptr)")
    ir.push("")
    ir.push("; Input function declarations")
    ir.push("declare i64 @input_i64()")
    ir.push("declare i64 @input_u64()")
    ir.push("declare double @input_f64()")
    ir.push("declare ptr @input_string()")
    ir.push("")
  }

  private nextLabel(): string {
    return `label${this.labelCounter++}`
  }

  private toLLVMType(type: any): LLVMType {
    if (!type) return "i64"

    switch (type.type) {
      case "IntegerType":
        return type.kind as LLVMType
      case "UnsignedType":
        return type.kind as LLVMType
      case "FloatType":
        // LLVM float type mapping: f8/f16->half, f32->float, f64->double, f128->fp128
        // f256 is not natively supported by LLVM - we treat it as fp128 (or could use software emulation)
        switch (type.kind) {
          case "f8":
          case "f16":
            return "half"
          case "f32":
            return "float"
          case "f64":
            return "double"
          case "f128":
          case "f256":
            return "fp128"
          default:
            return "float"
        }
      case "ArrayType":
        return "ptr"
      case "MapType":
        return "ptr"
      case "PointerType":
        return "ptr"
      case "VoidType":
        return "void"
default:
        return "i64"
    }
  }

private getIntBits(type: LLVMType): number {
    const match = type.match(/i(\d+)/)
    return match ? parseInt(match[1]) : 64
  }

  private getFloatBits(type: LLVMType): number {
    switch (type) {
      case "half": return 16
      case "float": return 32
      case "double": return 64
      case "fp128": return 128
      default: return 32
    }
  }

  private isFloatType(llvmType: LLVMType): boolean {
    return llvmType === "half" || llvmType === "float" || llvmType === "double" || llvmType === "fp128"
  }

  private isFloatOperand(expr: any): boolean {
    if (!expr) return false

    // Check literal type annotation
    if (expr.literalType?.type === "FloatType") return true

    // Check if it's a float literal value
    if (typeof expr.value === "number" && !Number.isInteger(expr.value)) return true
    if (typeof expr.value === "string") {
      const val = expr.value.toLowerCase()
      if (val.includes(".") || val.includes("e")) return true
    }

    // Check if it's an identifier with float type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      return varType?.type === "FloatType"
    }

    // For binary expressions, check left operand recursively
    if (expr.type === "BinaryExpression") {
      return this.isFloatOperand(expr.left) || this.isFloatOperand(expr.right)
    }

    return false
  }

  private getFloatTypeSize(expr: any): "half" | "float" | "double" | "fp128" {
    if (!expr) return "float"

    const floatKindToLLVM = (kind: string): "half" | "float" | "double" | "fp128" => {
      switch (kind) {
        case "f8":
        case "f16":
          return "half"
        case "f32":
          return "float"
        case "f64":
          return "double"
        case "f128":
        case "f256":
          return "fp128"
        default:
          return "float"
      }
    }

    // Check literal type annotation
    if (expr.literalType?.type === "FloatType") {
      return floatKindToLLVM(expr.literalType.kind)
    }

    // Check if it's an identifier with float type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "FloatType") {
        return floatKindToLLVM(varType.kind)
      }
    }

    // For binary expressions, check operands recursively and use widest type
    if (expr.type === "BinaryExpression") {
      const leftSize = this.getFloatTypeSize(expr.left)
      const rightSize = this.getFloatTypeSize(expr.right)
      // Priority: fp128 > double > float > half
      if (leftSize === "fp128" || rightSize === "fp128") return "fp128"
      if (leftSize === "double" || rightSize === "double") return "double"
      if (leftSize === "float" || rightSize === "float") return "float"
      return "half"
    }

    // For function calls, check the function's return type
    if (expr.type === "CallExpression") {
      const funcName = expr.function?.name || expr.callee?.name
      if (funcName) {
        const func = this.functions.get(funcName)
        if (func) {
          switch (func.returnType) {
            case "half": return "half"
            case "float": return "float"
            case "double": return "double"
            case "fp128": return "fp128"
          }
        }
      }
    }

    return "float" // default to float
  }

  private floatToHex(value: number, kind: string): string {
    // Convert float value to IEEE 754 hex representation based on type
    switch (kind) {
      case "f8":
      case "f16": {
        // Half precision (16-bit)
        const buffer = new ArrayBuffer(2)
        // Use Float16Array if available, otherwise convert via Float32
        if (typeof Float16Array !== 'undefined') {
          new Float16Array(buffer)[0] = value
        } else {
          // Convert float32 to half precision manually
          const f32Buffer = new ArrayBuffer(4)
          new DataView(f32Buffer).setFloat32(0, value, false)
          const f32Bits = new DataView(f32Buffer).getUint32(0, false)
          // Extract sign, exponent, mantissa
          const sign = (f32Bits >> 31) & 0x1
          const exponent = (f32Bits >> 23) & 0xFF
          const mantissa = f32Bits & 0x7FFFFF
          // Convert to half precision
          let hSign = sign
          let hExponent: number
          let hMantissa: number
          if (exponent === 0) {
            hExponent = 0
            hMantissa = 0
          } else if (exponent === 0xFF) {
            hExponent = 0x1F
            hMantissa = mantissa ? 0x200 : 0
          } else {
            const newExp = exponent - 127 + 15
            if (newExp >= 31) {
              hExponent = 0x1F
              hMantissa = 0
            } else if (newExp <= 0) {
              hExponent = 0
              hMantissa = (mantissa | 0x800000) >> (1 - newExp)
            } else {
              hExponent = newExp
              hMantissa = mantissa >> 13
            }
          }
          const hBits = (hSign << 15) | (hExponent << 10) | hMantissa
          return `0x${hBits.toString(16).padStart(4, '0')}`
        }
        const bits = new DataView(buffer).getUint16(0, false)
        return `0x${bits.toString(16).padStart(4, '0')}`
      }
      case "f32": {
        // Single precision (32-bit)
        const buffer = new ArrayBuffer(4)
        new DataView(buffer).setFloat32(0, value, false)
        const bits = new DataView(buffer).getUint32(0, false)
        return `0x${bits.toString(16).padStart(8, '0')}`
      }
      case "f64":
      default: {
        // Double precision (64-bit)
        const buffer = new ArrayBuffer(8)
        new DataView(buffer).setFloat64(0, value, false)
        const bits = new DataView(buffer).getBigUint64(0, false)
        return `0x${bits.toString(16).padStart(16, '0')}`
      }
      case "f128":
      case "f256": {
        // Quad precision (128-bit) - use fp128 format
        // For now, store as double and zero-pad the high bits
        const buffer = new ArrayBuffer(8)
        new DataView(buffer).setFloat64(0, value, false)
        const lowBits = new DataView(buffer).getBigUint64(0, false)
        return `0x0000000000000000${lowBits.toString(16).padStart(16, '0')}`
      }
    }
  }

  private floatToIntBits(value: number, kind: string): string {
    // Convert float value to LLVM hex float format (e.g., 0x40091eb851eb851f for 3.14)
    switch (kind) {
      case "f32": {
        const buffer = new ArrayBuffer(4)
        new DataView(buffer).setFloat32(0, value, false)
        const bits = new DataView(buffer).getUint32(0, false)
        return `0x${bits.toString(16).padStart(8, '0')}`
      }
      case "f64":
      default: {
        const buffer = new ArrayBuffer(8)
        new DataView(buffer).setFloat64(0, value, false)
        const bits = new DataView(buffer).getBigUint64(0, false)
        return `0x${bits.toString(16).padStart(16, '0')}`
      }
    }
  }
}

export function generateLLVMIR(ast: ProgramNode, options?: Partial<OptimizationOptions>): string {
  const generator = new LLVMIRGenerator(options)
  return generator.generate(ast)
}

export { LLVMIRGenerator, type OptimizationOptions }
