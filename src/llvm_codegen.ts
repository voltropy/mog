import type { ProgramNode, StatementNode, ExpressionNode } from "./analyzer.js"
import { isArrayType, isTableType } from "./types.js"

type LLVMType = "i8" | "i16" | "i32" | "i64" | "i128" | "i256" | "f32" | "f64" | "float" | "double" | "void" | "ptr"

type LLVMValue = {
  name: string
  type: LLVMType
  isConstant?: boolean
}

type LLVMFunction = {
  name: string
  returnType: LLVMType
  params: LLVMValue[]
  body: string[]
}

type LLVMGlobal = {
  name: string
  type: LLVMType
  initValue?: string
}

class LLVMIRGenerator {
  private functions: Map<string, LLVMFunction> = new Map()
  private globals: LLVMGlobal[] = []
  private currentFunction: LLVMFunction | null = null
  private blockCounter = 0
  private valueCounter = 0
  private labelCounter = 0

  generate(ast: ProgramNode): string {
    const ir: string[] = []

    ir.push("; AlgolScript LLVM IR")
    ir.push("; Generated by AlgolScript compiler")
    ir.push("")

    const platform = process.platform === "darwin" ? "aarch64-apple-darwin" :
                     process.platform === "win32" ? "x86_64-pc-windows-msvc" :
                     "x86_64-unknown-linux-gnu"
    ir.push(`target triple = "${platform}"`)
    ir.push("")

    this.setupDeclarations(ir)

    const functionDeclarations = this.collectFunctionDeclarations(ast)

    // Check if user has defined a main() function
    const mainFunc = functionDeclarations.find((f: any) => f.name === "main")
    const hasMain = !!mainFunc

    ir.push("; Function declarations")
    for (const funcDecl of functionDeclarations) {
      // Rename user's main() to @program_user to avoid conflict
      if (funcDecl.name === "main") {
        funcDecl.name = "program_user"
      }
      this.generateFunctionDeclaration(ir, funcDecl)
    }
    ir.push("")

    if (hasMain) {
      // User defined main() - generate wrapper at @main
      ir.push("; Main entry point (calls user's main)")
      
      const hasParams = mainFunc && mainFunc.params.length >= 2
      
      if (hasParams) {
        ir.push("define i32 @main(i32 %argc, ptr %argv) {")
        ir.push("entry:")
        ir.push("  call void @gc_init()")
        
        // Build array of length argc with argv pointers
        ir.push("  %args_array = call ptr @array_alloc(i64 8, i64 1, i64 %argc)")
        
        // Loop through argv and store pointers in array
        ir.push("  %args_array_data = getelementptr ptr, ptr %args_array, i64 0")
        
        // Process first 10 arguments (to keep code size reasonable)
        for (let i = 0; i < 10; i++) {
          ir.push(`  ; Process argv[${i}]`)
          ir.push(`  %argv_gep_${i} = getelementptr ptr, ptr %argv, i64 ${i}`)
          ir.push(`  %argv_ptr_${i} = load ptr, ptr %argv_gep_${i}`)
          ir.push(`  %in_bounds_${i} = icmp ult i64 ${i}, %argc`)
          ir.push(`  br i1 %in_bounds_${i}, label %store_argv_${i}, label %argv_done_${i}`)
          ir.push(`store_argv_${i}:`)
          ir.push(`  %array_gep_${i} = getelementptr i64, ptr %args_array_data, i64 ${i}`)
          ir.push(`  %argv_int_${i} = ptrtoint ptr %argv_ptr_${i} to i64`)
          ir.push(`  store i64 %argv_int_${i}, ptr %array_gep_${i}`)
          ir.push(`  br label %argv_done_${i}`)
          ir.push(`argv_done_${i}:`)
        }
        ir.push(`  ; Skip remaining argv elements (${i}..)`)
        
        // Create CLI args table (argc + args array)
        ir.push("  %cli_table = call ptr @table_new(i64 2)")
        ir.push("  %argc_key = alloca [5 x i8]")
        ir.push("  store [5 x i8] c\"argc\\00\", ptr %argc_key")
        ir.push("  call void @table_set(ptr %cli_table, ptr %argc_key, i64 4, i64 %argc)")
        
        ir.push("  %args_key = alloca [5 x i8]")
        ir.push("  store [5 x i8] c\"args\\00\", ptr %args_key")
        ir.push("  %args_int = ptrtoint ptr %args_array to i64")
        ir.push("  call void @table_set(ptr %cli_table, ptr %args_key, i64 4, i64 %args_int)")
        
        ir.push("  %cli_table_int = ptrtoint ptr %cli_table to i64")
        
        // Call user's main with CLI args table
        ir.push("  %result = call i64 @program_user(i64 %argc, i64 %cli_table_int)")
      } else {
        ir.push("define i32 @main(i32 %argc, ptr %argv) {")
        ir.push("entry:")
        ir.push("  call void @gc_init()")
        ir.push("  %result = call i64 @program_user()")
      }
      
      ir.push("  %truncated = trunc i64 %result to i32")
      ir.push("  ret i32 %truncated")
      ir.push("}")
    } else {
      // No main() - use program() entry point
      ir.push("define void @program() {")
      ir.push("entry:")

      for (const statement of ast.statements) {
        this.generateStatement(ir, statement)
      }

      ir.push("  ret void")
      ir.push("}")

      this.setupMainFunction(ir)
    }

    this.generateRuntimeFunctions(ir)

    return ir.join("\n")
  }

  private collectFunctionDeclarations(ast: ProgramNode): any[] {
    const functions: any[] = []
    const declarations = this.findFunctionDeclarationsRecursive(ast.statements)
    functions.push(...declarations)
    return functions
  }

  private findFunctionDeclarationsRecursive(statements: any[]): any[] {
    const functions: any[] = []
    for (const stmt of statements) {
      if (stmt.type === "FunctionDeclaration") {
        functions.push(stmt)
      } else if (stmt.type === "Block") {
        functions.push(...this.findFunctionDeclarationsRecursive(stmt.statements))
      }
    }
    return functions
  }

  private setupDeclarations(ir: string[]): void {
    ir.push("; Declare external LLM function")
    ir.push("declare ptr @llm_call(ptr %prompt, ptr %options, ptr %return_type)")
    ir.push("")

    ir.push("; Declare GC functions")
    ir.push("declare void @gc_init()")
    ir.push("declare ptr @gc_alloc(i64 %size)")
    ir.push("declare void @gc_collect()")
    ir.push("")

    ir.push("; Declare array functions")
    ir.push("declare ptr @array_alloc(i64 %element_size, i64 %dimension_count, i64 %dimensions)")
    ir.push("declare i64 @array_get(ptr %array, i64 %index)")
    ir.push("declare void @array_set(ptr %array, i64 %index, i64 %value)")
    ir.push("")

    ir.push("; Declare table functions")
    ir.push("declare ptr @table_new(i64 %initial_capacity)")
    ir.push("declare i64 @table_get(ptr %table, ptr %key, i64 %key_len)")
    ir.push("declare void @table_set(ptr %table, ptr %key, i64 %key_len, i64 %value)")
    ir.push("")
    
    ir.push("; Declare CLI argument helper functions")
    ir.push("declare i64 @get_argc_value(ptr %cli_table)")
    ir.push("declare i64 @get_argv_value(ptr %cli_table, i64 %index)")
    ir.push("")
  }

  private generateStatement(ir: string[], statement: StatementNode): void {
    switch (statement.type) {
      case "VariableDeclaration": {
        const llvmType = this.toLLVMType(statement.varType)
        const reg = `%${statement.name}`
        ir.push(`  ${reg} = alloca ${llvmType}`)
        if (statement.value) {
          const value = this.generateExpression(ir, statement.value)
          ir.push(`  store ${llvmType} ${value}, ptr ${reg}`)
        }
        break
      }
      case "Assignment":
        const value = this.generateExpression(ir, statement.value)
        ir.push(`  store i64 ${value}, ptr %${statement.name}`)
        break
      case "ExpressionStatement":
        this.generateExpression(ir, statement.expression)
        break
      case "Block":
        for (const stmt of statement.statements) {
          this.generateStatement(ir, stmt)
        }
        break
      case "Return":
        if (statement.value) {
          const value = this.generateExpression(ir, statement.value)
          ir.push(`  ret i64 ${value}`)
        } else {
          ir.push(`  ret void`)
        }
        break
      case "Conditional":
        this.generateConditional(ir, statement)
        break
      case "FunctionDeclaration":
        break
      case "WhileLoop":
        this.generateWhileLoop(ir, statement)
        break
      case "ForLoop":
        this.generateForLoop(ir, statement)
        break
      default:
        break
    }
  }

  private generateExpression(ir: string[], expr: any): string {
    switch (expr.type) {
      case "AssignmentExpression":
        return this.generateAssignmentExpression(ir, expr)
      case "NumberLiteral":
        return `${expr.value}`
      case "StringLiteral":
        return this.generateStringLiteral(ir, expr.value)
      case "Identifier": {
        const name = expr.name
        const ptrReg = `%${name}_local`
        const valReg = `%${this.valueCounter++}`

        if (this.currentFunction && this.currentFunction.params.find((p) => p.name === name)) {
          ir.push(`  ${valReg} = load i64, ptr ${ptrReg}`)
          return valReg
        }

        ir.push(`  ${valReg} = load i64, ptr %${name}`)
        return valReg
      }
      case "BinaryExpression":
        return this.generateBinaryExpression(ir, expr)
      case "UnaryExpression":
        return this.generateUnaryExpression(ir, expr)
      case "CallExpression":
        return this.generateCallExpression(ir, expr)
      case "ArrayLiteral":
        return this.generateArrayLiteral(ir, expr)
      case "TableLiteral":
        return this.generateTableLiteral(ir, expr)
      case "MemberExpression":
        return this.generateMemberExpression(ir, expr)
      case "IndexExpression":
        return this.generateIndexExpression(ir, expr)
      case "LLMCall":
        return this.generateLLMCall(ir, expr)
      case "MapExpression":
        return this.generateMapExpression(ir, expr)
      case "CastExpression":
        return this.generateCastExpression(ir, expr)
      default:
        return ""
    }
  }

  private generateStringLiteral(ir: string[], value: string): string {
    const name = `@str${this.valueCounter++}`
    const escaped = value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
    ir.push(`${name} = private unnamed_addr constant [${value.length + 1} x i8] c"${escaped}\\00"`)
    return name
  }

  private generateBinaryExpression(ir: string[], expr: any): string {
    const left = this.generateExpression(ir, expr.left)
    const right = this.generateExpression(ir, expr.right)
    const reg = `%${this.valueCounter++}`

    const opMap: Record<string, string[]> = {
      "+": ["add i64", "add"],
      "-": ["sub i64", "sub"],
      "*": ["mul i64", "mul"],
      "/": ["sdiv i64", "fdiv"],
      "%": ["srem i64", "frem"],
      "<": ["icmp slt i64", "fcmp olt"],
      ">": ["icmp sgt i64", "fcmp ogt"],
      "<=": ["icmp sle i64", "fcmp ole"],
      ">=": ["icmp sge i64", "fcmp oge"],
      "=": ["icmp eq i64", "fcmp oeq"],
      "==": ["icmp eq i64", "fcmp oeq"],
      "!=": ["icmp ne i64", "fcmp one"],
      "&&": ["and i64", "and"],
      "||": ["or i64", "or"],
    }

    const [intOp, floatOp] = opMap[expr.operator]
    const isFloat = expr.left.type === "FloatLiteral"
    const op = isFloat ? `${floatOp} ${left}, ${right}` : `${intOp} ${left}, ${right}`

    ir.push(`  ${reg} = ${op}`)
    return reg
  }

  private generateUnaryExpression(ir: string[], expr: any): string {
    const argument = expr.argument || expr.operand
    const value = this.generateExpression(ir, argument)
    const reg = `%${this.valueCounter++}`

    if (expr.operator === "-") {
      ir.push(`  ${reg} = sub i64 0, ${value}`)
    } else if (expr.operator === "!") {
      ir.push(`  ${reg} = xor i64 ${value}, 1`)
    }

    return reg
  }

  private generateCallExpression(ir: string[], expr: any): string {
    const args = (expr.args || expr.arguments || []).map((arg: ExpressionNode) => this.generateExpression(ir, arg)).filter(Boolean)

    if (expr.callee.type === "Identifier") {
      const funcName = expr.callee.name
      const funcInfo = this.functions.get(funcName)

      let typedArgs: string[]
      if (funcInfo && funcInfo.params) {
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = funcInfo.params[i]?.type || "i64"
          return `${paramType} ${arg}`
        })
      } else {
        typedArgs = args
      }

      const reg = `%${this.valueCounter++}`
      const returnType = funcInfo?.returnType || "i64"
      ir.push(`  ${reg} = call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
      return reg
    }

    return ""
  }

  private generateAssignmentExpression(ir: string[], expr: any): string {
    const { name, value } = expr
    const valueReg = this.generateExpression(ir, value)
    ir.push(`  store i64 ${valueReg}, ptr %${name}`)
    return valueReg
  }

  private generateArrayLiteral(ir: string[], expr: any): string {
    const elementReg = `%${this.valueCounter++}`
    ir.push(`  ${elementReg} = call ptr @array_alloc(i64 %size, i64 %dim_count, i64 %dimensions)`)

    for (let i = 0; i < expr.elements.length; i++) {
      const value = this.generateExpression(ir, expr.elements[i])
      if (value) {
        ir.push(`  call void @array_set(ptr ${elementReg}, i64 ${i}, i64 ${value})`)
      }
    }

    return elementReg
  }

  private generateTableLiteral(ir: string[], expr: any): string {
    const tableReg = `%${this.valueCounter++}`
    ir.push(`  ${tableReg} = call ptr @table_new(i64 %capacity)`)

    for (let i = 0; i < expr.entries.length; i++) {
      const { key, value } = expr.entries[i]
      const keyStr = this.generateStringLiteral(ir, key)
      const valueReg = this.generateExpression(ir, value)
      if (valueReg) {
        ir.push(`  call void @table_set(ptr ${tableReg}, ptr ${keyStr}, i64 ${key.length}, i64 ${valueReg})`)
      }
    }

    return tableReg
  }

  private generateMemberExpression(ir: string[], expr: any): string {
    const obj = this.generateExpression(ir, expr.object)
    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call i64 @table_get(ptr ${obj}, ptr @key_${expr.property}, i64 ${expr.property.length})`)
    return reg
  }

  private generateIndexExpression(ir: string[], expr: any): string {
    const array = this.generateExpression(ir, expr.object)
    const index = this.generateExpression(ir, expr.index)
    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call i64 @array_get(ptr ${array}, i64 ${index})`)
    return reg
  }

  private generateLLMCall(ir: string[], expr: any): string {
    const resultReg = `%${this.valueCounter++}`

    const prompt = this.generateStringLiteral(ir, expr.arguments.prompt)
    const options = this.generateStringLiteral(ir, JSON.stringify(expr.arguments.options || {}))
    const returnType = this.generateStringLiteral(ir, expr.returnType || "string")

    ir.push(`  ${resultReg} = call ptr @llm_call(ptr ${prompt}, ptr ${options}, ptr ${returnType})`)
    return resultReg
  }

  private generateMapExpression(ir: string[], expr: any): string {
    const collection = this.generateExpression(ir, expr.collection)
    const func = expr.function

    return collection
  }

  private generateCastExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const sourceType = this.toLLVMType(expr.sourceType)
    const targetType = this.toLLVMType(expr.targetType)
    const isSourceSigned = expr.sourceType?.type === "IntegerType"
    const isTargetSigned = expr.targetType?.type === "IntegerType"
    const reg = `%${this.valueCounter++}`

    const sourceIsInt = sourceType.startsWith("i")
    const targetIsInt = targetType.startsWith("i")
    const sourceIsFloat = sourceType.startsWith("f")
    const targetIsFloat = targetType.startsWith("f")

    if (sourceIsInt && targetIsInt) {
      const sourceBits = this.getIntBits(sourceType)
      const targetBits = this.getIntBits(targetType)

      if (targetBits > sourceBits) {
        const op = isSourceSigned ? "sext" : "zext"
        ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
      } else if (targetBits < sourceBits) {
        ir.push(`  ${reg} = trunc ${sourceType} ${value} to ${targetType}`)
      } else {
        return value
      }
    } else if (sourceIsInt && targetIsFloat) {
      const op = isSourceSigned ? "sitofp" : "uitofp"
      ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
    } else if (sourceIsFloat && targetIsInt) {
      const op = isTargetSigned ? "fptosi" : "fptoui"
      ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
    } else if (sourceIsFloat && targetIsFloat) {
      const sourceBits = this.getFloatBits(sourceType)
      const targetBits = this.getFloatBits(targetType)

      if (targetBits > sourceBits) {
        ir.push(`  ${reg} = fpext ${sourceType} ${value} to ${targetType}`)
      } else if (targetBits < sourceBits) {
        ir.push(`  ${reg} = fptrunc ${sourceType} ${value} to ${targetType}`)
      } else {
        return value
      }
    }

    return reg
  }

  private generateBlock(ir: string[], statement: any): void {
    for (const stmt of statement.statements) {
      this.generateStatement(ir, stmt)
    }
  }

  private generateConditional(ir: string[], statement: any): void {
    const condition = this.generateExpression(ir, statement.test || statement.condition)
    const trueLabel = this.nextLabel()
    const falseLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    ir.push(`  br i1 ${condition}, label %${trueLabel}, label %${falseLabel}`)
    ir.push("")

    ir.push(`${trueLabel}:`)
    const trueBranch = statement.trueBranch || statement.consequent
    const trueHadTerminator = this.generateBlockWithTerminator(ir, trueBranch)
    if (!trueHadTerminator) {
      ir.push(`  br label %${endLabel}`)
      ir.push("")
    }

    ir.push(`${falseLabel}:`)
    const falseBranch = statement.falseBranch || statement.alternate
    let falseHadTerminator = false
    if (falseBranch) {
      falseHadTerminator = this.generateBlockWithTerminator(ir, falseBranch)
      if (!falseHadTerminator) {
        ir.push(`  br label %${endLabel}`)
        ir.push("")
      }
    } else {
      ir.push(`  br label %${endLabel}`)
      ir.push("")
    }

    const needsEndLabel = !falseBranch || (falseBranch && !trueHadTerminator && !falseHadTerminator)
    if (needsEndLabel) {
      ir.push(`${endLabel}:`)
    }
  }

  private generateBlockWithTerminator(ir: string[], statement: any): boolean {
    if (statement.type === "Block") {
      const lastStmt = statement.statements[statement.statements.length - 1]
      if (lastStmt && lastStmt.type === "Return") {
        for (const stmt of statement.statements) {
          this.generateStatement(ir, stmt)
        }
        return true
      }
      for (const stmt of statement.statements) {
        this.generateStatement(ir, stmt)
      }
      return false
    } else {
      if (statement.type === "Return") {
        this.generateStatement(ir, statement)
        return true
      }
      this.generateStatement(ir, statement)
      return false
    }
  }

  private generateWhileLoop(ir: string[], statement: any): void {
    const startLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${startLabel}:`)
    const condition = this.generateExpression(ir, statement.test || statement.condition)
    ir.push(`  br i1 ${condition}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.generateStatement(ir, statement.body)
    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)
  }

  private generateForLoop(ir: string[], statement: any): void {
    const headerLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    const { variable, start, end, body } = statement

    const reg = `%${variable}`
    ir.push(`  ${reg} = alloca i64`)
    const startValue = this.generateExpression(ir, start)
    ir.push(`  store i64 ${startValue}, ptr ${reg}`)

    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${headerLabel}:`)
    const varValue = this.generateExpression(ir, { type: "Identifier", name: variable })
    const endValue = this.generateExpression(ir, end)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp sle i64 ${varValue}, ${endValue}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.generateStatement(ir, body)
    ir.push(`  br label %${incLabel}`)
    ir.push("")

    ir.push(`${incLabel}:`)
    const currentValue = this.generateExpression(ir, { type: "Identifier", name: variable })
    const incValue = `%${this.valueCounter++}`
    ir.push(`  ${incValue} = add i64 ${currentValue}, 1`)
    ir.push(`  store i64 ${incValue}, ptr %${variable}`)
    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)
  }

  private generateFunctionDeclaration(ir: string[], statement: any): void {
    const { name, params, returnType, body } = statement

    const llvmParams = params.map((p: any) => {
      const llvmType = this.toLLVMType(p.paramType)
      return { name: p.name, type: llvmType }
    })

    const llvmReturnType = this.toLLVMType(returnType)

    const func: LLVMFunction = {
      name,
      returnType: llvmReturnType,
      params: llvmParams,
      body: [],
    }

    this.functions.set(name, func)
    this.currentFunction = func

    const paramStr = llvmParams.map((p: LLVMValue) => `${p.type} %${p.name}`).join(", ")

    ir.push(`define ${llvmReturnType} @${name}(${paramStr}) {`)
    ir.push("entry:")

    for (const param of llvmParams) {
      const paramReg = `%${param.name}`
      const localReg = `%${param.name}_local`
      ir.push(`  ${localReg} = alloca ${param.type}`)
      ir.push(`  store ${param.type} ${paramReg}, ptr ${localReg}`)
    }
    ir.push("")

    for (const stmt of body.statements) {
      this.generateStatement(ir, stmt)
    }

    let hasReturn = false
    for (const stmt of body.statements) {
      if (stmt.type === "Return") {
        hasReturn = true
        break
      }
    }

    if (!hasReturn) {
      if (returnType !== "void") {
        ir.push("  ret i64 0")
      } else {
        ir.push("  ret void")
      }
    }

    ir.push("}")
    ir.push("")

    this.currentFunction = null
  }

  private generateReturn(ir: string[], statement: any): void {
    if (statement.value) {
      const reg = this.generateExpression(ir, statement.value)
      ir.push(`  ret i64 ${reg}`)
    } else {
      ir.push("  ret void")
    }
  }

  private setupMainFunction(ir: string[]): void {
    ir.push("")
    ir.push("; Main entry point")
    ir.push("define i32 @main() {")
    ir.push("entry:")
    ir.push("  call void @gc_init()")
    ir.push("  call void @program()")
    ir.push("  ret i32 0")
    ir.push("}")
  }

  private generateRuntimeFunctions(ir: string[]): void {
    ir.push("")
    ir.push("; Runtime function definitions (linked from runtime library)")
  }

  private nextLabel(): string {
    return `label${this.labelCounter++}`
  }

  private toLLVMType(type: any): LLVMType {
    if (!type) return "i64"

    switch (type.type) {
      case "IntegerType":
        return type.kind as LLVMType
      case "UnsignedType":
        return type.kind as LLVMType
      case "FloatType":
        return type.kind === "f32" ? "f32" : "f64"
      case "ArrayType":
        return "ptr"
      case "TableType":
        return "ptr"
      case "VoidType":
        return "void"
default:
        return "i64"
    }
  }

private getIntBits(type: LLVMType): number {
    const match = type.match(/i(\d+)/)
    return match ? parseInt(match[1]) : 64
  }

  private getFloatBits(type: LLVMType): number {
    return type === "f64" || type === "double" ? 64 : 32
  }
}

export function generateLLVMIR(ast: ProgramNode): string {
  const generator = new LLVMIRGenerator()
  return generator.generate(ast)
}

export { LLVMIRGenerator }
