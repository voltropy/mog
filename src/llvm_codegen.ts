import type { ProgramNode, StatementNode, ExpressionNode } from "./analyzer.js"
import { isArrayType, isTableType } from "./types.js"

type LLVMType = "i8" | "i16" | "i32" | "i64" | "i128" | "i256" | "f32" | "f64" | "float" | "double" | "void" | "ptr"

type LLVMValue = {
  name: string
  type: LLVMType
  isConstant?: boolean
}

type LLVMFunction = {
  name: string
  returnType: LLVMType
  params: LLVMValue[]
  body: string[]
}

type LLVMGlobal = {
  name: string
  type: LLVMType
  initValue?: string
}

class LLVMIRGenerator {
  private functions: Map<string, LLVMFunction> = new Map()
  private globals: LLVMGlobal[] = []
  private currentFunction: LLVMFunction | null = null
  private blockCounter = 0
  private valueCounter = 0
  private variableTypes: Map<string, any> = new Map()
  private loopStack: { breakLabel: string; continueLabel: string }[] = []
  private blockTerminated = false

  private resetValueCounter(start: number = 0): void {
    this.valueCounter = start
  }
  private labelCounter = 0
  private stringConstants: string[] = []
  private stringCounter = 0
  private resetStringCounter(): void {
    this.stringCounter = 0
  }

  generate(ast: ProgramNode): string {
    const ir: string[] = []

    ir.push("; AlgolScript LLVM IR")
    ir.push("; Generated by AlgolScript compiler")
    ir.push("")

    const platform = process.platform === "darwin" ? "aarch64-apple-darwin" :
                     process.platform === "win32" ? "x86_64-pc-windows-msvc" :
                     "x86_64-unknown-linux-gnu"
    ir.push(`target triple = "${platform}"`)
    ir.push("")

    this.setupDeclarations(ir)
    this.generatePrintDeclarations(ir)

    this.resetValueCounter(0)
    this.resetStringCounter()
    this.stringConstants = []  // Clear string constants

    // First: collect all string constants from AST
    this.collectStringConstants(ast)
    // Reset counter for code generation pass
    this.stringCounter = 0

    // Collect function declarations first to identify strings in functions
    const functionDeclarations = this.collectFunctionDeclarations(ast)

    // Check if user has defined a main() function
    const mainFunc = functionDeclarations.find((f: any) => f.name === "main")
    const hasMain = !!mainFunc

    // Insert string constants before function declarations
    ir.push("; String constants")
    for (const str of this.stringConstants) {
      ir.push(str)
    }
    ir.push("")

    ir.push("; Function declarations")
    for (const funcDecl of functionDeclarations) {
      // Rename user's main() to @program_user to avoid conflict
      if (funcDecl.name === "main") {
        funcDecl.name = "program_user"
      }
      this.generateFunctionDeclaration(ir, funcDecl)
    }
    ir.push("")

    if (hasMain) {
      // User defined main() - generate wrapper at @main
      ir.push("; Main entry point (calls user's main)")
      
      const hasParams = mainFunc && mainFunc.params.length >= 2
      
      if (hasParams) {
        ir.push("define i32 @main(i32 %argc, ptr %argv) {")
        ir.push("entry:")
        ir.push("  call void @gc_init()")
        ir.push("  call void @gc_push_frame()")
        
        // Build array of length argc with argv pointers
        ir.push("  %args_array = call ptr @array_alloc(i64 8, i64 1, i64 %argc)")
        
        // Loop through argv and store pointers in array
        ir.push("  %args_array_data = getelementptr ptr, ptr %args_array, i64 0")
        
        // Process first 10 arguments (to keep code size reasonable)
        for (let i = 0; i < 10; i++) {
          ir.push(`  ; Process argv[${i}]`)
          ir.push(`  %argv_gep_${i} = getelementptr ptr, ptr %argv, i64 ${i}`)
          ir.push(`  %argv_ptr_${i} = load ptr, ptr %argv_gep_${i}`)
          ir.push(`  %in_bounds_${i} = icmp ult i64 ${i}, %argc`)
          ir.push(`  br i1 %in_bounds_${i}, label %store_argv_${i}, label %argv_done_${i}`)
          ir.push(`store_argv_${i}:`)
          ir.push(`  %array_gep_${i} = getelementptr i64, ptr %args_array_data, i64 ${i}`)
          ir.push(`  %argv_int_${i} = ptrtoint ptr %argv_ptr_${i} to i64`)
          ir.push(`  store i64 %argv_int_${i}, ptr %array_gep_${i}`)
          ir.push(`  br label %argv_done_${i}`)
          ir.push(`argv_done_${i}:`)
        }
        ir.push(`  ; Skip remaining argv elements (${i}..)`)
        
        // Create CLI args table (argc + args array)
        ir.push("  %cli_table = call ptr @table_new(i64 2)")
        ir.push("  %argc_key = alloca [5 x i8]")
        ir.push("  store [5 x i8] c\"argc\\00\", ptr %argc_key")
        ir.push("  call void @table_set(ptr %cli_table, ptr %argc_key, i64 4, i64 %argc)")
        
        ir.push("  %args_key = alloca [5 x i8]")
        ir.push("  store [5 x i8] c\"args\\00\", ptr %args_key")
        ir.push("  %args_int = ptrtoint ptr %args_array to i64")
        ir.push("  call void @table_set(ptr %cli_table, ptr %args_key, i64 4, i64 %args_int)")
        
        ir.push("  %cli_table_int = ptrtoint ptr %cli_table to i64")
        
        // Call user's main with CLI args table
        ir.push("  %result = call i64 @program_user(i64 %argc, i64 %cli_table_int)")
      } else {
        ir.push("define i32 @main(i32 %argc, ptr %argv) {")
        ir.push("entry:")
        ir.push("  call void @gc_init()")
        ir.push("  call void @gc_push_frame()")
        ir.push("  %result = call i64 @program_user()")
      }
      
      ir.push("  %truncated = trunc i64 %result to i32")
      ir.push("  call void @gc_pop_frame()")
      ir.push("  ret i32 %truncated")
      ir.push("}")
    } else {
      // No main() - use program() entry point
      this.resetValueCounter(10)
      
      ir.push("define void @program() {")
      ir.push("entry:")

      this.blockTerminated = false
      for (const statement of ast.statements) {
        this.generateStatement(ir, statement)
        if (this.blockTerminated) break
      }

      if (!this.blockTerminated) {
        ir.push("  ret void")
      }
      ir.push("}")

      this.setupMainFunction(ir)
    }

    this.generateRuntimeFunctions(ir)
    this.generatePOSIXDeclarations(ir)

    return ir.join("\n")
  }

  private collectFunctionDeclarations(ast: ProgramNode): any[] {
    const functions: any[] = []
    const declarations = this.findFunctionDeclarationsRecursive(ast.statements)
    functions.push(...declarations)
    return functions
  }

  private findFunctionDeclarationsRecursive(statements: any[]): any[] {
    const functions: any[] = []
    for (const stmt of statements) {
      if (stmt.type === "FunctionDeclaration") {
        functions.push(stmt)
        // Recursively find nested function declarations in the function body
        if (stmt.body?.statements) {
          functions.push(...this.findFunctionDeclarationsRecursive(stmt.body.statements))
        }
      } else if (stmt.type === "Block") {
        functions.push(...this.findFunctionDeclarationsRecursive(stmt.statements))
      }
    }
    return functions
  }

  private setupDeclarations(ir: string[]): void {
    ir.push("; Declare external LLM function")
    ir.push("declare ptr @llm_call(ptr %prompt, ptr %options, ptr %return_type)")
    ir.push("")

    ir.push("; Declare GC functions")
    ir.push("declare void @gc_init()")
    ir.push("declare ptr @gc_alloc(i64 %size)")
    ir.push("declare void @gc_collect()")
    ir.push("declare void @gc_push_frame()")
    ir.push("declare void @gc_pop_frame()")
    ir.push("")

    ir.push("; Declare array functions")
    ir.push("declare ptr @array_alloc(i64 %element_size, i64 %dimension_count, ptr %dimensions)")
    ir.push("declare i64 @array_get(ptr %array, i64 %index)")
    ir.push("declare void @array_set(ptr %array, i64 %index, i64 %value)")
    ir.push("declare i64 @array_length(ptr %array)")
    ir.push("declare ptr @array_slice(ptr %array, i64 %start, i64 %end)")
    ir.push("")

    ir.push("; Declare table functions")
    ir.push("declare ptr @table_new(i64 %initial_capacity)")
    ir.push("declare i64 @table_get(ptr %table, ptr %key, i64 %key_len)")
    ir.push("declare void @table_set(ptr %table, ptr %key, i64 %key_len, i64 %value)")
    ir.push("")

    ir.push("; Declare string functions")
    ir.push("declare i64 @string_length(ptr %str)")
    ir.push("declare ptr @string_concat(ptr %a, ptr %b)")
    ir.push("")

    ir.push("; Declare CLI argument helper functions")
    ir.push("declare i64 @get_argc_value(ptr %cli_table)")
    ir.push("declare i64 @get_argv_value(ptr %cli_table, i64 %index)")
    ir.push("")
  }

  private generateStatement(ir: string[], statement: StatementNode): void {
    // Skip if current block is already terminated
    if (this.blockTerminated) {
      return
    }

    switch (statement.type) {
      case "VariableDeclaration": {
        const llvmType = this.toLLVMType(statement.varType)
        const reg = `%${statement.name}`
        const isPointerLike = statement.varType?.type === "ArrayType" || statement.varType?.type === "PointerType"
        const allocaType = isPointerLike ? "ptr" : llvmType
        ir.push(`  ${reg} = alloca ${allocaType}`)
        this.variableTypes.set(statement.name, statement.varType)
        if (statement.value) {
          const value = this.generateExpression(ir, statement.value)
          const isPointerLike = statement.varType?.type === "ArrayType" || statement.varType?.type === "PointerType"
          const storeType = isPointerLike ? "ptr" : llvmType
          ir.push(`  store ${storeType} ${value}, ptr ${reg}`)
        }
        break
      }
      case "Assignment": {
        const value = this.generateExpression(ir, statement.value)
        const varType = this.variableTypes.get(statement.name)
        const llvmType = this.toLLVMType(varType)
        ir.push(`  store ${llvmType} ${value}, ptr %${statement.name}`)
        break
      }
      case "ExpressionStatement":
        this.generateExpression(ir, statement.expression)
        break
      case "Block":
        this.blockTerminated = false
        for (const stmt of statement.statements) {
          this.generateStatement(ir, stmt)
          if (this.blockTerminated) break
        }
        break
      case "Return": {
        let value = null
        if (statement.value) {
          value = this.generateExpression(ir, statement.value)
        }
        ir.push("  call void @gc_pop_frame()")
        if (value) {
          const returnType = this.currentFunction?.returnType || "i64"
          ir.push(`  ret ${returnType} ${value}`)
        } else {
          ir.push(`  ret void`)
        }
        this.blockTerminated = true
        break
      }
      case "Conditional":
        this.generateConditional(ir, statement)
        break
      case "FunctionDeclaration":
        break
      case "WhileLoop":
        this.generateWhileLoop(ir, statement)
        break
      case "ForLoop":
        this.generateForLoop(ir, statement)
        break
      case "ForEachLoop":
        this.generateForEachLoop(ir, statement)
        break
      case "Break":
        this.generateBreak(ir)
        break
      case "Continue":
        this.generateContinue(ir)
        break
      default:
        break
    }
  }

  private generateExpression(ir: string[], expr: any): string {
    switch (expr.type) {
      case "AssignmentExpression":
        return this.generateAssignmentExpression(ir, expr)
      case "NumberLiteral": {
        // Handle float literals - convert to LLVM hex float format
        const val = String(expr.value)
        // Check if it's a float literal (has decimal point or exponent)
        const isFloat = val.includes(".") || val.toLowerCase().includes("e")
        if (isFloat) {
          const numVal = parseFloat(val)
          // Use DataView to get IEEE 754 bit pattern for double precision
          const buffer = new ArrayBuffer(8)
          new DataView(buffer).setFloat64(0, numVal, false) // big-endian
          const bits = new DataView(buffer).getBigUint64(0, false)
          return `0x${bits.toString(16).padStart(16, '0')}`
        }
        // Integer literal - parse octal if needed
        let intVal: number
        if (val.startsWith("0") && val.length > 1) {
          intVal = parseInt(val, 8)
        } else {
          intVal = parseInt(val, 10)
        }
        return `${intVal}`
      }
      case "POSIXConstant":
        return `${expr.value}`
      case "StringLiteral": {
        const name = this.generateStringLiteral(ir, expr.value)
        const ptrReg = `%${this.valueCounter++}`
        ir.push(`  ${ptrReg} = getelementptr [${expr.value.length + 1} x i8], ptr ${name}, i64 0, i64 0`)
        return ptrReg
      }
      case "TemplateLiteral":
        return this.generateTemplateLiteral(ir, expr)
      case "Identifier": {
        const name = expr.name
        const ptrReg = `%${name}_local`
        const valReg = `%${this.valueCounter++}`

        const varType = this.variableTypes.get(name)
        const isPointerLike = varType?.type === "ArrayType" || varType?.type === "PointerType"

        // Determine LLVM type for loading
        let llvmLoadType = "i64"
        if (varType?.type === "FloatType") {
          llvmLoadType = varType.kind === "f32" ? "float" : "double"
        }

        if (this.currentFunction && this.currentFunction.params.find((p) => p.name === name)) {
          if (isPointerLike) {
            const loaded = `%${this.valueCounter++}`
            ir.push(`  ${loaded} = load ptr, ptr ${ptrReg}`)
            return loaded
          }
          ir.push(`  ${valReg} = load ${llvmLoadType}, ptr ${ptrReg}`)
          return valReg
        }

        if (isPointerLike) {
          const loaded = `%${this.valueCounter++}`
          ir.push(`  ${loaded} = load ptr, ptr %${name}`)
          return loaded
        }

        ir.push(`  ${valReg} = load ${llvmLoadType}, ptr %${name}`)
        return valReg
      }
      case "BinaryExpression":
        return this.generateBinaryExpression(ir, expr)
      case "UnaryExpression":
        return this.generateUnaryExpression(ir, expr)
      case "CallExpression":
        return this.generateCallExpression(ir, expr)
      case "ArrayLiteral":
        return this.generateArrayLiteral(ir, expr)
      case "TableLiteral":
        return this.generateTableLiteral(ir, expr)
      case "MemberExpression":
        return this.generateMemberExpression(ir, expr)
      case "IndexExpression":
        return this.generateIndexExpression(ir, expr)
      case "SliceExpression":
        return this.generateSliceExpression(ir, expr)
      case "LLMCall":
        return this.generateLLMCall(ir, expr)
      case "MapExpression":
        return this.generateMapExpression(ir, expr)
      case "CastExpression":
        return this.generateCastExpression(ir, expr)
      default:
        return ""
    }
  }

  private generateStringLiteral(_ir: string[], value: string): string {
    // Strings are already collected and emitted, just return the name
    const name = `@str${this.stringCounter++}`
    return name
  }

  private collectStringFromNode(node: any): void {
    if (!node) return

    if (node.type === "StringLiteral") {
      const name = `@str${this.stringCounter++}`
      const escaped = node.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
      const strDef = `${name} = private unnamed_addr constant [${node.value.length + 1} x i8] c"${escaped}\\00"`
      this.stringConstants.push(strDef)
      return
    }

    // Collect strings from template literals
    if (node.type === "TemplateLiteral") {
      for (const part of node.parts) {
        if (typeof part === "string") {
          const name = `@str${this.stringCounter++}`
          const escaped = part.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
          const strDef = `${name} = private unnamed_addr constant [${part.length + 1} x i8] c"${escaped}\\00"`
          this.stringConstants.push(strDef)
        } else {
          this.collectStringFromNode(part)
        }
      }
      return
    }

    // Collect MemberExpression property names as string constants
    if (node.type === "MemberExpression") {
      const name = `@key_${node.property}_${this.stringCounter++}`
      const escaped = node.property.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
      const strDef = `${name} = private unnamed_addr constant [${node.property.length + 1} x i8] c"${escaped}\\00"`
      this.stringConstants.push(strDef)
    }

    // Recursively collect from child nodes
    for (const key in node) {
      if (key === 'position' || key.startsWith('_')) continue
      const value = node[key]
      if (Array.isArray(value)) {
        value.forEach(child => this.collectStringFromNode(child))
      } else if (typeof value === 'object' && value !== null) {
        this.collectStringFromNode(value)
      }
    }
  }

  private collectStringConstants(ast: any): void {
    this.collectStringFromNode(ast)
  }

  private generateTemplateLiteral(ir: string[], expr: any): string {
    const parts = expr.parts as (string | any)[]
    if (parts.length === 0) {
      // Empty string
      const name = this.generateStringLiteral(ir, "")
      const ptrReg = `%${this.valueCounter++}`
      ir.push(`  ${ptrReg} = getelementptr [1 x i8], ptr ${name}, i64 0, i64 0`)
      return ptrReg
    }

    // Collect all string parts into registers
    const partRegs: string[] = []
    for (const part of parts) {
      if (typeof part === "string") {
        // String literal part
        const name = this.generateStringLiteral(ir, part)
        const ptrReg = `%${this.valueCounter++}`
        ir.push(`  ${ptrReg} = getelementptr [${part.length + 1} x i8], ptr ${name}, i64 0, i64 0`)
        partRegs.push(ptrReg)
      } else {
        // Expression part - generate it and convert to string
        const exprReg = this.generateExpression(ir, part)
        // For now, assume it's already a string pointer
        // TODO: convert numbers to strings
        partRegs.push(exprReg)
      }
    }

    // Concatenate all parts using string_concat
    let result = partRegs[0]
    for (let i = 1; i < partRegs.length; i++) {
      const concatResult = `%${this.valueCounter++}`
      ir.push(`  ${concatResult} = call ptr @string_concat(ptr ${result}, ptr ${partRegs[i]})`)
      result = concatResult
    }

    return result
  }

  private generateBinaryExpression(ir: string[], expr: any): string {
    const left = this.generateExpression(ir, expr.left)
    const right = this.generateExpression(ir, expr.right)
    const reg = `%${this.valueCounter++}`

    // Handle logical operators specially - they work on i1 but we store as i64
    if (expr.operator === "&&" || expr.operator === "||") {
      // Convert operands to i1 (compare with 0), do logical op, then extend to i64
      const leftBool = `%${this.valueCounter++}`
      const rightBool = `%${this.valueCounter++}`
      ir.push(`  ${leftBool} = icmp ne i64 ${left}, 0`)
      ir.push(`  ${rightBool} = icmp ne i64 ${right}, 0`)
      const boolReg = `%${this.valueCounter++}`
      const logicOp = expr.operator === "&&" ? "and" : "or"
      ir.push(`  ${boolReg} = ${logicOp} i1 ${leftBool}, ${rightBool}`)
      const extReg = `%${this.valueCounter++}`
      ir.push(`  ${extReg} = zext i1 ${boolReg} to i64`)
      return extReg
    }

    const opMap: Record<string, string[]> = {
      "+": ["add i64", "fadd"],
      "-": ["sub i64", "fsub"],
      "*": ["mul i64", "fmul"],
      "/": ["sdiv i64", "fdiv"],
      "%": ["srem i64", "frem"],
      "|": ["or i64", "or"],
      "&": ["and i64", "and"],
    }

    // Comparison operators return i1, need to extend to i64
    const cmpMap: Record<string, string[]> = {
      "<": ["icmp slt i64", "fcmp olt"],
      ">": ["icmp sgt i64", "fcmp ogt"],
      "<=": ["icmp sle i64", "fcmp ole"],
      ">=": ["icmp sge i64", "fcmp oge"],
      "=": ["icmp eq i64", "fcmp oeq"],
      "==": ["icmp eq i64", "fcmp oeq"],
      "!=": ["icmp ne i64", "fcmp one"],
    }

    // Determine if operation is float-based by checking operand types
    const isFloat = this.isFloatOperand(expr.left) || this.isFloatOperand(expr.right)

    if (cmpMap[expr.operator]) {
      const [intOp, floatOp] = cmpMap[expr.operator]
      const floatType = isFloat ? this.getFloatTypeSize(expr) : "float"
      const cmpOp = isFloat ? `${floatOp} ${floatType} ${left}, ${right}` : `${intOp} ${left}, ${right}`
      const boolReg = `%${this.valueCounter++}`
      ir.push(`  ${boolReg} = ${cmpOp}`)
      const extReg = `%${this.valueCounter++}`
      ir.push(`  ${extReg} = zext i1 ${boolReg} to i64`)
      return extReg
    }

    const [intOp, floatOp] = opMap[expr.operator]
    if (isFloat) {
      const floatType = this.getFloatTypeSize(expr)
      ir.push(`  ${reg} = ${floatOp} ${floatType} ${left}, ${right}`)
    } else {
      ir.push(`  ${reg} = ${intOp} ${left}, ${right}`)
    }

    return reg
  }

  private generateUnaryExpression(ir: string[], expr: any): string {
    const argument = expr.argument || expr.operand
    const value = this.generateExpression(ir, argument)
    const reg = `%${this.valueCounter++}`

    if (expr.operator === "-") {
      ir.push(`  ${reg} = sub i64 0, ${value}`)
    } else if (expr.operator === "!") {
      ir.push(`  ${reg} = xor i64 ${value}, 1`)
    }

    return reg
  }

  private generateCallExpression(ir: string[], expr: any): string {
    const args = (expr.args || expr.arguments || []).map((arg: ExpressionNode) => this.generateExpression(ir, arg)).filter(Boolean)

    if (expr.callee.type === "Identifier") {
      const funcName = expr.callee.name

      // Handle print functions
      const printFunctions = ["print", "print_i64", "print_u64", "print_f64", "print_string",
                              "println", "println_i64", "println_u64", "println_f64", "println_string"]
      if (printFunctions.includes(funcName)) {
        return this.generatePrintCall(ir, funcName, args, expr)
      }

      // Handle input functions
      const inputFunctions = ["input_i64", "input_u64", "input_f64", "input_string"]
      if (inputFunctions.includes(funcName)) {
        return this.generateInputCall(ir, funcName)
      }

      const funcInfo = this.functions.get(funcName)

      // POSIX function signatures for proper argument typing
      const posixSignatures: Record<string, string[]> = {
        open: ["ptr", "i64"],  // variadic: may have mode
        read: ["i64", "ptr", "i64"],
        write: ["i64", "ptr", "i64"],
        pread: ["i64", "ptr", "i64", "i64"],
        pwrite: ["i64", "ptr", "i64", "i64"],
        lseek: ["i64", "i64", "i64"],
        close: ["i64"],
        fsync: ["i64"],
        fdatasync: ["i64"],
        stat: ["ptr", "ptr"],
        lstat: ["ptr", "ptr"],
        fstat: ["i64", "ptr"],
        access: ["ptr", "i64"],
        faccessat: ["i64", "ptr", "i64", "i64"],
        utimes: ["ptr", "ptr"],
        futimes: ["i64", "ptr"],
        utimensat: ["i64", "ptr", "ptr", "i64"],
        chmod: ["ptr", "i64"],
        fchmod: ["i64", "i64"],
        chown: ["ptr", "i64", "i64"],
        fchown: ["i64", "i64", "i64"],
        umask: ["i64"],
        truncate: ["ptr", "i64"],
        ftruncate: ["i64", "i64"],
        link: ["ptr", "ptr"],
        symlink: ["ptr", "ptr"],
        readlink: ["ptr", "ptr", "i64"],
        rename: ["ptr", "ptr"],
        unlink: ["ptr"],
        mkdir: ["ptr", "i64"],
        rmdir: ["ptr"],
        fcntl: ["i64", "i64"],  // variadic
        pathconf: ["ptr", "i64"],
        fpathconf: ["i64", "i64"],
        dup: ["i64"],
        dup2: ["i64", "i64"],
        creat: ["ptr", "i64"],
        mkfifo: ["ptr", "i64"],
        mknod: ["ptr", "i64", "i64"],  // variadic
        chdir: ["ptr"],
        fchdir: ["i64"],
        getcwd: ["ptr", "i64"],
        opendir: ["ptr"],
        readdir: ["ptr"],
        closedir: ["ptr"],
        rewinddir: ["ptr"],
      }

      const runtimeSignatures: Record<string, { params: string[]; ret: string }> = {
        table_new: { params: ["i64"], ret: "ptr" },
        table_get: { params: ["ptr", "ptr", "i64"], ret: "i64" },
        table_set: { params: ["ptr", "ptr", "i64", "i64"], ret: "void" },
        string_length: { params: ["ptr"], ret: "i64" },
        string_concat: { params: ["ptr", "ptr"], ret: "ptr" },
      }

      const sig = posixSignatures[funcName]
      const isVariadic = ["open", "fcntl", "mknod"].includes(funcName)

      // POSIX functions that return ptr instead of i64
      const posixReturnTypes: Record<string, string> = {
        opendir: "ptr",
        readdir: "ptr",
      }

      let typedArgs: string[]
      if (funcInfo && funcInfo.params) {
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = funcInfo.params[i]?.type || "i64"
          return `${paramType} ${arg}`
        })
      } else if (sig) {
        // Use POSIX signature for typing
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = sig[i] || "i64"
          return `${paramType} ${arg}`
        })
      } else if (runtimeSignatures[funcName]) {
        const sig = runtimeSignatures[funcName]
        typedArgs = args.map((arg: string, i: number) => {
          const paramType = sig.params[i] || "i64"
          return `${paramType} ${arg}`
        })
        const returnType = sig.ret
        const reg = returnType === "void" ? null : `%${this.valueCounter++}`
        if (reg) {
          ir.push(`  ${reg} = call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
        } else {
          ir.push(`  call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
        }
        return reg || ""
      } else if (isVariadic) {
        // For variadic functions without sig, type first 2 args, rest as i64
        typedArgs = args.map((arg: string, i: number) => {
          if (i === 0) return `ptr ${arg}`
          return `i64 ${arg}`
        })
      } else {
        typedArgs = args
      }

      const reg = `%${this.valueCounter++}`
      const returnType = funcInfo?.returnType || posixReturnTypes[funcName] || "i64"
      ir.push(`  ${reg} = call ${returnType} @${funcName}(${typedArgs.join(", ")})`)
      return reg
    }

    return ""
  }

  private generateInputCall(ir: string[], funcName: string): string {
    const reg = `%${this.valueCounter++}`
    
    switch (funcName) {
      case "input_i64":
      case "input_u64":
        ir.push(`  ${reg} = call i64 @${funcName}()`)
        return reg
      case "input_f64":
        ir.push(`  ${reg} = call double @${funcName}()`)
        return reg
      case "input_string":
        ir.push(`  ${reg} = call ptr @${funcName}()`)
        return reg
      default:
        return ""
    }
  }

  private generatePrintCall(ir: string[], funcName: string, args: string[], expr: any): string {
    // Handle println with no arguments (just newline)
    if (funcName === "println" && args.length === 0) {
      ir.push(`  call void @println()`)
      return ""
    }

    if (args.length === 0) {
      return ""
    }

    // Determine the actual function to call based on argument type
    const arg = expr.args?.[0] || expr.arguments?.[0]
    let actualFunc = funcName

    // Determine argument type - try resultType first, then variableTypes for identifiers
    let argType = arg?.resultType?.type
    if (!argType && arg?.type === "Identifier") {
      const varType = this.variableTypes.get(arg.name)
      argType = varType?.type
    }
    argType = argType || "IntegerType"

    // If generic print/println, determine specific version based on type
    if (funcName === "print" || funcName === "println") {
      if (argType === "FloatType") {
        actualFunc = funcName === "print" ? "print_f64" : "println_f64"
      } else if (argType === "UnsignedType") {
        actualFunc = funcName === "print" ? "print_u64" : "println_u64"
      } else {
        actualFunc = funcName === "print" ? "print_i64" : "println_i64"
      }
    }

    // Generate call with appropriate type
    if (argType === "FloatType") {
      ir.push(`  call void @${actualFunc}(double ${args[0]})`)
    } else {
      ir.push(`  call void @${actualFunc}(i64 ${args[0]})`)
    }
    return ""
  }

  private generateAssignmentExpression(ir: string[], expr: any): string {
    const { name, target, value } = expr
    const valueReg = this.generateExpression(ir, value)
    
    if (target && target.type === "IndexExpression") {
      const array = this.generateExpression(ir, target.object)
      const index = this.generateExpression(ir, target.index)
      // Handle nested array access
      const isNestedIndex = target.object?.type === "IndexExpression"
      let arrayPtr = array
      if (isNestedIndex) {
        const r = `%${this.valueCounter++}`
        ir.push(`  ${r} = inttoptr i64 ${array} to ptr`)
        arrayPtr = r
      }
      ir.push(`  call void @array_set(ptr ${arrayPtr}, i64 ${index}, i64 ${valueReg})`)
    } else if (target && target.type === "MemberExpression") {
      // Table member assignment: person.age := 31
      const obj = this.generateExpression(ir, target.object)
      // Generate the key string constant
      const keyName = `@key_${target.property}_${this.stringCounter++}`
      const escaped = target.property.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
      const strDef = `${keyName} = private unnamed_addr constant [${target.property.length + 1} x i8] c"${escaped}\\00"`
      this.stringConstants.push(strDef)
      // obj is already a ptr for tables
      ir.push(`  call void @table_set(ptr ${obj}, ptr ${keyName}, i64 ${target.property.length}, i64 ${valueReg})`)
    } else {
      const varType = this.variableTypes.get(name)
      const llvmType = this.toLLVMType(varType)
      ir.push(`  store ${llvmType} ${valueReg}, ptr %${name}`)
    }
    
    return valueReg
  }

  private generateArrayLiteral(ir: string[], expr: any): string {
    const size = expr.elements.length || 0
    const dimensionsReg = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsReg} = alloca [1 x i64]`)
    const dimensionsPtr = `%${this.valueCounter++}`
    ir.push(`  ${dimensionsPtr} = getelementptr [1 x i64], ptr ${dimensionsReg}, i64 0, i64 0`)
    ir.push(`  store i64 ${size}, ptr ${dimensionsPtr}`)
    const elementReg = `%${this.valueCounter++}`
    ir.push(`  ${elementReg} = call ptr @array_alloc(i64 8, i64 1, ptr ${dimensionsReg})`)

    for (let i = 0; i < expr.elements.length; i++) {
      const value = this.generateExpression(ir, expr.elements[i])
      if (value) {
        // Check if value is a pointer (nested array) and convert to i64
        const valueToStore = value.includes('ptr') || value.startsWith('%') && !value.includes('i64')
          ? (() => { const r = `%${this.valueCounter++}`; ir.push(`  ${r} = ptrtoint ptr ${value} to i64`); return r; })()
          : value
        ir.push(`  call void @array_set(ptr ${elementReg}, i64 ${i}, i64 ${valueToStore})`)
      }
    }

    return elementReg
  }

  private generateTableLiteral(ir: string[], expr: any): string {
    const tableReg = `%${this.valueCounter++}`
    const capacity = expr.columns.length > 0 ? expr.columns.length * 2 : 4
    ir.push(`  ${tableReg} = call ptr @table_new(i64 ${capacity})`)

    for (const col of expr.columns) {
      const key = col.name
      const value = col.values[0]
      const keyStr = this.generateStringLiteral(ir, key)
      const valueReg = this.generateExpression(ir, value)
      if (valueReg) {
        ir.push(`  call void @table_set(ptr ${tableReg}, ptr ${keyStr}, i64 ${key.length}, i64 ${valueReg})`)
      }
    }

    return tableReg
  }

  private generateMemberExpression(ir: string[], expr: any): string {
    const obj = this.generateExpression(ir, expr.object)
    // Generate the key string constant
    const keyName = `@key_${expr.property}_${this.stringCounter++}`
    const escaped = expr.property.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
    const strDef = `${keyName} = private unnamed_addr constant [${expr.property.length + 1} x i8] c"${escaped}\\00"`
    this.stringConstants.push(strDef)
    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call i64 @table_get(ptr ${obj}, ptr ${keyName}, i64 ${expr.property.length})`)
    return reg
  }

  private generateIndexExpression(ir: string[], expr: any): string {
    const array = this.generateExpression(ir, expr.object)
    const index = this.generateExpression(ir, expr.index)
    // Handle nested array access
    // If expr.object is an IndexExpression, array is an i64 (from array_get), convert to ptr
    // Otherwise, array is already a ptr (from alloca or variable load)
    const isNestedIndex = expr.object?.type === "IndexExpression"
    let arrayPtr = array
    if (isNestedIndex) {
      const r = `%${this.valueCounter++}`
      ir.push(`  ${r} = inttoptr i64 ${array} to ptr`)
      arrayPtr = r
    }
    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call i64 @array_get(ptr ${arrayPtr}, i64 ${index})`)
    return reg
  }

  private generateSliceExpression(ir: string[], expr: any): string {
    const array = this.generateExpression(ir, expr.object)
    const start = this.generateExpression(ir, expr.start)
    const end = this.generateExpression(ir, expr.end)

    const isNestedIndex = expr.object?.type === "IndexExpression"
    let arrayPtr = array
    if (isNestedIndex) {
      const r = `%${this.valueCounter++}`
      ir.push(`  ${r} = inttoptr i64 ${array} to ptr`)
      arrayPtr = r
    }

    const reg = `%${this.valueCounter++}`
    ir.push(`  ${reg} = call ptr @array_slice(ptr ${arrayPtr}, i64 ${start}, i64 ${end})`)
    return reg
  }

  private generateLLMCall(ir: string[], expr: any): string {
    const resultReg = `%${this.valueCounter++}`

    const prompt = this.generateStringLiteral(ir, expr.arguments.prompt)
    const options = this.generateStringLiteral(ir, JSON.stringify(expr.arguments.options || {}))
    const returnType = this.generateStringLiteral(ir, expr.returnType || "string")

    ir.push(`  ${resultReg} = call ptr @llm_call(ptr ${prompt}, ptr ${options}, ptr ${returnType})`)
    return resultReg
  }

  private generateMapExpression(ir: string[], expr: any): string {
    const collection = this.generateExpression(ir, expr.collection)
    const func = expr.function

    return collection
  }

  private generateCastExpression(ir: string[], expr: any): string {
    const value = this.generateExpression(ir, expr.value)
    const sourceType = expr.sourceType ? this.toLLVMType(expr.sourceType) : this.toLLVMType(expr.value?.resultType)
    const targetType = this.toLLVMType(expr.targetType)
    const isSourceSigned = expr.sourceType?.type === "IntegerType"
    const isTargetSigned = expr.targetType?.type === "IntegerType"
    const reg = `%${this.valueCounter++}`

    const sourceIsInt = sourceType.startsWith("i") || sourceType === "ptr"
    const targetIsInt = targetType.startsWith("i") || targetType === "ptr"
    const sourceIsFloat = sourceType.startsWith("f")
    const targetIsFloat = targetType.startsWith("f")

    if (sourceType === "ptr" && targetIsInt) {
      ir.push(`  ${reg} = ptrtoint ptr ${value} to ${targetType}`)
      return reg
    }

    if (targetType === "ptr" && sourceIsInt) {
      ir.push(`  ${reg} = inttoptr ${sourceType} ${value} to ptr`)
      return reg
    }

    if (sourceIsInt && targetIsInt) {
      const sourceBits = this.getIntBits(sourceType)
      const targetBits = this.getIntBits(targetType)

      if (targetBits > sourceBits) {
        const op = isSourceSigned ? "sext" : "zext"
        ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
      } else if (targetBits < sourceBits) {
        ir.push(`  ${reg} = trunc ${sourceType} ${value} to ${targetType}`)
      } else {
        return value
      }
    } else if (sourceIsInt && targetIsFloat) {
      const op = isSourceSigned ? "sitofp" : "uitofp"
      ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
    } else if (sourceIsFloat && targetIsInt) {
      const op = isTargetSigned ? "fptosi" : "fptoui"
      ir.push(`  ${reg} = ${op} ${sourceType} ${value} to ${targetType}`)
    } else if (sourceIsFloat && targetIsFloat) {
      const sourceBits = this.getFloatBits(sourceType)
      const targetBits = this.getFloatBits(targetType)

      if (targetBits > sourceBits) {
        ir.push(`  ${reg} = fpext ${sourceType} ${value} to ${targetType}`)
      } else if (targetBits < sourceBits) {
        ir.push(`  ${reg} = fptrunc ${sourceType} ${value} to ${targetType}`)
      } else {
        return value
      }
    }

    return reg
  }

  private generateBlock(ir: string[], statement: any): void {
    for (const stmt of statement.statements) {
      this.generateStatement(ir, stmt)
      if (this.blockTerminated) break
    }
  }

  private generateConditional(ir: string[], statement: any): void {
    const condValue = this.generateExpression(ir, statement.test || statement.condition)
    // Convert i64 condition to i1
    const condBool = `%${this.valueCounter++}`
    ir.push(`  ${condBool} = icmp ne i64 ${condValue}, 0`)
    const trueLabel = this.nextLabel()
    const falseLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    ir.push(`  br i1 ${condBool}, label %${trueLabel}, label %${falseLabel}`)
    ir.push("")

    // Save blockTerminated state - branches with terminators shouldn't affect parent block
    const prevTerminated = this.blockTerminated
    this.blockTerminated = false

    ir.push(`${trueLabel}:`)
    const trueBranch = statement.trueBranch || statement.consequent
    const trueHadTerminator = this.generateBlockWithTerminator(ir, trueBranch)
    if (!trueHadTerminator) {
      ir.push(`  br label %${endLabel}`)
      ir.push("")
    }

    ir.push(`${falseLabel}:`)
    const falseBranch = statement.falseBranch || statement.alternate
    let falseHadTerminator = false
    if (falseBranch) {
      falseHadTerminator = this.generateBlockWithTerminator(ir, falseBranch)
      if (!falseHadTerminator) {
        ir.push(`  br label %${endLabel}`)
        ir.push("")
      }
    } else {
      ir.push(`  br label %${endLabel}`)
      ir.push("")
    }

    // End label is needed if either branch doesn't have a terminator
    // (because those branches will branch to the end label)
    const needsEndLabel = !trueHadTerminator || !falseHadTerminator
    if (needsEndLabel) {
      ir.push(`${endLabel}:`)
    }

    // Restore blockTerminated state unless both branches terminate
    if (!(trueHadTerminator && falseHadTerminator)) {
      this.blockTerminated = prevTerminated
    }
  }

  private generateBlockWithTerminator(ir: string[], statement: any): boolean {
    if (statement.type === "Block") {
      const lastStmt = statement.statements[statement.statements.length - 1]
      if (lastStmt && (lastStmt.type === "Return" || lastStmt.type === "Break" || lastStmt.type === "Continue")) {
        for (const stmt of statement.statements) {
          this.generateStatement(ir, stmt)
          if (this.blockTerminated) break
        }
        return true
      }
      for (const stmt of statement.statements) {
        this.generateStatement(ir, stmt)
        if (this.blockTerminated) break
      }
      return false
    } else {
      if (statement.type === "Return" || statement.type === "Break" || statement.type === "Continue") {
        this.generateStatement(ir, statement)
        return true
      }
      this.generateStatement(ir, statement)
      return false
    }
  }

  private generateWhileLoop(ir: string[], statement: any): void {
    const startLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: startLabel })

    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${startLabel}:`)
    const condValue = this.generateExpression(ir, statement.test || statement.condition)
    // Convert i64 condition to i1
    const condBool = `%${this.valueCounter++}`
    ir.push(`  ${condBool} = icmp ne i64 ${condValue}, 0`)
    ir.push(`  br i1 ${condBool}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.generateStatement(ir, statement.body)
    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Pop loop context
    this.loopStack.pop()
  }

  private generateForLoop(ir: string[], statement: any): void {
    const headerLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: incLabel })

    const { variable, start, end, body } = statement

    const reg = `%${variable}`
    ir.push(`  ${reg} = alloca i64`)
    const startValue = this.generateExpression(ir, start)
    ir.push(`  store i64 ${startValue}, ptr ${reg}`)

    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${headerLabel}:`)
    const varValue = this.generateExpression(ir, { type: "Identifier", name: variable })
    const endValue = this.generateExpression(ir, end)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp sle i64 ${varValue}, ${endValue}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    ir.push(`${bodyLabel}:`)
    this.generateStatement(ir, body)
    if (!this.blockTerminated) {
      ir.push(`  br label %${incLabel}`)
      ir.push("")
    }

    ir.push(`${incLabel}:`)
    const currentValue = this.generateExpression(ir, { type: "Identifier", name: variable })
    const incValue = `%${this.valueCounter++}`
    ir.push(`  ${incValue} = add i64 ${currentValue}, 1`)
    ir.push(`  store i64 ${incValue}, ptr %${variable}`)
    ir.push(`  br label %${headerLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Pop loop context
    this.loopStack.pop()
  }

  private generateForEachLoop(ir: string[], statement: any): void {
    const startLabel = this.nextLabel()
    const bodyLabel = this.nextLabel()
    const incLabel = this.nextLabel()
    const endLabel = this.nextLabel()

    // Push loop context for break/continue
    this.loopStack.push({ breakLabel: endLabel, continueLabel: incLabel })
    const prevTerminated = this.blockTerminated
    this.blockTerminated = false

    const { variable, array, body } = statement

    // Generate array and get its length
    const arrayPtr = this.generateExpression(ir, array)
    const indexReg = `%${variable}_idx`
    const valueReg = `%${variable}`

    // Allocate index variable and loop variable
    ir.push(`  ${indexReg} = alloca i64`)
    ir.push(`  store i64 0, ptr ${indexReg}`)
    ir.push(`  ${valueReg} = alloca i64`)
    this.variableTypes.set(variable, { type: "IntegerType", kind: "i64" })

    // Get array length
    const lengthReg = `%${this.valueCounter++}`
    ir.push(`  ${lengthReg} = call i64 @array_length(ptr ${arrayPtr})`)

    ir.push(`  br label %${startLabel}`)
    ir.push("")

    // Header: check if index < length
    ir.push(`${startLabel}:`)
    const currentIndex = `%${this.valueCounter++}`
    ir.push(`  ${currentIndex} = load i64, ptr ${indexReg}`)
    const cond = `%${this.valueCounter++}`
    ir.push(`  ${cond} = icmp slt i64 ${currentIndex}, ${lengthReg}`)
    ir.push(`  br i1 ${cond}, label %${bodyLabel}, label %${endLabel}`)
    ir.push("")

    // Body: get element and execute
    ir.push(`${bodyLabel}:`)
    const elemValue = `%${this.valueCounter++}`
    ir.push(`  ${elemValue} = call i64 @array_get(ptr ${arrayPtr}, i64 ${currentIndex})`)
    ir.push(`  store i64 ${elemValue}, ptr ${valueReg}`)
    this.generateStatement(ir, body)
    ir.push(`  br label %${incLabel}`)
    ir.push("")

    // Increment
    ir.push(`${incLabel}:`)
    const nextIndex = `%${this.valueCounter++}`
    ir.push(`  ${nextIndex} = add i64 ${currentIndex}, 1`)
    ir.push(`  store i64 ${nextIndex}, ptr ${indexReg}`)
    ir.push(`  br label %${startLabel}`)
    ir.push("")

    ir.push(`${endLabel}:`)

    // Pop loop context
    this.loopStack.pop()
    this.blockTerminated = prevTerminated
  }

  private generateBreak(ir: string[]): void {
    if (this.loopStack.length === 0) {
      // Error: break outside of loop - this should be caught by analyzer
      return
    }
    const loopContext = this.loopStack[this.loopStack.length - 1]
    ir.push(`  br label %${loopContext.breakLabel}`)
    this.blockTerminated = true
  }

  private generateContinue(ir: string[]): void {
    if (this.loopStack.length === 0) {
      // Error: continue outside of loop - this should be caught by analyzer
      return
    }
    const loopContext = this.loopStack[this.loopStack.length - 1]
    ir.push(`  br label %${loopContext.continueLabel}`)
    this.blockTerminated = true
  }

  private generateFunctionDeclaration(ir: string[], statement: any): void {
    const { name, params, returnType, body } = statement

    this.resetValueCounter(10)

    const llvmParams = params.map((p: any) => {
      const llvmType = this.toLLVMType(p.paramType)
      return { name: p.name, type: llvmType }
    })

    const llvmReturnType = this.toLLVMType(returnType)

    const func: LLVMFunction = {
      name,
      returnType: llvmReturnType,
      params: llvmParams,
      body: [],
    }

    this.functions.set(name, func)
    this.currentFunction = func

    const paramStr = llvmParams.map((p: LLVMValue) => `${p.type} %${p.name}`).join(", ")

    ir.push(`define ${llvmReturnType} @${name}(${paramStr}) {`)
    ir.push("entry:")
    ir.push("  call void @gc_push_frame()")

    for (const param of llvmParams) {
      const paramReg = `%${param.name}`
      const localReg = `%${param.name}_local`
      ir.push(`  ${localReg} = alloca ${param.type}`)
      ir.push(`  store ${param.type} ${paramReg}, ptr ${localReg}`)
      // Track parameter type for later loads
      const paramType = params.find((p: any) => p.name === param.name)?.paramType
      if (paramType) {
        this.variableTypes.set(param.name, paramType)
      }
    }
    ir.push("")

    this.blockTerminated = false
    for (const stmt of body.statements) {
      this.generateStatement(ir, stmt)
      if (this.blockTerminated) break
    }

    let hasReturn = false
    for (const stmt of body.statements) {
      if (stmt.type === "Return") {
        hasReturn = true
        break
      }
    }

    if (!hasReturn) {
      ir.push("  call void @gc_pop_frame()")
      if (returnType !== "void") {
        ir.push(`  ret ${llvmReturnType} 0`)
      } else {
        ir.push("  ret void")
      }
    }

    ir.push("}")
    ir.push("")

    this.currentFunction = null
  }

  private generateReturn(ir: string[], statement: any): void {
    if (statement.value) {
      const reg = this.generateExpression(ir, statement.value)
      const returnType = this.currentFunction?.returnType || "i64"
      ir.push(`  ret ${returnType} ${reg}`)
    } else {
      ir.push("  ret void")
    }
  }

  private setupMainFunction(ir: string[]): void {
    ir.push("")
    ir.push("; Main entry point")
    ir.push("define i32 @main() {")
    ir.push("entry:")
    ir.push("  call void @gc_init()")
    ir.push("  call void @gc_push_frame()")
    ir.push("  call void @program()")
    ir.push("  call void @gc_pop_frame()")
    ir.push("  ret i32 0")
    ir.push("}")
  }

  private generateRuntimeFunctions(ir: string[]): void {
    ir.push("")
    ir.push("; Runtime function definitions (linked from runtime library)")
  }

  private generatePOSIXDeclarations(ir: string[]): void {
    ir.push("")
    ir.push("; POSIX function declarations")

    ir.push("declare i64 @open(ptr, i64, ...)")
    ir.push("declare i64 @read(i64, ptr, i64)")
    ir.push("declare i64 @write(i64, ptr, i64)")
    ir.push("declare i64 @close(i64)")
    ir.push("declare i64 @access(ptr, i64)")
    ir.push("declare i64 @faccessat(i64, ptr, i64, i64)")
    ir.push("declare i64 @chmod(ptr, i64)")
    ir.push("declare i64 @fchmod(i64, i64)")
    ir.push("declare i64 @chown(ptr, i64, i64)")
    ir.push("declare i64 @fchown(i64, i64, i64)")
    ir.push("declare i64 @lseek(i64, i64, i64)")
    ir.push("declare i64 @fsync(i64)")
    ir.push("declare i64 @fdatasync(i64)")
    ir.push("declare i64 @ftruncate(i64, i64)")
    ir.push("declare i64 @stat(ptr, ptr)")
    ir.push("declare i64 @lstat(ptr, ptr)")
    ir.push("declare i64 @fstat(i64, ptr)")
    ir.push("declare i64 @link(ptr, ptr)")
    ir.push("declare i64 @symlink(ptr, ptr)")
    ir.push("declare i64 @readlink(ptr, ptr, i64)")
    ir.push("declare i64 @unlink(ptr)")
    ir.push("declare i64 @rename(ptr, ptr)")
    ir.push("declare ptr @opendir(ptr)")
    ir.push("declare ptr @readdir(ptr)")
    ir.push("declare void @rewinddir(ptr)")
    ir.push("declare void @closedir(ptr)")
    ir.push("declare i64 @mkdir(ptr, i64)")
    ir.push("declare i64 @rmdir(ptr)")
    ir.push("declare i64 @chdir(ptr)")
    ir.push("declare i64 @fchdir(i64)")
    ir.push("declare i64 @getcwd(ptr, i64)")
    ir.push("declare i64 @dup(i64)")
    ir.push("declare i64 @dup2(i64, i64)")
    ir.push("declare i64 @fcntl(i64, i64, ...)")
    ir.push("declare i64 @pathconf(ptr, i64)")
    ir.push("declare i64 @fpathconf(i64, i64)")
    ir.push("declare i64 @creat(ptr, i64)")
    ir.push("declare i64 @mkfifo(ptr, i64)")
    ir.push("declare i64 @mknod(ptr, i64, i64)")
    ir.push("declare i64 @utimes(ptr, ptr)")
    ir.push("declare i64 @futimes(i64, ptr)")
    ir.push("declare i64 @utimensat(i64, ptr, ptr, i64)")
    ir.push("declare i64 @pread(i64, ptr, i64, i64)")
    ir.push("declare i64 @pwrite(i64, ptr, i64, i64)")
    ir.push("declare i64 @truncate(ptr, i64)")
    ir.push("")
  }

  private generatePrintDeclarations(ir: string[]): void {
    ir.push("")
    ir.push("; Print function declarations")
    ir.push("declare void @print_i64(i64)")
    ir.push("declare void @print_u64(i64)")
    ir.push("declare void @print_f64(double)")
    ir.push("declare void @print_string(ptr)")
    ir.push("declare void @println()")
    ir.push("declare void @println_i64(i64)")
    ir.push("declare void @println_u64(i64)")
    ir.push("declare void @println_f64(double)")
    ir.push("declare void @println_string(ptr)")
    ir.push("")
    ir.push("; Input function declarations")
    ir.push("declare i64 @input_i64()")
    ir.push("declare i64 @input_u64()")
    ir.push("declare double @input_f64()")
    ir.push("declare ptr @input_string()")
    ir.push("")
  }

  private nextLabel(): string {
    return `label${this.labelCounter++}`
  }

  private toLLVMType(type: any): LLVMType {
    if (!type) return "i64"

    switch (type.type) {
      case "IntegerType":
        return type.kind as LLVMType
      case "UnsignedType":
        return type.kind as LLVMType
      case "FloatType":
        // LLVM uses 'float' and 'double' as type names
        return type.kind === "f32" ? "float" : "double"
      case "ArrayType":
        return "ptr"
      case "TableType":
        return "ptr"
      case "PointerType":
        return "ptr"
      case "VoidType":
        return "void"
default:
        return "i64"
    }
  }

private getIntBits(type: LLVMType): number {
    const match = type.match(/i(\d+)/)
    return match ? parseInt(match[1]) : 64
  }

  private getFloatBits(type: LLVMType): number {
    return type === "f64" || type === "double" ? 64 : 32
  }

  private isFloatType(llvmType: LLVMType): boolean {
    return llvmType === "float" || llvmType === "double" || llvmType === "f32" || llvmType === "f64"
  }

  private isFloatOperand(expr: any): boolean {
    if (!expr) return false

    // Check literal type annotation
    if (expr.literalType?.type === "FloatType") return true

    // Check if it's a float literal value
    if (typeof expr.value === "number" && !Number.isInteger(expr.value)) return true
    if (typeof expr.value === "string") {
      const val = expr.value.toLowerCase()
      if (val.includes(".") || val.includes("e")) return true
    }

    // Check if it's an identifier with float type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      return varType?.type === "FloatType"
    }

    // For binary expressions, check left operand recursively
    if (expr.type === "BinaryExpression") {
      return this.isFloatOperand(expr.left) || this.isFloatOperand(expr.right)
    }

    return false
  }

  private getFloatTypeSize(expr: any): "float" | "double" {
    if (!expr) return "float"

    // Check literal type annotation
    if (expr.literalType?.type === "FloatType") {
      return expr.literalType.kind === "f64" ? "double" : "float"
    }

    // Check if it's an identifier with float type
    if (expr.type === "Identifier" && expr.name) {
      const varType = this.variableTypes.get(expr.name)
      if (varType?.type === "FloatType") {
        return varType.kind === "f64" ? "double" : "float"
      }
    }

    // For binary expressions, check operands recursively
    if (expr.type === "BinaryExpression") {
      const leftSize = this.getFloatTypeSize(expr.left)
      const rightSize = this.getFloatTypeSize(expr.right)
      // If any operand is double, use double
      return (leftSize === "double" || rightSize === "double") ? "double" : "float"
    }

    // For function calls, check the function's return type
    if (expr.type === "CallExpression") {
      const funcName = expr.function?.name || expr.callee?.name
      if (funcName) {
        const func = this.functions.get(funcName)
        if (func?.returnType === "double") {
          return "double"
        }
      }
    }

    return "float" // default to float
  }
}

export function generateLLVMIR(ast: ProgramNode): string {
  const generator = new LLVMIRGenerator()
  return generator.generate(ast)
}

export { LLVMIRGenerator }
