//! Integration tests for the Mog plugin compilation and loading pipeline.
//!
//! These tests exercise `compile_plugin` end-to-end: Mog source → QBE IR →
//! assembly → shared library → dlopen → call exported functions.
//!
//! Requirements: QBE (`qbe` on PATH or $QBE), a C compiler (`cc`), and
//! `build/runtime.a` must exist.  Tests that cannot find these tools are
//! skipped rather than failed.

use std::ffi::{c_char, c_void, CStr};
use std::path::PathBuf;
use std::sync::atomic::{AtomicU32, Ordering};

use mog::compiler;

// Unique counter to avoid temp-dir collisions between parallel tests that
// share the same process ID.
static TEST_COUNTER: AtomicU32 = AtomicU32::new(0);

// ---------------------------------------------------------------------------
// C-compatible structs matching the Mog plugin ABI
// ---------------------------------------------------------------------------

/// Plugin info as generated by the QBE codegen.
///
/// Note: the QBE codegen emits a simplified 3-field struct (24 bytes), NOT
/// the full `MogPluginInfo` from `mog_plugin.h` which has 5 fields.
/// Layout: [name: *const c_char, version: *const c_char, num_exports: i64]
#[repr(C)]
struct MogPluginInfo {
    name: *const c_char,
    version: *const c_char,
    num_exports: i64,
}

#[repr(C)]
struct MogPluginExport {
    name: *const c_char,
    func_ptr: *mut c_void,
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

unsafe fn cstr_to_str<'a>(ptr: *const c_char) -> &'a str {
    if ptr.is_null() {
        return "<null>";
    }
    unsafe { CStr::from_ptr(ptr) }
        .to_str()
        .unwrap_or("<invalid>")
}

/// Read the math_plugin.mog source from the examples directory.
fn math_plugin_source() -> String {
    let path =
        PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../examples/plugins/math_plugin.mog");
    std::fs::read_to_string(&path).unwrap_or_else(|e| {
        panic!("cannot read math_plugin.mog at {}: {e}", path.display());
    })
}

/// Compile math_plugin.mog with a unique plugin name to avoid collisions
/// between parallel tests.  Returns the library path.
///
/// Panics (skips) if the toolchain is not available.
fn compile_math_plugin_unique(label: &str) -> PathBuf {
    let n = TEST_COUNTER.fetch_add(1, Ordering::SeqCst);
    let name = format!("math_plugin_{label}_{n}");
    let source = math_plugin_source();

    match compiler::compile_plugin(&source, &name, "1.0.0") {
        Ok(path) => path,
        Err(errors) => {
            let msg = errors.join("; ");
            if msg.contains("qbe") || msg.contains("runtime") || msg.contains("not found") {
                panic!("skipping: toolchain not available: {msg}");
            }
            panic!("compile_plugin failed: {msg}");
        }
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

/// Test that compile_plugin produces a file that exists.
#[test]
fn plugin_compiles_to_dylib() {
    let lib_path = compile_math_plugin_unique("dylib");
    assert!(lib_path.exists(), "compiled plugin should exist on disk");

    let ext = lib_path.extension().unwrap().to_str().unwrap();
    if cfg!(target_os = "macos") {
        assert_eq!(ext, "dylib");
    } else {
        assert_eq!(ext, "so");
    }

    let _ = std::fs::remove_file(&lib_path);
}

/// Test loading the plugin and inspecting its metadata.
#[test]
fn plugin_info_is_correct() {
    let lib_path = compile_math_plugin_unique("info");

    let lib =
        unsafe { libloading::Library::new(&lib_path) }.expect("failed to load compiled plugin");

    // mog_plugin_info
    let info_fn: libloading::Symbol<unsafe extern "C" fn() -> *const MogPluginInfo> =
        unsafe { lib.get(b"mog_plugin_info\0") }.expect("missing mog_plugin_info");

    let info_ptr = unsafe { info_fn() };
    assert!(
        !info_ptr.is_null(),
        "mog_plugin_info should not return null"
    );

    let info = unsafe { &*info_ptr };
    let name = unsafe { cstr_to_str(info.name) };
    let version = unsafe { cstr_to_str(info.version) };

    // The name embedded in the plugin matches the unique name we gave it,
    // but we just care that it's non-empty and starts with "math_plugin_".
    assert!(
        name.starts_with("math_plugin_"),
        "expected name starting with math_plugin_, got: {name}"
    );
    assert_eq!(version, "1.0.0");
    // math_plugin has 4 public functions: fibonacci, factorial, gcd, sum_of_squares
    assert_eq!(info.num_exports, 4, "expected 4 exports");

    let _ = std::fs::remove_file(&lib_path);
}

/// Test initializing the plugin (with null VM since math_plugin needs no
/// capabilities).
#[test]
fn plugin_init_succeeds() {
    let lib_path = compile_math_plugin_unique("init");

    let lib =
        unsafe { libloading::Library::new(&lib_path) }.expect("failed to load compiled plugin");

    let init_fn: libloading::Symbol<unsafe extern "C" fn(*mut c_void) -> i32> =
        unsafe { lib.get(b"mog_plugin_init\0") }.expect("missing mog_plugin_init");

    let result = unsafe { init_fn(std::ptr::null_mut()) };
    assert_eq!(result, 0, "mog_plugin_init should return 0");

    let _ = std::fs::remove_file(&lib_path);
}

/// Test calling exported functions and verifying results.
#[test]
fn plugin_function_calls() {
    let lib_path = compile_math_plugin_unique("calls");

    let lib =
        unsafe { libloading::Library::new(&lib_path) }.expect("failed to load compiled plugin");

    // Init first
    let init_fn: libloading::Symbol<unsafe extern "C" fn(*mut c_void) -> i32> =
        unsafe { lib.get(b"mog_plugin_init\0") }.expect("missing mog_plugin_init");
    unsafe { init_fn(std::ptr::null_mut()) };

    // Get exports
    let exports_fn: libloading::Symbol<unsafe extern "C" fn(*mut i32) -> *const MogPluginExport> =
        unsafe { lib.get(b"mog_plugin_exports\0") }.expect("missing mog_plugin_exports");

    let mut count: i32 = 0;
    let exports_ptr = unsafe { exports_fn(&mut count) };
    assert!(count > 0, "should have at least one export");

    // Build a lookup table
    let mut exports: Vec<(String, *mut c_void)> = Vec::new();
    for i in 0..count as usize {
        let entry = unsafe { &*exports_ptr.add(i) };
        let name = unsafe { cstr_to_str(entry.name) }.to_string();
        exports.push((name, entry.func_ptr));
    }

    // Helper to call a function by name
    let call = |name: &str, args: &[i64]| -> i64 {
        let (_, fptr) = exports.iter().find(|(n, _)| n == name).unwrap_or_else(|| {
            panic!(
                "function '{name}' not found in exports: {:?}",
                exports.iter().map(|(n, _)| n.clone()).collect::<Vec<_>>()
            );
        });
        let fptr = *fptr;
        assert!(!fptr.is_null());
        unsafe {
            match args.len() {
                0 => {
                    let f: extern "C" fn() -> i64 = std::mem::transmute(fptr);
                    f()
                }
                1 => {
                    let f: extern "C" fn(i64) -> i64 = std::mem::transmute(fptr);
                    f(args[0])
                }
                2 => {
                    let f: extern "C" fn(i64, i64) -> i64 = std::mem::transmute(fptr);
                    f(args[0], args[1])
                }
                _ => panic!("unsupported arity"),
            }
        }
    };

    // fibonacci(10) = 55
    assert_eq!(call("fibonacci", &[10]), 55);
    // fibonacci(0) = 0
    assert_eq!(call("fibonacci", &[0]), 0);
    // fibonacci(1) = 1
    assert_eq!(call("fibonacci", &[1]), 1);

    // factorial(7) = 5040
    assert_eq!(call("factorial", &[7]), 5040);
    // factorial(0) = 1
    assert_eq!(call("factorial", &[0]), 1);
    // factorial(1) = 1
    assert_eq!(call("factorial", &[1]), 1);

    // gcd(48, 18) = 6
    assert_eq!(call("gcd", &[48, 18]), 6);
    // gcd(100, 75) = 25
    assert_eq!(call("gcd", &[100, 75]), 25);

    // sum_of_squares(3, 4) = 25
    assert_eq!(call("sum_of_squares", &[3, 4]), 25);
    // sum_of_squares(0, 0) = 0
    assert_eq!(call("sum_of_squares", &[0, 0]), 0);

    let _ = std::fs::remove_file(&lib_path);
}

/// Test that compiling invalid source produces errors (not panics).
#[test]
fn compile_bad_source_returns_error() {
    // The parser may panic on truly invalid input.  Use catch_unwind to
    // convert a panic into an error — either way the test passes as long as
    // it doesn't produce a successful compilation.
    let result = std::panic::catch_unwind(|| {
        compiler::compile_plugin("this is not valid mog @@@@", "bad_plugin", "0.0.1")
    });
    match result {
        Ok(Ok(path)) => {
            // If it somehow compiled, that's unexpected but not fatal.
            let _ = std::fs::remove_file(&path);
            panic!("bad source should not compile successfully");
        }
        Ok(Err(_errors)) => {
            // Expected: compile_plugin returned an error.
        }
        Err(_panic) => {
            // Also acceptable: the parser panicked on garbage input.
        }
    }
}

/// Test that compile_plugin rejects empty source.
#[test]
fn compile_empty_source() {
    // Empty source produces empty IR which should be rejected.
    let result = compiler::compile_plugin("", "empty_plugin", "0.0.1");
    // This may succeed with warnings or fail — either is acceptable.
    // The key thing is it doesn't panic.
    match result {
        Ok(path) => {
            // Clean up if it somehow succeeded
            let _ = std::fs::remove_file(&path);
        }
        Err(_) => {
            // Expected — empty IR
        }
    }
}

/// Test the compile_to_binary API directly.
#[test]
fn compile_to_binary_works() {
    let source = r#"fn main() -> int { return 42; }"#;
    let n = TEST_COUNTER.fetch_add(1, Ordering::SeqCst);
    let output = std::env::temp_dir().join(format!("mog-test-bin-{}-{}", std::process::id(), n));

    let options = compiler::CompileOptions {
        output_path: Some(output.clone()),
        ..Default::default()
    };

    match compiler::compile_to_binary(source, &options) {
        Ok(bin_path) => {
            assert!(bin_path.exists());
            let output = std::process::Command::new(&bin_path).output();
            match output {
                Ok(out) => {
                    assert!(out.status.success() || out.status.code() == Some(42));
                }
                Err(e) => {
                    eprintln!("could not run binary: {e}");
                }
            }
            let _ = std::fs::remove_file(&bin_path);
        }
        Err(errors) => {
            let msg = errors.join("; ");
            if msg.contains("qbe") || msg.contains("runtime") || msg.contains("not found") {
                eprintln!("skipping: {msg}");
            } else {
                panic!("compile_to_binary failed: {msg}");
            }
        }
    }
}

/// Test capability sandboxing: a plugin that requires capabilities should
/// still compile (the `requires` declaration is metadata, not a hard dependency
/// at compile time unless the capability .mogdecl is missing).
#[test]
fn plugin_with_requires_declaration() {
    // This source uses `requires env` — if env.mogdecl doesn't exist, the
    // compiler will warn but may still produce IR.  Either outcome is fine;
    // we just verify it doesn't panic.
    let source = r#"
requires env

pub fn hello() -> int {
    return 1;
}
"#;
    let result = compiler::compile_plugin(source, "cap_plugin", "0.1.0");
    // We don't assert success or failure — both are acceptable depending
    // on whether env.mogdecl is available.
    match result {
        Ok(path) => {
            let _ = std::fs::remove_file(&path);
        }
        Err(errors) => {
            // Check that the errors are reasonable (not panics)
            assert!(!errors.is_empty());
            eprintln!("cap_plugin errors (expected): {:?}", errors);
        }
    }
}
