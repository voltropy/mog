# Chapter 15: Embedding Mog in a Host Application

Mog is designed to be embedded. It's a scripting language that runs inside your application, not a standalone runtime. The host creates a VM, decides what the script can do, enforces resource limits, and tears everything down when it's finished.

This chapter covers the C API that makes embedding work.

## The Embedding Lifecycle

Every embedded Mog program follows the same five-step lifecycle:

```
[Host Application]
  1. Create a MogVM
  2. Register capabilities (what the script can do)
  3. Set resource limits (how long, how much memory)
  4. Compile and run the Mog script
  5. Free the VM
```

Here's the minimal version in C:

```c
#include "mog.h"

int main(void) {
  // 1. Create the VM
  MogVM *vm = mog_vm_new();
  mog_vm_set_global(vm);

  // 2. Register built-in capabilities (fs + process)
  mog_register_posix_host(vm);

  // 3. Set resource limits
  MogLimits limits = { .max_cpu_ms = 5000 };
  mog_vm_set_limits(vm, &limits);

  // 4. Run the compiled program
  //    (program_user is generated by the Mog compiler)
  int result = program_user();

  // 5. Cleanup
  mog_vm_free(vm);
  return result;
}
```

`mog_vm_set_global()` stores the VM pointer in a global so that generated code can find it. `program_user()` is the entry point the Mog compiler produces from the script's `main` function.

## The C API

### VM Lifecycle

```c
// Create a new VM instance
MogVM *vm = mog_vm_new();

// Store as the global VM (required for generated code)
mog_vm_set_global(vm);

// Retrieve the global VM from anywhere
MogVM *vm = mog_vm_get_global();

// Destroy the VM and free all resources
mog_vm_free(vm);
```

A program typically creates one VM and sets it as the global. The global pointer is what the compiler-generated code uses to route capability calls back to the host.

### Registering Capabilities

Capabilities are registered as arrays of name-function pairs, terminated by a `{NULL, NULL}` sentinel:

```c
// Define host functions
static MogValue my_get_name(MogVM *vm, MogArgs *args) {
  (void)vm; (void)args;
  return mog_string("MyApp");
}

static MogValue my_get_version(MogVM *vm, MogArgs *args) {
  (void)vm; (void)args;
  return mog_int(42);
}

// Build the registration table
static const MogCapEntry app_functions[] = {
  { "get_name",    my_get_name    },
  { "get_version", my_get_version },
  { NULL, NULL }  // sentinel
};

// Register under the capability name "app"
mog_register_capability(vm, "app", app_functions);
```

After this, any Mog script that declares `requires app;` can call `app.get_name()` and `app.get_version()`.

For the standard POSIX capabilities (`fs` and `process`), there's a convenience function:

```c
// Registers both "fs" and "process" capabilities
mog_register_posix_host(vm);
```

### Validating Script Requirements

Before running a script, you can check that the VM provides everything the script needs:

```c
const char *required[] = { "fs", "process", "http", NULL };
int result = mog_validate_capabilities(vm, required);
if (result != 0) {
  // Some required capability is missing — refuse to run
  fprintf(stderr, "script requires capabilities this host doesn't provide\n");
  return 1;
}
```

You can also check individual capabilities:

```c
if (mog_has_capability(vm, "http")) {
  // http is available
}
```

> **Note:** Capability validation is covered from the Mog side in Chapter 14. The `requires` declaration is the script's half of the contract; `mog_validate_capabilities()` is the host's half.

## Implementing a Custom Capability

Here's a complete example: implementing an `env` capability that provides application metadata, random numbers, logging, and an async delay function.

### Step 1: Write the `.mogdecl` File

```
capability env {
  fn get_name() -> string
  fn get_version() -> int
  fn timestamp() -> int
  fn random(min: int, max: int) -> int
  fn log(message: string)
  async fn delay_square(value: int, delay_ms: int) -> int
}
```

This tells the compiler what functions exist and what their types are. See Chapter 14 for more on `.mogdecl` files.

### Step 2: Implement the Host Functions in C

Every host function has the same signature: it takes a `MogVM*` and `MogArgs*` and returns a `MogValue`. Extract arguments with `mog_arg_int`, `mog_arg_string`, etc. Return values with `mog_int`, `mog_string`, etc.

```c
#include "mog.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

static MogValue host_get_name(MogVM *vm, MogArgs *args) {
  (void)vm; (void)args;
  return mog_string("MogShowcase");
}

static MogValue host_get_version(MogVM *vm, MogArgs *args) {
  (void)vm; (void)args;
  return mog_int(1);
}

static MogValue host_timestamp(MogVM *vm, MogArgs *args) {
  (void)vm; (void)args;
  return mog_int((int64_t)time(NULL));
}

static MogValue host_random(MogVM *vm, MogArgs *args) {
  (void)vm;
  int64_t min_val = mog_arg_int(args, 0);
  int64_t max_val = mog_arg_int(args, 1);
  if (max_val <= min_val) return mog_int(min_val);
  int64_t range = max_val - min_val + 1;
  return mog_int(min_val + (rand() % range));
}

static MogValue host_log(MogVM *vm, MogArgs *args) {
  (void)vm;
  const char *message = mog_arg_string(args, 0);
  printf("[mog] %s\n", message);
  return mog_none();
}
```

### Step 3: Build the Registration Table and Register

```c
static const MogCapEntry env_functions[] = {
  { "get_name",     host_get_name     },
  { "get_version",  host_get_version  },
  { "timestamp",    host_timestamp    },
  { "random",       host_random       },
  { "log",          host_log          },
  { NULL, NULL }
};

// In your setup code:
MogVM *vm = mog_vm_new();
mog_register_capability(vm, "env", env_functions);
mog_vm_set_global(vm);
```

### Step 4: Use It from Mog

```mog
requires env;

fn main() -> int {
  name := env.get_name();
  version := env.get_version();
  env.log("starting {name} v{version}");

  roll := env.random(1, 100);
  env.log("random roll: {roll}");

  ts := env.timestamp();
  env.log("timestamp: {ts}");

  return 0;
}
```

The compiler checks the calls against `env.mogdecl`. At runtime, the VM routes each call to the corresponding C function.

## MogValue: Data Exchange Between Host and Script

All data crossing the host-script boundary is wrapped in `MogValue`, a 24-byte tagged union:

```c
typedef struct {
  enum {
    MOG_INT,     // int64_t
    MOG_FLOAT,   // double
    MOG_BOOL,    // bool
    MOG_STRING,  // const char*
    MOG_NONE,    // no value
    MOG_HANDLE,  // opaque pointer + type name
    MOG_ERROR    // error message string
  } tag;
  union {
    int64_t     i;
    double      f;
    bool        b;
    const char *s;
    struct { void *ptr; const char *type_name; } handle;
    const char *error;
  } data;
} MogValue;
```

### Constructing Values

Return values to the script using constructor functions:

```c
MogValue v1 = mog_int(42);
MogValue v2 = mog_float(3.14);
MogValue v3 = mog_bool(true);
MogValue v4 = mog_string("hello");
MogValue v5 = mog_none();
MogValue v6 = mog_error("file not found");
MogValue v7 = mog_handle(my_pointer, "DatabaseConn");
```

There are also result helpers that read more naturally for success returns:

```c
return mog_ok_int(42);      // same as mog_int(42)
return mog_ok_float(3.14);  // same as mog_float(3.14)
return mog_ok_string("ok"); // same as mog_string("ok")
```

### Extracting Arguments

Read arguments from `MogArgs` with bounds-checked extractors. These abort on type mismatch — a host programming error, not a script error:

```c
static MogValue host_add(MogVM *vm, MogArgs *args) {
  (void)vm;
  int64_t a = mog_arg_int(args, 0);     // first argument as int
  int64_t b = mog_arg_int(args, 1);     // second argument as int
  return mog_int(a + b);
}

static MogValue host_greet(MogVM *vm, MogArgs *args) {
  (void)vm;
  const char *name = mog_arg_string(args, 0);
  printf("hello, %s\n", name);
  return mog_none();
}

static MogValue host_scale(MogVM *vm, MogArgs *args) {
  (void)vm;
  double value = mog_arg_float(args, 0);
  double factor = mog_arg_float(args, 1);
  return mog_float(value * factor);
}
```

You can also extract from standalone `MogValue`s (not wrapped in `MogArgs`):

```c
MogValue result = mog_cap_call(vm, "math", "add", args, 2);
int64_t sum = mog_as_int(result);
```

### Returning Errors

Host functions signal errors by returning a `MogValue` with the `MOG_ERROR` tag. The script sees this as an error value that propagates through `?` (see Chapter 11):

```c
static MogValue host_read_sensor(MogVM *vm, MogArgs *args) {
  (void)vm;
  int64_t sensor_id = mog_arg_int(args, 0);

  if (sensor_id < 0 || sensor_id > 7) {
    return mog_error("invalid sensor id");
  }

  double reading = read_hardware_sensor(sensor_id);
  return mog_float(reading);
}
```

From the Mog side:

```mog
requires hw;

async fn main() -> int {
  // The ? propagates the error if sensor_id is invalid
  temp := hw.read_sensor(3)?;
  print("sensor 3: {temp}");

  // This will produce an error
  bad := hw.read_sensor(99)?;  // error: "invalid sensor id"
  return 0;
}
```

### Opaque Handles

For host-side resources that shouldn't be inspected by the script (database connections, file handles, GPU contexts), use `MOG_HANDLE`:

```c
static MogValue host_db_connect(MogVM *vm, MogArgs *args) {
  (void)vm;
  const char *connstr = mog_arg_string(args, 0);
  DBConn *conn = db_open(connstr);
  if (!conn) return mog_error("connection failed");
  return mog_handle(conn, "DBConn");
}

static MogValue host_db_query(MogVM *vm, MogArgs *args) {
  (void)vm;
  // Extract handle with type checking — aborts if type doesn't match
  DBConn *conn = mog_arg_handle(args, 0, "DBConn");
  const char *sql = mog_arg_string(args, 1);
  // ... execute query ...
  return mog_string(result_json);
}
```

> **Warning:** Opaque handles are not garbage-collected. The host is responsible for managing the lifetime of the underlying resource. If the script drops a handle without calling a cleanup function, the host must detect this (e.g., via a finalizer or VM teardown hook) to avoid leaks.

## Resource Limits and Timeouts

An embedded script should never be able to freeze or crash the host. Mog provides three mechanisms for resource control.

### CPU Time Limits

Set a maximum execution time via `MogLimits`:

```c
MogLimits limits = {
  .max_memory     = 0,     // 0 = unlimited
  .max_cpu_ms     = 5000,  // 5 seconds
  .max_stack_depth = 0     // 0 = default (1024)
};
mog_vm_set_limits(vm, &limits);
```

When `max_cpu_ms` is set, the VM automatically arms a timeout. If the script exceeds the time limit, it is interrupted at the next loop back-edge and returns `MOG_INTERRUPT_CODE` (-99) to the host.

### Manual Timeout Arming

For finer control, arm and cancel timeouts directly:

```c
// Arm: interrupt after 3 seconds
mog_arm_timeout(3000);

int result = program_user();

if (result == MOG_INTERRUPT_CODE) {
  printf("script timed out\n");
}

// Cancel if script finished early
mog_cancel_timeout();
```

### Host-Initiated Interrupts

The interrupt mechanism is thread-safe. A watchdog thread, signal handler, or UI callback can request termination at any time:

```c
// From any thread:
mog_request_interrupt();
```

The script checks the interrupt flag at every loop back-edge. When it sees the flag, it stops execution and returns `MOG_INTERRUPT_CODE` to the host. This is cooperative — not a signal kill — so the VM stays in a clean state.

```c
// Clear the flag before running another script
mog_clear_interrupt();

// Check if an interrupt was requested
if (mog_interrupt_requested()) {
  printf("interrupt pending\n");
}
```

> **Tip:** The cooperative interrupt model means a script that blocks inside a host function (e.g., a long-running C call) cannot be interrupted until it returns to Mog code. Keep host functions short, or implement your own cancellation within long-running C functions.

### Complete Timeout Example

```c
#include "mog.h"
#include <stdio.h>

int main(void) {
  MogVM *vm = mog_vm_new();
  mog_vm_set_global(vm);
  mog_register_posix_host(vm);

  // 2-second timeout
  MogLimits limits = { .max_cpu_ms = 2000 };
  mog_vm_set_limits(vm, &limits);

  // Run the script
  int result = program_user();

  if (result == MOG_INTERRUPT_CODE) {
    fprintf(stderr, "script exceeded 2-second time limit\n");
  } else {
    printf("script exited with code %d\n", result);
  }

  mog_vm_free(vm);
  return (result == MOG_INTERRUPT_CODE) ? 1 : result;
}
```

## Safety Guarantees

Mog's embedding model provides several layers of safety:

**No raw pointers.** Mog scripts cannot construct or dereference pointers. The only way to hold a host resource is through an opaque `MOG_HANDLE`, and the host controls what operations are valid on it.

**No system calls without capabilities.** There is no `syscall()`, no `exec()`, no way to touch the OS except through capability functions the host explicitly registered. Chapter 14 explains the capability model in detail.

**GC-managed memory.** The script cannot leak memory or cause use-after-free. The VM's garbage collector handles all allocations.

**Cooperative interrupts.** The compiler inserts interrupt checks at every loop back-edge. An infinite loop can always be stopped by the host — no need for SIGKILL or process termination.

**Capability validation.** Before execution, `mog_validate_capabilities()` confirms that every capability the script requires is registered. Missing capabilities are caught before a single instruction runs.

## Practical Example: Embedding in a Game Server

Consider a game server that lets players write Mog scripts to customize NPC behavior. The host exposes a `game` capability:

### The `.mogdecl` File

```
capability game {
  fn get_npc_health(npc_id: int) -> int
  fn get_npc_position(npc_id: int) -> string
  fn move_npc(npc_id: int, x: int, y: int)
  fn npc_say(npc_id: int, message: string)
  fn get_nearest_player(npc_id: int) -> int
  fn distance_to(npc_id: int, target_id: int) -> int
}
```

### The Host Implementation (C)

```c
static MogValue game_get_npc_health(MogVM *vm, MogArgs *args) {
  (void)vm;
  int64_t npc_id = mog_arg_int(args, 0);
  NPC *npc = find_npc(npc_id);
  if (!npc) return mog_error("unknown npc");
  return mog_int(npc->health);
}

static MogValue game_move_npc(MogVM *vm, MogArgs *args) {
  (void)vm;
  int64_t npc_id = mog_arg_int(args, 0);
  int64_t x = mog_arg_int(args, 1);
  int64_t y = mog_arg_int(args, 2);
  NPC *npc = find_npc(npc_id);
  if (!npc) return mog_error("unknown npc");
  npc->x = (int)x;
  npc->y = (int)y;
  return mog_none();
}

static MogValue game_npc_say(MogVM *vm, MogArgs *args) {
  (void)vm;
  int64_t npc_id = mog_arg_int(args, 0);
  const char *msg = mog_arg_string(args, 1);
  broadcast_chat(npc_id, msg);
  return mog_none();
}

// ... remaining functions ...

static const MogCapEntry game_functions[] = {
  { "get_npc_health",    game_get_npc_health    },
  { "get_npc_position",  game_get_npc_position  },
  { "move_npc",          game_move_npc          },
  { "npc_say",           game_npc_say           },
  { "get_nearest_player",game_get_nearest_player},
  { "distance_to",       game_distance_to       },
  { NULL, NULL }
};
```

### The Player Script (Mog)

```mog
requires game;

fn tick(npc_id: int) -> int {
  health := game.get_npc_health(npc_id);

  // If low health, flee
  if health < 20 {
    game.npc_say(npc_id, "I must retreat!");
    game.move_npc(npc_id, 0, 0);  // move to safe zone
    return 0;
  }

  // Otherwise, approach the nearest player
  player := game.get_nearest_player(npc_id);
  dist := game.distance_to(npc_id, player);

  if dist < 5 {
    game.npc_say(npc_id, "Welcome, traveler!");
  }

  return 0;
}
```

### The Host Runner

```c
void run_npc_script(const char *script_path, int npc_id) {
  MogVM *vm = mog_vm_new();
  mog_register_capability(vm, "game", game_functions);
  mog_vm_set_global(vm);

  // Player scripts get 50ms max — one game tick
  MogLimits limits = { .max_cpu_ms = 50 };
  mog_vm_set_limits(vm, &limits);

  mog_arm_timeout(50);
  int result = program_user();

  if (result == MOG_INTERRUPT_CODE) {
    log_warning("npc %d script timed out", npc_id);
  }

  mog_vm_free(vm);
}
```

The script has access to exactly the game functions the host provides. It cannot read files, access the network, or inspect other NPCs' internal state beyond what `game` exposes. The 50ms timeout prevents a buggy script from stalling the server tick.

## Summary

| API Function | Purpose |
|---|---|
| `mog_vm_new()` | Create a VM instance |
| `mog_vm_set_global(vm)` | Set the global VM pointer |
| `mog_vm_free(vm)` | Destroy the VM |
| `mog_register_capability(vm, name, entries)` | Register a capability |
| `mog_register_posix_host(vm)` | Register built-in `fs` + `process` |
| `mog_validate_capabilities(vm, caps)` | Check all required capabilities exist |
| `mog_vm_set_limits(vm, &limits)` | Set resource limits |
| `mog_arm_timeout(ms)` | Arm a timeout timer |
| `mog_request_interrupt()` | Request script termination |
| `mog_cap_call(vm, cap, fn, args, n)` | Call a capability from C |
| `mog_int(v)`, `mog_string(s)`, ... | Construct a MogValue |
| `mog_arg_int(args, i)`, ... | Extract an argument |

The embedding model is intentionally simple: create, configure, run, destroy. The host is always in control — it decides what capabilities exist, how long scripts can run, and when to stop them. The script operates in a sandbox defined entirely by the host.
