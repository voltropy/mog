/* ============================================================
 * Mog Language Showcase with Host Embedding
 * Demonstrates all major language features + host capabilities
 * ============================================================ */

requires env;
requires fs;
requires process;

// ============================================================
// 1. FUNCTIONS - basic, recursive, nested
// ============================================================

fn add(a: i64, b: i64) -> i64 {
  return a + b;
}

fn factorial(n: i64) -> i64 {
  if (n <= 1) {
    return 1;
  }
  return n * factorial(n - 1);
}

fn fibonacci(n: i64) -> i64 {
  if (n <= 0) { return 0; }
  if (n == 1) { return 1; }
  a: i64 = 0;
  b: i64 = 1;
  i: i64 = 2;
  while (i <= n) {
    temp: i64 = a + b;
    a = b;
    b = temp;
    i := i + 1;
  }
  return b;
}

// ============================================================
// 2. STRUCTS - declaration, creation, field access/mutation
// ============================================================

struct Point {
  x: f64,
  y: f64
}

struct Particle {
  x: f64,
  y: f64,
  mass: f64
}

fn create_point(x: f64, y: f64) -> Point {
  return Point { x: x, y: y };
}

fn distance_sq(p: Point) -> f64 {
  return p.x * p.x + p.y * p.y;
}

// ============================================================
// 3. ASYNC FUNCTIONS - for the async/await showcase section
// ============================================================

// Simulate an async computation (runs eagerly, completes inline)
async fn async_add(a: i64, b: i64) -> i64 {
  return a + b;
}

// Chain of async calls: double a value
async fn async_double(x: i64) -> i64 {
  return x * 2;
}

// Nested async: adds then doubles
async fn add_then_double(a: i64, b: i64) -> i64 {
  sum: i64 = await async_add(a, b);
  result: i64 = await async_double(sum);
  return result;
}

// Async factorial (recursive async is interesting because each
// level returns a Future that the caller awaits)
async fn async_factorial(n: i64) -> i64 {
  if (n <= 1) {
    return 1;
  }
  sub: i64 = await async_factorial(n - 1);
  return n * sub;
}

// Async fibonacci (iterative, but uses await for each step)
async fn async_fib_step(a: i64, b: i64) -> i64 {
  return a + b;
}

async fn async_fibonacci(n: i64) -> i64 {
  if (n <= 1) {
    return n;
  }
  a: i64 = 0;
  b: i64 = 1;
  i: i64 = 2;
  while (i <= n) {
    next: i64 = await async_fib_step(a, b);
    a = b;
    b = next;
    i = i + 1;
  }
  return b;
}

// Tasks for parallel execution with all()
async fn task_alpha() -> i64 {
  return 100;
}

async fn task_beta() -> i64 {
  return 200;
}

async fn task_gamma() -> i64 {
  return 300;
}

// Tasks for race() - first to complete wins
async fn fast_path() -> i64 {
  return 1;
}

async fn slow_path() -> i64 {
  return 999;
}

// Async pipeline: fetch -> transform -> validate
async fn fetch_value() -> i64 {
  return 21;
}

async fn transform(x: i64) -> i64 {
  doubled: i64 = await async_double(x);
  return doubled;
}

async fn validate(x: i64) -> i64 {
  if (x > 0) {
    return x;
  }
  return 0;
}

async fn pipeline() -> i64 {
  raw: i64 = await fetch_value();
  transformed: i64 = await transform(raw);
  validated: i64 = await validate(transformed);
  return validated;
}

// ============================================================
// 4. RESULT & OPTIONAL - error handling
// ============================================================

fn safe_divide(a: i64, b: i64) -> Result<i64> {
  if b == 0 {
    return err("division by zero");
  }
  return ok(a / b);
}

fn find_positive(n: i64) -> ?i64 {
  if n > 0 {
    return some(n);
  }
  return none;
}

fn chain_divide(a: i64, b: i64, c: i64) -> Result<i64> {
  step1: i64 = safe_divide(a, b)?;
  step2: i64 = safe_divide(step1, c)?;
  return ok(step2);
}

// ============================================================
// 5. MAIN - entry point (async to support await)
// ============================================================

async fn main() -> i64 {

  // --- Section: Basic Variables & Arithmetic ---
  print_string("=== Variables & Arithmetic ===\n");

  x: i64 = 42;
  y: i64 = 13;
  sum: i64 = x + y;
  diff: i64 = x - y;
  prod: i64 = x * y;
  quot: i64 = x / y;
  rem: i64 = x % y;

  print_string(f"  42 + 13 = {sum}\n");
  print_string(f"  42 - 13 = {diff}\n");
  print_string(f"  42 * 13 = {prod}\n");
  print_string(f"  42 / 13 = {quot}\n");
  print_string(f"  42 % 13 = {rem}\n");
  print_string("\n");

  // --- Section: Float Arithmetic ---
  print_string("=== Float Arithmetic ===\n");

  a: f64 = 3.14;
  b: f64 = 2.71;
  fsum: f64 = a + b;
  fprod: f64 = a * b;

  print_string("  3.14 + 2.71 = ");
  print_f64(fsum);
  print_string("\n");
  print_string("  3.14 * 2.71 = ");
  print_f64(fprod);
  print_string("\n\n");

  // --- Section: Bitwise Operators ---
  print_string("=== Bitwise Operators ===\n");

  bw_and: i64 = 255 & 15;
  bw_or: i64 = 240 | 15;
  bw_xor: i64 = 255 ^ 15;
  bw_shl: i64 = 1 << 8;
  bw_shr: i64 = 256 >> 4;

  print_string(f"  255 & 15 = {bw_and}\n");
  print_string(f"  240 | 15 = {bw_or}\n");
  print_string(f"  255 ^ 15 = {bw_xor}\n");
  print_string(f"  1 << 8 = {bw_shl}\n");
  print_string(f"  256 >> 4 = {bw_shr}\n");
  print_string("\n");

  // --- Section: Functions ---
  print_string("=== Functions ===\n");

  r: i64 = add(10, 32);
  print_string(f"  add(10, 32) = {r}\n");

  f5: i64 = factorial(5);
  print_string(f"  factorial(5) = {f5}\n");

  f10: i64 = factorial(10);
  print_string(f"  factorial(10) = {f10}\n");

  fib10: i64 = fibonacci(10);
  print_string(f"  fibonacci(10) = {fib10}\n");

  fib20: i64 = fibonacci(20);
  print_string(f"  fibonacci(20) = {fib20}\n");
  print_string("\n");

  // --- Section: Strings & Interpolation ---
  print_string("=== Strings & Interpolation ===\n");

  greeting: [u8] = "Hello, Mog!";
  print_string(f"  {greeting}\n");

  name: [u8] = "World";
  print_string(f"  Hello, {name}!\n");

  val: i64 = 99;
  print_string(f"  The answer is {val}\n");
  print_string("\n");

  // --- Section: String Methods ---
  print_string("=== String Methods ===\n");

  s: [u8] = "hello world";

  upper: [u8] = s.upper();
  print_string(f"  upper: {upper}\n");

  lower: [u8] = upper.lower();
  print_string(f"  lower: {lower}\n");

  padded: [u8] = "  trimmed  ";
  trimmed: [u8] = padded.trim();
  print_string(f"  trim: [{trimmed}]\n");

  replaced: [u8] = s.replace("world", "mog");
  print_string(f"  replace: {replaced}\n");

  print_string(f"  len('hello world') = {s.len}\n");
  print_string("\n");

  // --- Section: If/Else ---
  print_string("=== If/Else ===\n");

  test_val: i64 = 42;
  if (test_val > 0) {
    print_string("  42 > 0: true\n");
  } else {
    print_string("  42 > 0: false\n");
  }

  if (test_val < 0) {
    print_string("  42 < 0: true\n");
  } else {
    print_string("  42 < 0: false\n");
  }
  print_string("\n");

  // --- Section: While Loop ---
  print_string("=== While Loop ===\n");

  wsum: i64 = 0;
  wi: i64 = 1;
  while (wi <= 10) {
    wsum := wsum + wi;
    wi := wi + 1;
  }
  print_string(f"  sum(1..10) = {wsum}\n");
  print_string("\n");

  // --- Section: For-In Range ---
  print_string("=== For-In Range ===\n");

  fsum2: i64 = 0;
  for fi in 0..10 {
    fsum2 := fsum2 + fi;
  }
  print_string(f"  sum(0..10) = {fsum2}\n");
  print_string("\n");

  // --- Section: Break & Continue ---
  print_string("=== Break & Continue ===\n");

  bsum: i64 = 0;
  for bi in 0..100 {
    if (bi > 5) {
      break;
    }
    bsum := bsum + bi;
  }
  print_string(f"  break at 5, sum = {bsum}\n");

  csum: i64 = 0;
  for ci in 0..10 {
    if (ci == 5) {
      continue;
    }
    csum := csum + ci;
  }
  print_string(f"  skip 5, sum = {csum}\n");
  print_string("\n");

  // --- Section: Structs ---
  print_string("=== Structs ===\n");

  p1: Point = Point { x: 3.0, y: 4.0 };
  print_string("  Point(3, 4).x = ");
  print_f64(p1.x);
  print_string("\n");
  print_string("  Point(3, 4).y = ");
  print_f64(p1.y);
  print_string("\n");

  dsq: f64 = distance_sq(p1);
  print_string("  distance_sq = ");
  print_f64(dsq);
  print_string("\n");

  p2: Point = create_point(1.5, 2.5);
  print_string("  create_point(1.5, 2.5).x = ");
  print_f64(p2.x);
  print_string("\n");

  particle: Particle = Particle { x: 0.0, y: 0.0, mass: 1.5 };
  particle.x := 10.0;
  particle.y := 20.0;
  print_string("  particle after mutation: x=");
  print_f64(particle.x);
  print_string(" y=");
  print_f64(particle.y);
  print_string(" mass=");
  print_f64(particle.mass);
  print_string("\n\n");

  // --- Section: Arrays ---
  print_string("=== Arrays ===\n");

  arr: i64[] = [10, 20, 30, 40, 50];
  print_string(f"  arr[0] = {arr[0]}\n");
  print_string(f"  arr[4] = {arr[4]}\n");

  print_string(f"  arr.len = {arr.len}\n");

  arr.push(60);
  print_string(f"  after push(60), len = {arr.len}\n");
  print_string("\n");

  // --- Section: Match Expression ---
  print_string("=== Match Expression ===\n");

  mval: i64 = 2;
  mresult: i64 = match mval {
    1 => 10,
    2 => 20,
    3 => 30,
    _ => 0
  };
  print_string(f"  match 2: {mresult}\n");

  mval2: i64 = 99;
  mresult2: i64 = match mval2 {
    1 => 100,
    _ => 999
  };
  print_string(f"  match 99 (wildcard): {mresult2}\n");
  print_string("\n");

  // --- Section: If-Expression ---
  print_string("=== If-Expression ===\n");

  ival: i64 = 10;
  iresult: i64 = if ival > 5 { 1; } else { 0; };
  print_string(f"  if 10 > 5: {iresult}\n");

  iresult2: i64 = if ival > 100 { 1; } else { 0; };
  print_string(f"  if 10 > 100: {iresult2}\n");
  print_string("\n");

  // --- Section: Result Type ---
  print_string("=== Result Type ===\n");

  // ok and err constructors
  res1: Result<i64> = safe_divide(10, 3);
  if res1 is ok(div_ok) {
    print_string(f"  10 / 3 = {div_ok}\n");
  }

  res2: Result<i64> = safe_divide(10, 0);
  if res2 is err(div_err) {
    print_string("  10 / 0 = err (division by zero)\n");
  }

  // ? propagation through chain_divide
  res3: Result<i64> = chain_divide(100, 5, 2);
  if res3 is ok(chain_ok) {
    print_string(f"  100 / 5 / 2 = {chain_ok}\n");
  }

  res4: Result<i64> = chain_divide(100, 0, 2);
  if res4 is err(chain_err) {
    print_string("  100 / 0 / 2 = err (propagated)\n");
  }

  // match on Result
  res5: Result<i64> = safe_divide(42, 6);
  rdesc: i64 = match res5 {
    ok(rval) => rval,
    err(rmsg) => 0
  };
  print_string(f"  match ok(42/6): {rdesc}\n");

  res6: Result<i64> = safe_divide(42, 0);
  rdesc2: i64 = match res6 {
    ok(rval2) => rval2,
    err(rmsg2) => 0
  };
  print_string(f"  match err(42/0): {rdesc2}\n");
  print_string("\n");

  // --- Section: Optional Type ---
  print_string("=== Optional Type ===\n");

  // some and none
  o1: ?i64 = find_positive(42);
  if o1 is some(found) {
    print_string(f"  find_positive(42) = {found}\n");
  }

  o2: ?i64 = find_positive(-5);
  if o2 is none {
    print_string("  find_positive(-5) = none\n");
  }

  // match on Optional
  o3: ?i64 = some(99);
  oval: i64 = match o3 {
    some(sv) => sv,
    none => 0
  };
  print_string(f"  match some(99): {oval}\n");

  o4: ?i64 = none;
  oval2: i64 = match o4 {
    some(sv2) => sv2,
    none => 0
  };
  print_string(f"  match none: {oval2}\n");
  print_string("\n");

  // --- Section: Math Builtins ---
  print_string("=== Math Builtins ===\n");

  sq: f64 = sqrt(4.0);
  print_string("  sqrt(4.0) = ");
  print_f64(sq);
  print_string("\n");

  sn: f64 = sin(0.0);
  print_string("  sin(0.0) = ");
  print_f64(sn);
  print_string("\n");

  cs: f64 = cos(0.0);
  print_string("  cos(0.0) = ");
  print_f64(cs);
  print_string("\n");

  pi_val: f64 = PI;
  print_string("  PI = ");
  print_f64(pi_val);
  print_string("\n");

  e_val: f64 = E;
  print_string("  E = ");
  print_f64(e_val);
  print_string("\n");

  sin_pi: f64 = sin(PI);
  print_string("  sin(PI) = ");
  print_f64(sin_pi);
  print_string("\n\n");

  // --- Section: Host Capability (env) ---
  print_string("=== Host Capability: env ===\n");

  await env.log("  [env.log] Hello from the host!");

  hname: ptr = await env.get_name();
  print_string(f"  env.get_name() = {hname}\n");

  hver: i64 = await env.get_version();
  print_string(f"  env.get_version() = {hver}\n");

  hts: i64 = await env.timestamp();
  print_string(f"  env.timestamp() = {hts}\n");

  rnd: i64 = await env.random(1, 100);
  print_string(f"  env.random(1, 100) = {rnd}\n");
  print_string("\n");

  // --- Section: SoA (Struct of Arrays) ---
  print_string("=== SoA (Struct of Arrays) ===\n");

  struct Datum { id: i64, val: i64 }
  datums := soa Datum[10];
  datums[0].id = 1;
  datums[0].val = 100;
  datums[1].id = 2;
  datums[1].val = 200;

  print_string(f"  datums[0].id = {datums[0].id}\n");
  print_string(f"  datums[1].val = {datums[1].val}\n");
  print_string("\n");

  // --- Section: Closures ---
  print_string("=== Closures ===\n");

  // Non-capturing lambda
  double := fn(x: i64) -> i64 { x * 2 };
  print_string(f"  double(21) = {double(21)}\n");

  // Closure capturing a variable (value capture)
  offset: i64 = 100;
  add_offset := fn(x: i64) -> i64 { x + offset };
  print_string(f"  add_offset(42) = {add_offset(42)}\n");

  // make_adder pattern
  fn make_adder(n: i64) -> fn(i64) -> i64 {
    return fn(x: i64) -> i64 { x + n };
  }
  add5 := make_adder(5);
  add10 := make_adder(10);
  print_string(f"  add5(3) = {add5(3)}\n");
  print_string(f"  add10(3) = {add10(3)}\n");

  // Higher-order: passing closure as argument
  fn apply(f: fn(i64) -> i64, x: i64) -> i64 {
    return f(x);
  }
  print_string(f"  apply(double, 7) = {apply(double, 7)}\n");
  print_string("\n");

  // --- Section: String Type ---
  print_string("=== String Type ===\n");
  name2: string = "Mog";
  greeting2: string = f"Hello, {name2}!";
  print_string(f"  greeting: {greeting2}\n");
  num_str: string = str(42);
  print_string(f"  str(42) = {num_str}\n");
  print_string("\n");

  // --- Section: Map Iteration ---
  print_string("=== Map Iteration ===\n");
  scores := {"alice": 95, "bob": 87, "carol": 92};
  for key, value in scores {
    print_string(f"  {key}: {value}\n");
  }
  print_string("\n");

  // --- Section: Tensors ---
  print_string("=== Tensors ===\n");
  ta := tensor<f32>([3], [1.0, 2.0, 3.0]);
  tb := tensor<f32>([3], [4.0, 5.0, 6.0]);
  tc := ta + tb;
  print_string("  a + b = ");
  tensor_print(tc);
  ts: f64 = ta.sum();
  print_string("  a.sum() = ");
  print_f64(ts);
  print_string("\n");

  // Matrix multiply
  m1 := tensor<f32>([2, 3], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
  m2 := tensor<f32>([3, 2], [7.0, 8.0, 9.0, 10.0, 11.0, 12.0]);
  m3 := matmul(m1, m2);
  print_string("  matmul = ");
  tensor_print(m3);
  print_string("\n");

  // --- Section: File System Capability ---
  print_string("=== File System (fs capability) ===\n");
  // Write a file
  await fs.write_file("/tmp/mog_test.txt", "Hello from Mog!");
  print_string("  Wrote /tmp/mog_test.txt\n");

  // Check if it exists
  exists_val: bool = await fs.exists("/tmp/mog_test.txt");
  print_string("  File exists: ");
  if exists_val {
    print_string("true");
  } else {
    print_string("false");
  }
  print_string("\n");

  // Read it back
  contents: string = await fs.read_file("/tmp/mog_test.txt");
  print_string("  Contents: ");
  print_string(contents);
  print_string("\n");

  // Get file size
  sz: int = await fs.file_size("/tmp/mog_test.txt");
  print_string("  File size: ");
  print(sz);
  print_string(" bytes\n");

  // Clean up
  await fs.remove("/tmp/mog_test.txt");
  print_string("  Cleaned up test file\n");
  print_string("\n");

  // --- Section: Process Capability ---
  print_string("=== Process (process capability) ===\n");
  // Get current working directory
  cwd_val: string = await process.cwd();
  print_string("  CWD: ");
  print_string(cwd_val);
  print_string("\n");

  // Get timestamp
  ts_val: int = await process.timestamp();
  print_string("  Timestamp: ");
  print(ts_val);
  print_string(" ms\n");

  // Get environment variable
  home_val: string = await process.getenv("HOME");
  print_string("  HOME: ");
  print_string(home_val);
  print_string("\n");
  print_string("\n");

  // --- Section: Async/Await ---
  print_string("=== Async/Await ===\n");
  print_string("  (powered by LLVM coroutine intrinsics + host event loop)\n");
  print_string("\n");

  // 1. Basic await - call an async function and get the result
  r1: i64 = await async_add(20, 22);
  print_string(f"  await async_add(20, 22) = {r1}\n");

  // 2. Nested async - add_then_double calls async_add then async_double
  r2: i64 = await add_then_double(10, 11);
  print_string(f"  await add_then_double(10, 11) = {r2}\n");

  // 3. Recursive async - factorial with each level returning a Future
  r3: i64 = await async_factorial(7);
  print_string(f"  await async_factorial(7) = {r3}\n");

  // 4. Sequential awaits in a loop - async fibonacci
  r4: i64 = await async_fibonacci(15);
  print_string(f"  await async_fibonacci(15) = {r4}\n");

  // 5. Pipeline pattern: fetch -> transform -> validate
  r5: i64 = await pipeline();
  print_string(f"  await pipeline() = {r5}\n");

  // 6. Parallel execution with all() - run tasks concurrently
  await all([task_alpha(), task_beta(), task_gamma()]);
  print_string("  all([alpha, beta, gamma]) completed\n");

  // 7. Race - first future to complete wins
  winner: i64 = await race([fast_path(), slow_path()]);
  print_string(f"  race([fast, slow]) winner = {winner}\n");

  // 8. Async file I/O - write, read, verify, clean up
  await fs.write_file("/tmp/mog_async_test.txt", "async file I/O works!");
  async_contents: string = await fs.read_file("/tmp/mog_async_test.txt");
  print_string(f"  async fs round-trip: {async_contents}\n");
  await fs.remove("/tmp/mog_async_test.txt");

  // 9. Timed operation with process.sleep
  t_before: i64 = await process.timestamp();
  await process.sleep(25);
  t_after: i64 = await process.timestamp();
  elapsed: i64 = t_after - t_before;
  print_string(f"  process.sleep(25ms): elapsed = {elapsed}ms\n");
  print_string("\n");

  // --- Summary ---
  print_string("=== Showcase Complete ===\n");
  print_string("All features demonstrated successfully!\n");

  return 0;
}
