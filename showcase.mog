/* ============================================================
 * Mog Language Showcase with Host Embedding
 * Demonstrates all major language features + host capabilities
 * ============================================================ */

requires env;
requires fs;
requires process;

// ============================================================
// 1. FUNCTIONS - basic, recursive, nested
// ============================================================

fn add(a: i64, b: i64) -> i64 {
  return a + b;
}

fn factorial(n: i64) -> i64 {
  if (n <= 1) {
    return 1;
  }
  return n * factorial(n - 1);
}

fn fibonacci(n: i64) -> i64 {
  if (n <= 0) { return 0; }
  if (n == 1) { return 1; }
  a: i64 = 0;
  b: i64 = 1;
  i: i64 = 2;
  while (i <= n) {
    temp: i64 = a + b;
    a = b;
    b = temp;
    i := i + 1;
  }
  return b;
}

// ============================================================
// 2. STRUCTS - declaration, creation, field access/mutation
// ============================================================

struct Point {
  x: f64,
  y: f64
}

struct Particle {
  x: f64,
  y: f64,
  mass: f64
}

fn create_point(x: f64, y: f64) -> Point {
  return Point { x: x, y: y };
}

fn distance_sq(p: Point) -> f64 {
  return p.x * p.x + p.y * p.y;
}

// ============================================================
// 3. ASYNC FUNCTIONS - for the async/await showcase section
// ============================================================

// Simulate an async computation (runs eagerly, completes inline)
async fn async_add(a: i64, b: i64) -> i64 {
  return a + b;
}

// Chain of async calls: double a value
async fn async_double(x: i64) -> i64 {
  return x * 2;
}

// Nested async: adds then doubles
async fn add_then_double(a: i64, b: i64) -> i64 {
  sum: i64 = await async_add(a, b);
  result: i64 = await async_double(sum);
  return result;
}

// Async factorial (recursive async is interesting because each
// level returns a Future that the caller awaits)
async fn async_factorial(n: i64) -> i64 {
  if (n <= 1) {
    return 1;
  }
  sub: i64 = await async_factorial(n - 1);
  return n * sub;
}

// Async fibonacci (iterative, but uses await for each step)
async fn async_fib_step(a: i64, b: i64) -> i64 {
  return a + b;
}

async fn async_fibonacci(n: i64) -> i64 {
  if (n <= 1) {
    return n;
  }
  a: i64 = 0;
  b: i64 = 1;
  i: i64 = 2;
  while (i <= n) {
    next: i64 = await async_fib_step(a, b);
    a = b;
    b = next;
    i = i + 1;
  }
  return b;
}

// Tasks for parallel execution with all()
async fn task_alpha() -> i64 {
  return 100;
}

async fn task_beta() -> i64 {
  return 200;
}

async fn task_gamma() -> i64 {
  return 300;
}

// Tasks for race() - first to complete wins
async fn fast_path() -> i64 {
  return 1;
}

async fn slow_path() -> i64 {
  return 999;
}

// Async pipeline: fetch -> transform -> validate
async fn fetch_value() -> i64 {
  return 21;
}

async fn transform(x: i64) -> i64 {
  doubled: i64 = await async_double(x);
  return doubled;
}

async fn validate(x: i64) -> i64 {
  if (x > 0) {
    return x;
  }
  return 0;
}

async fn pipeline() -> i64 {
  raw: i64 = await fetch_value();
  transformed: i64 = await transform(raw);
  validated: i64 = await validate(transformed);
  return validated;
}

// ============================================================
// 4. RESULT & OPTIONAL - error handling
// ============================================================

fn safe_divide(a: i64, b: i64) -> Result<i64> {
  if b == 0 {
    return err("division by zero");
  }
  return ok(a / b);
}

fn find_positive(n: i64) -> ?i64 {
  if n > 0 {
    return some(n);
  }
  return none;
}

fn chain_divide(a: i64, b: i64, c: i64) -> Result<i64> {
  step1: i64 = safe_divide(a, b)?;
  step2: i64 = safe_divide(step1, c)?;
  return ok(step2);
}

// ============================================================
// 5. MAIN - entry point (async to support await)
// ============================================================

async fn main() -> i64 {

  // --- Section: Basic Variables & Arithmetic ---
  println("=== Variables & Arithmetic ===");

  x: i64 = 42;
  y: i64 = 13;
  sum: i64 = x + y;
  diff: i64 = x - y;
  prod: i64 = x * y;
  quot: i64 = x / y;
  rem: i64 = x % y;

  println(f"  42 + 13 = {sum}");
  println(f"  42 - 13 = {diff}");
  println(f"  42 * 13 = {prod}");
  println(f"  42 / 13 = {quot}");
  println(f"  42 % 13 = {rem}");
  println("");

  // --- Section: Float Arithmetic ---
  println("=== Float Arithmetic ===");

  a: f64 = 3.14;
  b: f64 = 2.71;
  fsum: f64 = a + b;
  fprod: f64 = a * b;

  print_string("  3.14 + 2.71 = ");
  print_f64(fsum);
  println("");
  print_string("  3.14 * 2.71 = ");
  print_f64(fprod);
  println("\n");

  // --- Section: Bitwise Operators ---
  println("=== Bitwise Operators ===");

  bw_and: i64 = 255 & 15;
  bw_or: i64 = 240 | 15;
  bw_xor: i64 = 255 ^ 15;
  bw_shl: i64 = 1 << 8;
  bw_shr: i64 = 256 >> 4;

  println(f"  255 & 15 = {bw_and}");
  println(f"  240 | 15 = {bw_or}");
  println(f"  255 ^ 15 = {bw_xor}");
  println(f"  1 << 8 = {bw_shl}");
  println(f"  256 >> 4 = {bw_shr}");
  println("");

  // --- Section: Functions ---
  println("=== Functions ===");

  r: i64 = add(10, 32);
  println(f"  add(10, 32) = {r}");

  f5: i64 = factorial(5);
  println(f"  factorial(5) = {f5}");

  f10: i64 = factorial(10);
  println(f"  factorial(10) = {f10}");

  fib10: i64 = fibonacci(10);
  println(f"  fibonacci(10) = {fib10}");

  fib20: i64 = fibonacci(20);
  println(f"  fibonacci(20) = {fib20}");
  println("");

  // --- Section: Strings & Interpolation ---
  println("=== Strings & Interpolation ===");

  greeting: [u8] = "Hello, Mog!";
  println(f"  {greeting}");

  name: [u8] = "World";
  println(f"  Hello, {name}!");

  val: i64 = 99;
  println(f"  The answer is {val}");
  println("");

  // --- Section: String Methods ---
  println("=== String Methods ===");

  s: [u8] = "hello world";

  upper: [u8] = s.upper();
  println(f"  upper: {upper}");

  lower: [u8] = upper.lower();
  println(f"  lower: {lower}");

  padded: [u8] = "  trimmed  ";
  trimmed: [u8] = padded.trim();
  println(f"  trim: [{trimmed}]");

  replaced: [u8] = s.replace("world", "mog");
  println(f"  replace: {replaced}");

  println(f"  len('hello world') = {s.len}");
  println("");

  // --- Section: If/Else ---
  println("=== If/Else ===");

  test_val: i64 = 42;
  if (test_val > 0) {
    println("  42 > 0: true");
  } else {
    println("  42 > 0: false");
  }

  if (test_val < 0) {
    println("  42 < 0: true");
  } else {
    println("  42 < 0: false");
  }
  println("");

  // --- Section: While Loop ---
  println("=== While Loop ===");

  wsum: i64 = 0;
  wi: i64 = 1;
  while (wi <= 10) {
    wsum := wsum + wi;
    wi := wi + 1;
  }
  println(f"  sum(1..10) = {wsum}");
  println("");

  // --- Section: For-In Range ---
  println("=== For-In Range ===");

  fsum2: i64 = 0;
  for fi in 0..10 {
    fsum2 := fsum2 + fi;
  }
  println(f"  sum(0..10) = {fsum2}");
  println("");

  // --- Section: Break & Continue ---
  println("=== Break & Continue ===");

  bsum: i64 = 0;
  for bi in 0..100 {
    if (bi > 5) {
      break;
    }
    bsum := bsum + bi;
  }
  println(f"  break at 5, sum = {bsum}");

  csum: i64 = 0;
  for ci in 0..10 {
    if (ci == 5) {
      continue;
    }
    csum := csum + ci;
  }
  println(f"  skip 5, sum = {csum}");
  println("");

  // --- Section: Structs ---
  println("=== Structs ===");

  p1: Point = Point { x: 3.0, y: 4.0 };
  print_string("  Point(3, 4).x = ");
  print_f64(p1.x);
  println("");
  print_string("  Point(3, 4).y = ");
  print_f64(p1.y);
  println("");

  dsq: f64 = distance_sq(p1);
  print_string("  distance_sq = ");
  print_f64(dsq);
  println("");

  p2: Point = create_point(1.5, 2.5);
  print_string("  create_point(1.5, 2.5).x = ");
  print_f64(p2.x);
  println("");

  particle: Particle = Particle { x: 0.0, y: 0.0, mass: 1.5 };
  particle.x := 10.0;
  particle.y := 20.0;
  println(f"  particle after mutation: x={particle.x} y={particle.y} mass={particle.mass}");
  println("\n");

  // --- Section: Arrays ---
  println("=== Arrays ===");

  arr: i64[] = [10, 20, 30, 40, 50];
  println(f"  arr[0] = {arr[0]}");
  println(f"  arr[4] = {arr[4]}");

  println(f"  arr.len = {arr.len}");

  arr.push(60);
  println(f"  after push(60), len = {arr.len}");
  println("");

  // --- Section: Match Expression ---
  println("=== Match Expression ===");

  mval: i64 = 2;
  mresult: i64 = match mval {
    1 => 10,
    2 => 20,
    3 => 30,
    _ => 0
  };
  println(f"  match 2: {mresult}");

  mval2: i64 = 99;
  mresult2: i64 = match mval2 {
    1 => 100,
    _ => 999
  };
  println(f"  match 99 (wildcard): {mresult2}");
  println("");

  // --- Section: If-Expression ---
  println("=== If-Expression ===");

  ival: i64 = 10;
  iresult: i64 = if ival > 5 { 1; } else { 0; };
  println(f"  if 10 > 5: {iresult}");

  iresult2: i64 = if ival > 100 { 1; } else { 0; };
  println(f"  if 10 > 100: {iresult2}");
  println("");

  // --- Section: Result Type ---
  println("=== Result Type ===");

  // ok and err constructors
  res1: Result<i64> = safe_divide(10, 3);
  if res1 is ok(div_ok) {
    println(f"  10 / 3 = {div_ok}");
  }

  res2: Result<i64> = safe_divide(10, 0);
  if res2 is err(div_err) {
    println("  10 / 0 = err (division by zero)");
  }

  // ? propagation through chain_divide
  res3: Result<i64> = chain_divide(100, 5, 2);
  if res3 is ok(chain_ok) {
    println(f"  100 / 5 / 2 = {chain_ok}");
  }

  res4: Result<i64> = chain_divide(100, 0, 2);
  if res4 is err(chain_err) {
    println("  100 / 0 / 2 = err (propagated)");
  }

  // match on Result
  res5: Result<i64> = safe_divide(42, 6);
  rdesc: i64 = match res5 {
    ok(rval) => rval,
    err(rmsg) => 0
  };
  println(f"  match ok(42/6): {rdesc}");

  res6: Result<i64> = safe_divide(42, 0);
  rdesc2: i64 = match res6 {
    ok(rval2) => rval2,
    err(rmsg2) => 0
  };
  println(f"  match err(42/0): {rdesc2}");
  println("");

  // --- Section: Optional Type ---
  println("=== Optional Type ===");

  // some and none
  o1: ?i64 = find_positive(42);
  if o1 is some(found) {
    println(f"  find_positive(42) = {found}");
  }

  o2: ?i64 = find_positive(-5);
  if o2 is none {
    println("  find_positive(-5) = none");
  }

  // match on Optional
  o3: ?i64 = some(99);
  oval: i64 = match o3 {
    some(sv) => sv,
    none => 0
  };
  println(f"  match some(99): {oval}");

  o4: ?i64 = none;
  oval2: i64 = match o4 {
    some(sv2) => sv2,
    none => 0
  };
  println(f"  match none: {oval2}");
  println("");

  // --- Section: Math Builtins ---
  println("=== Math Builtins ===");

  sq: f64 = sqrt(4.0);
  print_string("  sqrt(4.0) = ");
  print_f64(sq);
  println("");

  sn: f64 = sin(0.0);
  print_string("  sin(0.0) = ");
  print_f64(sn);
  println("");

  cs: f64 = cos(0.0);
  print_string("  cos(0.0) = ");
  print_f64(cs);
  println("");

  pi_val: f64 = PI;
  print_string("  PI = ");
  print_f64(pi_val);
  println("");

  e_val: f64 = E;
  print_string("  E = ");
  print_f64(e_val);
  println("");

  sin_pi: f64 = sin(PI);
  print_string("  sin(PI) = ");
  print_f64(sin_pi);
  println("\n");

  // --- Section: Host Capability (env) ---
  println("=== Host Capability: env ===");

  await env.log("  [env.log] Hello from the host!");

  hname: ptr = await env.get_name();
  println(f"  env.get_name() = {hname}");

  hver: i64 = await env.get_version();
  println(f"  env.get_version() = {hver}");

  hts: i64 = await env.timestamp();
  println(f"  env.timestamp() = {hts}");

  rnd: i64 = await env.random(1, 100);
  println(f"  env.random(1, 100) = {rnd}");
  println("");

  // --- Section: SoA (Struct of Arrays) ---
  println("=== SoA (Struct of Arrays) ===");

  struct Datum { id: i64, val: i64 }
  datums := soa Datum[10];
  datums[0].id = 1;
  datums[0].val = 100;
  datums[1].id = 2;
  datums[1].val = 200;

  println(f"  datums[0].id = {datums[0].id}");
  println(f"  datums[1].val = {datums[1].val}");
  println("");

  // --- Section: Closures ---
  println("=== Closures ===");

  // Non-capturing lambda
  double := fn(x: i64) -> i64 { x * 2 };
  println(f"  double(21) = {double(21)}");

  // Closure capturing a variable (value capture)
  offset: i64 = 100;
  add_offset := fn(x: i64) -> i64 { x + offset };
  println(f"  add_offset(42) = {add_offset(42)}");

  // make_adder pattern
  fn make_adder(n: i64) -> fn(i64) -> i64 {
    return fn(x: i64) -> i64 { x + n };
  }
  add5 := make_adder(5);
  add10 := make_adder(10);
  println(f"  add5(3) = {add5(3)}");
  println(f"  add10(3) = {add10(3)}");

  // Higher-order: passing closure as argument
  fn apply(f: fn(i64) -> i64, x: i64) -> i64 {
    return f(x);
  }
  println(f"  apply(double, 7) = {apply(double, 7)}");
  println("");

  // --- Section: String Type ---
  println("=== String Type ===");
  name2: string = "Mog";
  greeting2: string = f"Hello, {name2}!";
  println(f"  greeting: {greeting2}");
  num_str: string = str(42);
  println(f"  str(42) = {num_str}");
  println("");

  // --- Section: Map Iteration ---
  println("=== Map Iteration ===");
  scores := {"alice": 95, "bob": 87, "carol": 92};
  for key, value in scores {
    println(f"  {key}: {value}");
  }
  println("");

  // --- Section: Tensors ---
  println("=== Tensors ===");
  ta := tensor<f32>([3], [1.0, 2.0, 3.0]);
  tb := tensor<f32>([3], [4.0, 5.0, 6.0]);
  tc := ta + tb;
  print_string("  a + b = ");
  tensor_print(tc);
  ts: f64 = ta.sum();
  print_string("  a.sum() = ");
  print_f64(ts);
  println("");

  // Matrix multiply
  m1 := tensor<f32>([2, 3], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
  m2 := tensor<f32>([3, 2], [7.0, 8.0, 9.0, 10.0, 11.0, 12.0]);
  m3 := matmul(m1, m2);
  print_string("  matmul = ");
  tensor_print(m3);
  println("");

  // --- Section: File System Capability ---
  println("=== File System (fs capability) ===");
  // Write a file
  await fs.write_file("/tmp/mog_test.txt", "Hello from Mog!");
  println("  Wrote /tmp/mog_test.txt");

  // Check if it exists
  exists_val: bool = await fs.exists("/tmp/mog_test.txt");
  print_string("  File exists: ");
  if exists_val {
    print_string("true");
  } else {
    print_string("false");
  }
  println("");

  // Read it back
  contents: string = await fs.read_file("/tmp/mog_test.txt");
  print_string("  Contents: ");
  print_string(contents);
  println("");

  // Get file size
  sz: int = await fs.file_size("/tmp/mog_test.txt");
  print_string("  File size: ");
  print(sz);
  println(" bytes");

  // Clean up
  await fs.remove("/tmp/mog_test.txt");
  println("  Cleaned up test file");
  println("");

  // --- Section: Process Capability ---
  println("=== Process (process capability) ===");
  // Get current working directory
  cwd_val: string = await process.cwd();
  print_string("  CWD: ");
  print_string(cwd_val);
  println("");

  // Get timestamp
  ts_val: int = await process.timestamp();
  print_string("  Timestamp: ");
  print(ts_val);
  println(" ms");

  // Get environment variable
  home_val: string = await process.getenv("HOME");
  print_string("  HOME: ");
  print_string(home_val);
  println("");
  println("");

  // --- Section: Async/Await ---
  println("=== Async/Await ===");
  println("  (powered by LLVM coroutine intrinsics + host event loop)");
  println("");

  // 1. Basic await - call an async function and get the result
  r1: i64 = await async_add(20, 22);
  println(f"  await async_add(20, 22) = {r1}");

  // 2. Nested async - add_then_double calls async_add then async_double
  r2: i64 = await add_then_double(10, 11);
  println(f"  await add_then_double(10, 11) = {r2}");

  // 3. Recursive async - factorial with each level returning a Future
  r3: i64 = await async_factorial(7);
  println(f"  await async_factorial(7) = {r3}");

  // 4. Sequential awaits in a loop - async fibonacci
  r4: i64 = await async_fibonacci(15);
  println(f"  await async_fibonacci(15) = {r4}");

  // 5. Pipeline pattern: fetch -> transform -> validate
  r5: i64 = await pipeline();
  println(f"  await pipeline() = {r5}");

  // 6. Parallel execution with all() - run tasks concurrently
  await all([task_alpha(), task_beta(), task_gamma()]);
  println("  all([alpha, beta, gamma]) completed");

  // 7. Race - first future to complete wins
  winner: i64 = await race([fast_path(), slow_path()]);
  println(f"  race([fast, slow]) winner = {winner}");

  // 8. Async file I/O - write, read, verify, clean up
  await fs.write_file("/tmp/mog_async_test.txt", "async file I/O works!");
  async_contents: string = await fs.read_file("/tmp/mog_async_test.txt");
  println(f"  async fs round-trip: {async_contents}");
  await fs.remove("/tmp/mog_async_test.txt");

  // 9. Timed operation with process.sleep
  t_before: i64 = await process.timestamp();
  await process.sleep(25);
  t_after: i64 = await process.timestamp();
  elapsed: i64 = t_after - t_before;
  println(f"  process.sleep(25ms): elapsed = {elapsed}ms");
  println("");

  // --- Section: Custom Host Async Function ---
  println("=== Custom Host Async (env.delay_square) ===");
  println("  (host computes result, delivers via event loop timer)");

  // 10. Basic async host call — host squares the value after a delay
  sq1: i64 = await env.delay_square(7, 10);
  println(f"  await env.delay_square(7, 10ms) = {sq1}");

  // 11. Timed async host call — verify the delay actually happens
  t1: i64 = await process.timestamp();
  sq2: i64 = await env.delay_square(12, 30);
  t2: i64 = await process.timestamp();
  sq_elapsed: i64 = t2 - t1;
  println(f"  await env.delay_square(12, 30ms) = {sq2} (took {sq_elapsed}ms)");

  // 12. Multiple async host calls — fire sequentially and collect results
  a1: i64 = await env.delay_square(3, 5);
  a2: i64 = await env.delay_square(4, 5);
  a3: i64 = await env.delay_square(5, 5);
  host_sum: i64 = a1 + a2 + a3;
  println(f"  3²+4²+5² = {a1}+{a2}+{a3} = {host_sum}");
  println("");

  // --- Summary ---
  println("=== Showcase Complete ===");
  println("All features demonstrated successfully!");

  return 0;
}
