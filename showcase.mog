/* ============================================================
 * Mog Language Showcase with Host Embedding
 * Demonstrates all major language features + host capabilities
 * ============================================================ */

requires env;

// ============================================================
// 1. FUNCTIONS - basic, recursive, nested
// ============================================================

fn add(a: i64, b: i64) -> i64 {
  return a + b;
}

fn factorial(n: i64) -> i64 {
  if (n <= 1) {
    return 1;
  }
  return n * factorial(n - 1);
}

fn fibonacci(n: i64) -> i64 {
  if (n <= 0) { return 0; }
  if (n == 1) { return 1; }
  a: i64 = 0;
  b: i64 = 1;
  i: i64 = 2;
  while (i <= n) {
    temp: i64 = a + b;
    a = b;
    b = temp;
    i := i + 1;
  }
  return b;
}

// ============================================================
// 2. STRUCTS - declaration, creation, field access/mutation
// ============================================================

struct Point {
  x: f64,
  y: f64
}

struct Particle {
  x: f64,
  y: f64,
  mass: f64
}

fn create_point(x: f64, y: f64) -> Point {
  return Point { x: x, y: y };
}

fn distance_sq(p: Point) -> f64 {
  return p.x * p.x + p.y * p.y;
}

// ============================================================
// 3. MAIN - entry point
// ============================================================

fn main() -> i64 {

  // --- Section: Basic Variables & Arithmetic ---
  print_string("=== Variables & Arithmetic ===\n");

  x: i64 = 42;
  y: i64 = 13;
  sum: i64 = x + y;
  diff: i64 = x - y;
  prod: i64 = x * y;
  quot: i64 = x / y;
  rem: i64 = x % y;

  print_string(f"  42 + 13 = {sum}\n");
  print_string(f"  42 - 13 = {diff}\n");
  print_string(f"  42 * 13 = {prod}\n");
  print_string(f"  42 / 13 = {quot}\n");
  print_string(f"  42 % 13 = {rem}\n");
  print_string("\n");

  // --- Section: Float Arithmetic ---
  print_string("=== Float Arithmetic ===\n");

  a: f64 = 3.14;
  b: f64 = 2.71;
  fsum: f64 = a + b;
  fprod: f64 = a * b;

  print_string("  3.14 + 2.71 = ");
  print_f64(fsum);
  print_string("\n");
  print_string("  3.14 * 2.71 = ");
  print_f64(fprod);
  print_string("\n\n");

  // --- Section: Bitwise Operators ---
  print_string("=== Bitwise Operators ===\n");

  bw_and: i64 = 255 & 15;
  bw_or: i64 = 240 | 15;
  bw_xor: i64 = 255 ^ 15;
  bw_shl: i64 = 1 << 8;
  bw_shr: i64 = 256 >> 4;

  print_string(f"  255 & 15 = {bw_and}\n");
  print_string(f"  240 | 15 = {bw_or}\n");
  print_string(f"  255 ^ 15 = {bw_xor}\n");
  print_string(f"  1 << 8 = {bw_shl}\n");
  print_string(f"  256 >> 4 = {bw_shr}\n");
  print_string("\n");

  // --- Section: Functions ---
  print_string("=== Functions ===\n");

  r: i64 = add(10, 32);
  print_string(f"  add(10, 32) = {r}\n");

  f5: i64 = factorial(5);
  print_string(f"  factorial(5) = {f5}\n");

  f10: i64 = factorial(10);
  print_string(f"  factorial(10) = {f10}\n");

  fib10: i64 = fibonacci(10);
  print_string(f"  fibonacci(10) = {fib10}\n");

  fib20: i64 = fibonacci(20);
  print_string(f"  fibonacci(20) = {fib20}\n");
  print_string("\n");

  // --- Section: Strings & Interpolation ---
  print_string("=== Strings & Interpolation ===\n");

  greeting: [u8] = "Hello, Mog!";
  print_string(f"  {greeting}\n");

  name: [u8] = "World";
  print_string(f"  Hello, {name}!\n");

  val: i64 = 99;
  print_string(f"  The answer is {val}\n");
  print_string("\n");

  // --- Section: String Methods ---
  print_string("=== String Methods ===\n");

  s: [u8] = "hello world";

  upper: [u8] = s.upper();
  print_string(f"  upper: {upper}\n");

  lower: [u8] = upper.lower();
  print_string(f"  lower: {lower}\n");

  padded: [u8] = "  trimmed  ";
  trimmed: [u8] = padded.trim();
  print_string(f"  trim: [{trimmed}]\n");

  replaced: [u8] = s.replace("world", "mog");
  print_string(f"  replace: {replaced}\n");

  print_string(f"  len('hello world') = {s.len}\n");
  print_string("\n");

  // --- Section: If/Else ---
  print_string("=== If/Else ===\n");

  test_val: i64 = 42;
  if (test_val > 0) {
    print_string("  42 > 0: true\n");
  } else {
    print_string("  42 > 0: false\n");
  }

  if (test_val < 0) {
    print_string("  42 < 0: true\n");
  } else {
    print_string("  42 < 0: false\n");
  }
  print_string("\n");

  // --- Section: While Loop ---
  print_string("=== While Loop ===\n");

  wsum: i64 = 0;
  wi: i64 = 1;
  while (wi <= 10) {
    wsum := wsum + wi;
    wi := wi + 1;
  }
  print_string(f"  sum(1..10) = {wsum}\n");
  print_string("\n");

  // --- Section: For-In Range ---
  print_string("=== For-In Range ===\n");

  fsum2: i64 = 0;
  for fi in 0..10 {
    fsum2 := fsum2 + fi;
  }
  print_string(f"  sum(0..10) = {fsum2}\n");
  print_string("\n");

  // --- Section: Break & Continue ---
  print_string("=== Break & Continue ===\n");

  bsum: i64 = 0;
  for bi in 0..100 {
    if (bi > 5) {
      break;
    }
    bsum := bsum + bi;
  }
  print_string(f"  break at 5, sum = {bsum}\n");

  csum: i64 = 0;
  for ci in 0..10 {
    if (ci == 5) {
      continue;
    }
    csum := csum + ci;
  }
  print_string(f"  skip 5, sum = {csum}\n");
  print_string("\n");

  // --- Section: Structs ---
  print_string("=== Structs ===\n");

  p1: Point = Point { x: 3.0, y: 4.0 };
  print_string("  Point(3, 4).x = ");
  print_f64(p1.x);
  print_string("\n");
  print_string("  Point(3, 4).y = ");
  print_f64(p1.y);
  print_string("\n");

  dsq: f64 = distance_sq(p1);
  print_string("  distance_sq = ");
  print_f64(dsq);
  print_string("\n");

  p2: Point = create_point(1.5, 2.5);
  print_string("  create_point(1.5, 2.5).x = ");
  print_f64(p2.x);
  print_string("\n");

  particle: Particle = Particle { x: 0.0, y: 0.0, mass: 1.5 };
  particle.x := 10.0;
  particle.y := 20.0;
  print_string("  particle after mutation: x=");
  print_f64(particle.x);
  print_string(" y=");
  print_f64(particle.y);
  print_string(" mass=");
  print_f64(particle.mass);
  print_string("\n\n");

  // --- Section: Arrays ---
  print_string("=== Arrays ===\n");

  arr: i64[] = [10, 20, 30, 40, 50];
  print_string(f"  arr[0] = {arr[0]}\n");
  print_string(f"  arr[4] = {arr[4]}\n");

  print_string(f"  arr.len = {arr.len}\n");

  arr.push(60);
  print_string(f"  after push(60), len = {arr.len}\n");
  print_string("\n");

  // --- Section: Match Expression ---
  print_string("=== Match Expression ===\n");

  mval: i64 = 2;
  mresult: i64 = match mval {
    1 => 10,
    2 => 20,
    3 => 30,
    _ => 0
  };
  print_string(f"  match 2: {mresult}\n");

  mval2: i64 = 99;
  mresult2: i64 = match mval2 {
    1 => 100,
    _ => 999
  };
  print_string(f"  match 99 (wildcard): {mresult2}\n");
  print_string("\n");

  // --- Section: If-Expression ---
  print_string("=== If-Expression ===\n");

  ival: i64 = 10;
  iresult: i64 = if ival > 5 { 1; } else { 0; };
  print_string(f"  if 10 > 5: {iresult}\n");

  iresult2: i64 = if ival > 100 { 1; } else { 0; };
  print_string(f"  if 10 > 100: {iresult2}\n");
  print_string("\n");

  // --- Section: Math Builtins ---
  print_string("=== Math Builtins ===\n");

  sq: f64 = sqrt(4.0);
  print_string("  sqrt(4.0) = ");
  print_f64(sq);
  print_string("\n");

  sn: f64 = sin(0.0);
  print_string("  sin(0.0) = ");
  print_f64(sn);
  print_string("\n");

  cs: f64 = cos(0.0);
  print_string("  cos(0.0) = ");
  print_f64(cs);
  print_string("\n");

  pi_val: f64 = PI;
  print_string("  PI = ");
  print_f64(pi_val);
  print_string("\n");

  e_val: f64 = E;
  print_string("  E = ");
  print_f64(e_val);
  print_string("\n");

  sin_pi: f64 = sin(PI);
  print_string("  sin(PI) = ");
  print_f64(sin_pi);
  print_string("\n\n");

  // --- Section: Host Capability (env) ---
  print_string("=== Host Capability: env ===\n");

  env.log("  [env.log] Hello from the host!");

  hname: ptr = env.get_name();
  print_string(f"  env.get_name() = {hname}\n");

  hver: i64 = env.get_version();
  print_string(f"  env.get_version() = {hver}\n");

  hts: i64 = env.timestamp();
  print_string(f"  env.timestamp() = {hts}\n");

  rnd: i64 = env.random(1, 100);
  print_string(f"  env.random(1, 100) = {rnd}\n");
  print_string("\n");

  // --- Section: SoA (Struct of Arrays) ---
  print_string("=== SoA (Struct of Arrays) ===\n");

  struct Datum { id: i64, val: i64 }
  datums := soa Datum[10];
  datums[0].id = 1;
  datums[0].val = 100;
  datums[1].id = 2;
  datums[1].val = 200;

  print_string(f"  datums[0].id = {datums[0].id}\n");
  print_string(f"  datums[1].val = {datums[1].val}\n");
  print_string("\n");

  // --- Section: Closures ---
  print_string("=== Closures ===\n");

  // Non-capturing lambda
  double := fn(x: i64) -> i64 { x * 2 };
  print_string(f"  double(21) = {double(21)}\n");

  // Closure capturing a variable (value capture)
  offset: i64 = 100;
  add_offset := fn(x: i64) -> i64 { x + offset };
  print_string(f"  add_offset(42) = {add_offset(42)}\n");

  // make_adder pattern
  fn make_adder(n: i64) -> fn(i64) -> i64 {
    return fn(x: i64) -> i64 { x + n };
  }
  add5 := make_adder(5);
  add10 := make_adder(10);
  print_string(f"  add5(3) = {add5(3)}\n");
  print_string(f"  add10(3) = {add10(3)}\n");

  // Higher-order: passing closure as argument
  fn apply(f: fn(i64) -> i64, x: i64) -> i64 {
    return f(x);
  }
  print_string(f"  apply(double, 7) = {apply(double, 7)}\n");
  print_string("\n");

  // --- Section: String Type ---
  print_string("=== String Type ===\n");
  name2: string = "Mog";
  greeting2: string = f"Hello, {name2}!";
  print_string(f"  greeting: {greeting2}\n");
  num_str: string = str(42);
  print_string(f"  str(42) = {num_str}\n");
  print_string("\n");

  // --- Section: Map Iteration ---
  print_string("=== Map Iteration ===\n");
  scores := {"alice": 95, "bob": 87, "carol": 92};
  for key, value in scores {
    print_string(f"  {key}: {value}\n");
  }
  print_string("\n");

  // --- Section: Tensors ---
  print_string("=== Tensors ===\n");
  ta := tensor<f32>([3], [1.0, 2.0, 3.0]);
  tb := tensor<f32>([3], [4.0, 5.0, 6.0]);
  tc := ta + tb;
  print_string("  a + b = ");
  tensor_print(tc);
  ts: f64 = ta.sum();
  print_string("  a.sum() = ");
  print_f64(ts);
  print_string("\n");

  // Matrix multiply
  m1 := tensor<f32>([2, 3], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);
  m2 := tensor<f32>([3, 2], [7.0, 8.0, 9.0, 10.0, 11.0, 12.0]);
  m3 := matmul(m1, m2);
  print_string("  matmul = ");
  tensor_print(m3);
  print_string("\n");

  // --- Section: Async/Await ---
  print_string("=== Async/Await ===\n");
  // Note: async currently uses synchronous fallback
  print_string("  (async support ready, uses sync fallback)\n");
  print_string("\n");

  // --- Summary ---
  print_string("=== Showcase Complete ===\n");
  print_string("All features demonstrated successfully!\n");

  return 0;
}
